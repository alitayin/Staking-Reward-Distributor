"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteWitnessUtxoForNonSegwitInputs = exports.clonePsbtWithoutNonWitnessUtxo = exports.extractP2msOnlyHalfSignedTx = exports.getSignatureValidationArrayPsbt = exports.addXpubsToPsbt = exports.isTransactionWithKeyPathSpendInput = exports.isTxInputArray = exports.isPsbtInputArray = exports.getStrictSignatureCounts = exports.getStrictSignatureCount = exports.parsePsbtInput = exports.getPsbtInputScriptType = exports.signWalletPsbt = exports.toWalletPsbt = void 0;
const assert = require("assert");
const utils_1 = require("bip174/src/lib/utils");
const bs58check = require("bs58check");
const UtxoPsbt_1 = require("../UtxoPsbt");
const UtxoTransaction_1 = require("../UtxoTransaction");
const outputScripts_1 = require("../outputScripts");
const WalletKeys_1 = require("./WalletKeys");
const Unspent_1 = require("../Unspent");
const transaction_1 = require("../transaction");
const Unspent_2 = require("./Unspent");
const parseInput_1 = require("../parseInput");
const Musig2_1 = require("../Musig2");
const types_1 = require("../types");
const taproot_1 = require("../../taproot");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const index_1 = require("../../index");
const PsbtUtil_1 = require("../PsbtUtil");
function getTaprootSigners(script, walletKeys) {
    const parsedPublicKeys = parseInput_1.parsePubScript2Of3(script, 'taprootScriptPathSpend').publicKeys;
    const walletSigners = parsedPublicKeys.map((publicKey) => {
        const index = walletKeys.publicKeys.findIndex((walletPublicKey) => outputScripts_1.toXOnlyPublicKey(walletPublicKey).equals(publicKey));
        if (index >= 0) {
            return { walletKey: walletKeys.triple[index], rootKey: walletKeys.parent.triple[index] };
        }
        throw new Error('Taproot public key is not a wallet public key');
    });
    return [walletSigners[0], walletSigners[1]];
}
function updatePsbtInput(psbt, inputIndex, unspent, rootWalletKeys) {
    const input = utils_1.checkForInput(psbt.data.inputs, inputIndex);
    const signatureCount = PsbtUtil_1.getPsbtInputSignatureCount(input);
    const scriptType = outputScripts_1.scriptTypeForChain(unspent.chain);
    if (signatureCount === 0 && scriptType === 'p2tr') {
        return;
    }
    const walletKeys = rootWalletKeys.deriveForChainAndIndex(unspent.chain, unspent.index);
    if (scriptType === 'p2tr') {
        if (!Array.isArray(input.tapLeafScript) || input.tapLeafScript.length === 0) {
            throw new Error('Invalid PSBT state. Missing required fields.');
        }
        if (input.tapLeafScript.length > 1) {
            throw new Error('Bitgo only supports a single tap leaf script per input');
        }
        const [signer, cosigner] = getTaprootSigners(input.tapLeafScript[0].script, walletKeys);
        const leafHash = outputScripts_1.getLeafHash({
            publicKeys: walletKeys.publicKeys,
            signer: signer.walletKey.publicKey,
            cosigner: cosigner.walletKey.publicKey,
        });
        psbt.updateInput(inputIndex, {
            tapBip32Derivation: [signer, cosigner].map((walletSigner) => ({
                leafHashes: [leafHash],
                pubkey: outputScripts_1.toXOnlyPublicKey(walletSigner.walletKey.publicKey),
                path: rootWalletKeys.getDerivationPath(walletSigner.rootKey, unspent.chain, unspent.index),
                masterFingerprint: walletSigner.rootKey.fingerprint,
            })),
        });
    }
    else {
        if (signatureCount === 0) {
            const { witnessScript, redeemScript } = outputScripts_1.createOutputScript2of3(walletKeys.publicKeys, scriptType);
            if (witnessScript && psbt.data.inputs[inputIndex].witnessScript === undefined) {
                psbt.updateInput(inputIndex, { witnessScript });
            }
            if (redeemScript && psbt.data.inputs[inputIndex].redeemScript === undefined) {
                psbt.updateInput(inputIndex, { redeemScript });
            }
        }
        psbt.updateInput(inputIndex, {
            bip32Derivation: [0, 1, 2].map((idx) => ({
                pubkey: walletKeys.triple[idx].publicKey,
                path: walletKeys.paths[idx],
                masterFingerprint: rootWalletKeys.triple[idx].fingerprint,
            })),
        });
    }
}
/**
 * @return PSBT filled with metatdata as per input params tx, unspents and rootWalletKeys.
 * Unsigned PSBT for taproot input with witnessUtxo
 * Unsigned PSBT for other input with witnessUtxo/nonWitnessUtxo, redeemScript/witnessScript, bip32Derivation
 * Signed PSBT for taproot input with witnessUtxo, tapLeafScript, tapBip32Derivation, tapScriptSig
 * Signed PSBT for other input with witnessUtxo/nonWitnessUtxo, redeemScript/witnessScript, bip32Derivation, partialSig
 */
function toWalletPsbt(tx, unspents, rootWalletKeys) {
    const prevOutputs = unspents.map((u) => {
        assert.notStrictEqual(outputScripts_1.scriptTypeForChain(u.chain), 'p2trMusig2');
        return Unspent_1.toPrevOutputWithPrevTx(u, tx.network);
    });
    const psbt = transaction_1.createPsbtFromTransaction(tx, prevOutputs);
    unspents.forEach((u, i) => {
        if (Unspent_2.isWalletUnspent(u) && u.index !== undefined) {
            updatePsbtInput(psbt, i, u, rootWalletKeys);
        }
    });
    return psbt;
}
exports.toWalletPsbt = toWalletPsbt;
/**
 * @param psbt
 * @param inputIndex
 * @param signer
 * @param unspent
 * @return signed PSBT with signer's key for unspent
 */
function signWalletPsbt(psbt, inputIndex, signer, unspent) {
    const scriptType = outputScripts_1.scriptTypeForChain(unspent.chain);
    if (scriptType === 'p2tr' || scriptType === 'p2trMusig2') {
        psbt.signTaprootInputHD(inputIndex, signer);
    }
    else {
        psbt.signInputHD(inputIndex, signer);
    }
}
exports.signWalletPsbt = signWalletPsbt;
/**
 * @returns script type of the input
 */
function getPsbtInputScriptType(input) {
    const isP2pk = (script) => {
        try {
            const chunks = bitcoinjs_lib_1.script.decompile(script);
            return ((chunks === null || chunks === void 0 ? void 0 : chunks.length) === 2 &&
                Buffer.isBuffer(chunks[0]) &&
                bitcoinjs_lib_1.script.isCanonicalPubKey(chunks[0]) &&
                chunks[1] === index_1.opcodes.OP_CHECKSIG);
        }
        catch (e) {
            return false;
        }
    };
    let scriptType;
    if (Buffer.isBuffer(input.redeemScript) && Buffer.isBuffer(input.witnessScript)) {
        scriptType = 'p2shP2wsh';
    }
    else if (Buffer.isBuffer(input.redeemScript)) {
        scriptType = isP2pk(input.redeemScript) ? 'p2shP2pk' : 'p2sh';
    }
    else if (Buffer.isBuffer(input.witnessScript)) {
        scriptType = 'p2wsh';
    }
    if (Array.isArray(input.tapLeafScript) && input.tapLeafScript.length > 0) {
        if (scriptType) {
            throw new Error(`Found both ${scriptType} and taprootScriptPath PSBT metadata.`);
        }
        if (input.tapLeafScript.length > 1) {
            throw new Error('Bitgo only supports a single tap leaf script per input.');
        }
        scriptType = 'taprootScriptPathSpend';
    }
    if (input.tapInternalKey) {
        if (scriptType) {
            throw new Error(`Found both ${scriptType} and taprootKeyPath PSBT metadata.`);
        }
        scriptType = 'taprootKeyPathSpend';
    }
    if (scriptType) {
        return scriptType;
    }
    throw new Error('could not parse input');
}
exports.getPsbtInputScriptType = getPsbtInputScriptType;
function parseTaprootKeyPathSignatures(input) {
    const partialSigs = Musig2_1.parsePsbtMusig2PartialSigs(input);
    if (!partialSigs) {
        return { signatures: undefined, participantPublicKeys: undefined };
    }
    const signatures = partialSigs.map((pSig) => pSig.partialSig);
    const participantPublicKeys = partialSigs.map((pSig) => pSig.participantPubKey);
    return types_1.isTuple(signatures) && types_1.isTuple(participantPublicKeys)
        ? { signatures, participantPublicKeys }
        : { signatures: [signatures[0]], participantPublicKeys: [participantPublicKeys[0]] };
}
function parsePartialOrTapScriptSignatures(sig) {
    if (!(sig === null || sig === void 0 ? void 0 : sig.length)) {
        return { signatures: undefined };
    }
    if (sig.length > 2) {
        throw new Error('unexpected signature count');
    }
    const signatures = sig.map((tSig) => tSig.signature);
    return types_1.isTuple(signatures) ? { signatures } : { signatures: [signatures[0]] };
}
function parseSignatures(input, scriptType) {
    return scriptType === 'taprootKeyPathSpend'
        ? parseTaprootKeyPathSignatures(input)
        : scriptType === 'taprootScriptPathSpend'
            ? parsePartialOrTapScriptSignatures(input.tapScriptSig)
            : parsePartialOrTapScriptSignatures(input.partialSig);
}
function parseScript(input, scriptType) {
    var _a;
    let pubScript;
    if (scriptType === 'p2sh' || scriptType === 'p2shP2pk') {
        pubScript = input.redeemScript;
    }
    else if (scriptType === 'p2wsh' || scriptType === 'p2shP2wsh') {
        pubScript = input.witnessScript;
    }
    else if (scriptType === 'taprootScriptPathSpend') {
        pubScript = input.tapLeafScript ? input.tapLeafScript[0].script : undefined;
    }
    else if (scriptType === 'taprootKeyPathSpend') {
        if ((_a = input.witnessUtxo) === null || _a === void 0 ? void 0 : _a.script) {
            pubScript = input.witnessUtxo.script;
        }
        else if (input.tapInternalKey && input.tapMerkleRoot) {
            pubScript = taproot_1.createTaprootOutputScript({ internalPubKey: input.tapInternalKey, taptreeRoot: input.tapMerkleRoot });
        }
    }
    if (!pubScript) {
        throw new Error(`Invalid PSBT state for ${scriptType}. Missing required fields.`);
    }
    return parseInput_1.parsePubScript(pubScript, scriptType);
}
/**
 * @return psbt metadata are parsed as per below conditions.
 * redeemScript/witnessScript/tapLeafScript matches BitGo.
 * signature and public key count matches BitGo.
 * P2SH-P2PK => scriptType, redeemScript, public key, signature.
 * P2SH => scriptType, redeemScript, public keys, signatures.
 * PW2SH => scriptType, witnessScript, public keys, signatures.
 * P2SH-PW2SH => scriptType, redeemScript, witnessScript, public keys, signatures.
 * P2TR and P2TR MUSIG2 script path => scriptType (taprootScriptPathSpend), pubScript (leaf script), controlBlock,
 * scriptPathLevel, leafVersion, public keys, signatures.
 * P2TR MUSIG2 kep path => scriptType (taprootKeyPathSpend), pubScript (scriptPubKey), participant pub keys (signer),
 * public key (tapOutputkey), signatures (partial signer sigs).
 */
function parsePsbtInput(input) {
    if (PsbtUtil_1.isPsbtInputFinalized(input)) {
        throw new Error('Finalized PSBT parsing is not supported');
    }
    const scriptType = getPsbtInputScriptType(input);
    const parsedPubScript = parseScript(input, scriptType);
    const signatures = parseSignatures(input, scriptType);
    if (parsedPubScript.scriptType === 'taprootKeyPathSpend' && 'participantPublicKeys' in signatures) {
        return {
            ...parsedPubScript,
            ...signatures,
        };
    }
    if (parsedPubScript.scriptType === 'taprootScriptPathSpend') {
        if (!input.tapLeafScript) {
            throw new Error('Invalid PSBT state for taprootScriptPathSpend. Missing required fields.');
        }
        const controlBlock = input.tapLeafScript[0].controlBlock;
        if (!parseInput_1.isValidControlBock(controlBlock)) {
            throw new Error('Invalid PSBT taprootScriptPathSpend controlBlock.');
        }
        const scriptPathLevel = parseInput_1.calculateScriptPathLevel(controlBlock);
        const leafVersion = parseInput_1.getLeafVersion(controlBlock);
        return {
            ...parsedPubScript,
            ...signatures,
            controlBlock,
            scriptPathLevel,
            leafVersion,
        };
    }
    if (parsedPubScript.scriptType === 'p2sh' ||
        parsedPubScript.scriptType === 'p2wsh' ||
        parsedPubScript.scriptType === 'p2shP2wsh') {
        if (parsedPubScript.scriptType === 'p2shP2wsh') {
            parsedPubScript.redeemScript = input.redeemScript;
        }
        return {
            ...parsedPubScript,
            ...signatures,
        };
    }
    if (parsedPubScript.scriptType === 'p2shP2pk' && (!signatures.signatures || !types_1.isTuple(signatures.signatures))) {
        return {
            ...parsedPubScript,
            signatures: signatures.signatures,
        };
    }
    throw new Error('invalid pub script');
}
exports.parsePsbtInput = parsePsbtInput;
/**
 * @returns strictly parse the input and get signature count.
 * unsigned(0), half-signed(1) or fully-signed(2)
 */
function getStrictSignatureCount(input) {
    var _a, _b;
    const calculateSignatureCount = (signatures) => {
        const count = signatures ? signatures.filter((s) => !parseInput_1.isPlaceholderSignature(s)).length : 0;
        if (count === 0 || count === 1 || count === 2) {
            return count;
        }
        throw new Error('invalid signature count');
    };
    if ('hash' in input) {
        if (((_a = input.script) === null || _a === void 0 ? void 0 : _a.length) || ((_b = input.witness) === null || _b === void 0 ? void 0 : _b.length)) {
            const parsedInput = parseInput_1.parseSignatureScript(input);
            return parsedInput.scriptType === 'taprootKeyPathSpend' ? 2 : calculateSignatureCount(parsedInput.signatures);
        }
        return 0;
    }
    else {
        return calculateSignatureCount(parsePsbtInput(input).signatures);
    }
}
exports.getStrictSignatureCount = getStrictSignatureCount;
/**
 * @returns strictly parse input and get signature count for all inputs.
 * 0=unsigned, 1=half-signed or 2=fully-signed
 */
function getStrictSignatureCounts(tx) {
    const inputs = tx instanceof UtxoPsbt_1.UtxoPsbt ? tx.data.inputs : tx instanceof UtxoTransaction_1.UtxoTransaction ? tx.ins : tx;
    return inputs.map((input, _) => getStrictSignatureCount(input));
}
exports.getStrictSignatureCounts = getStrictSignatureCounts;
/**
 * @return true iff inputs array is of PsbtInputType type
 * */
function isPsbtInputArray(inputs) {
    return !isTxInputArray(inputs);
}
exports.isPsbtInputArray = isPsbtInputArray;
/**
 * @return true iff inputs array is of TxInput type
 * */
function isTxInputArray(inputs) {
    assert(!!inputs.length, 'empty inputs array');
    return 'hash' in inputs[0];
}
exports.isTxInputArray = isTxInputArray;
/**
 * @returns true iff given psbt/transaction/tx-input-array/psbt-input-array contains at least one taproot key path spend input
 */
function isTransactionWithKeyPathSpendInput(data) {
    const inputs = data instanceof UtxoPsbt_1.UtxoPsbt ? data.data.inputs : data instanceof UtxoTransaction_1.UtxoTransaction ? data.ins : data;
    if (!inputs.length) {
        return false;
    }
    if (isPsbtInputArray(inputs)) {
        return inputs.some((input, _) => getPsbtInputScriptType(input) === 'taprootKeyPathSpend');
    }
    return inputs.some((input, _) => {
        // If the input is not signed, it cannot be a taprootKeyPathSpend input because you can only
        // extract a fully signed psbt into a transaction with taprootKeyPathSpend inputs.
        if (getStrictSignatureCount(input) === 0) {
            return false;
        }
        return parseInput_1.parseSignatureScript(input).scriptType === 'taprootKeyPathSpend';
    });
}
exports.isTransactionWithKeyPathSpendInput = isTransactionWithKeyPathSpendInput;
/**
 * Set the RootWalletKeys as the globalXpubs on the psbt
 *
 * We do all the matching of the (tap)bip32Derivations masterFingerprint to the fingerprint of the
 * extendedPubkey.
 */
function addXpubsToPsbt(psbt, rootWalletKeys) {
    const safeRootWalletKeys = new WalletKeys_1.RootWalletKeys(rootWalletKeys.triple.map((bip32) => bip32.neutered()), rootWalletKeys.derivationPrefixes);
    const xPubs = safeRootWalletKeys.triple.map((bip32) => ({
        extendedPubkey: bs58check.decode(bip32.toBase58()),
        masterFingerprint: bip32.fingerprint,
        // TODO: BG-73797 - bip174 currently requires m prefix for this to be a valid globalXpub
        path: 'm',
    }));
    psbt.updateGlobal({ globalXpub: xPubs });
}
exports.addXpubsToPsbt = addXpubsToPsbt;
/**
 * validates signatures for each 2 of 3 input against user, backup, bitgo keys derived from rootWalletKeys.
 * @returns array of input index and its [is valid user sig exist, is valid backup sig exist, is valid user bitgo exist]
 * For p2shP2pk input, [false, false, false] is returned since it is not a 2 of 3 sig input.
 */
function getSignatureValidationArrayPsbt(psbt, rootWalletKeys) {
    return psbt.data.inputs.map((input, i) => {
        const sigValArrayForInput = getPsbtInputScriptType(input) === 'p2shP2pk'
            ? [false, false, false]
            : psbt.getSignatureValidationArray(i, { rootNodes: rootWalletKeys.triple });
        return [i, sigValArrayForInput];
    });
}
exports.getSignatureValidationArrayPsbt = getSignatureValidationArrayPsbt;
/**
 * Extracts the half signed transaction from the psbt for p2ms based script types - p2sh, p2wsh, and p2shP2wsh.
 * The purpose is to provide backward compatibility to keyternal (KRS) that only supports network transaction and p2ms script types.
 */
function extractP2msOnlyHalfSignedTx(psbt) {
    assert(!!(psbt.data.inputs.length && psbt.data.outputs.length), 'empty inputs or outputs');
    const tx = psbt.getUnsignedTx();
    function isP2msParsedPsbtInput(parsed) {
        return ['p2sh', 'p2shP2wsh', 'p2wsh'].includes(parsed.scriptType);
    }
    psbt.data.inputs.forEach((input, i) => {
        var _a, _b;
        const parsed = parsePsbtInput(input);
        assert(isP2msParsedPsbtInput(parsed), `unsupported script type ${parsed.scriptType}`);
        assert(((_a = input.partialSig) === null || _a === void 0 ? void 0 : _a.length) === 1, `unexpected signature count ${(_b = input.partialSig) === null || _b === void 0 ? void 0 : _b.length}`);
        const [partialSig] = input.partialSig;
        assert(input.sighashType !== undefined && input.sighashType === bitcoinjs_lib_1.script.signature.decode(partialSig.signature).hashType, 'signature sighash does not match input sighash type');
        // type casting is to address the invalid type checking in payments.p2ms
        const signatures = parsed.publicKeys.map((pk) => partialSig.pubkey.equals(pk) ? partialSig.signature : bitcoinjs_lib_1.opcodes.OP_0);
        const isP2SH = !!parsed.redeemScript;
        const isP2WSH = !!parsed.witnessScript;
        const payment = index_1.payments.p2ms({ output: parsed.pubScript, signatures }, { validate: false, allowIncomplete: true });
        const p2wsh = isP2WSH ? index_1.payments.p2wsh({ redeem: payment }) : undefined;
        const p2sh = isP2SH ? index_1.payments.p2sh({ redeem: p2wsh || payment }) : undefined;
        if (p2sh === null || p2sh === void 0 ? void 0 : p2sh.input) {
            tx.setInputScript(i, p2sh.input);
        }
        if (p2wsh === null || p2wsh === void 0 ? void 0 : p2wsh.witness) {
            tx.setWitness(i, p2wsh.witness);
        }
    });
    return tx;
}
exports.extractP2msOnlyHalfSignedTx = extractP2msOnlyHalfSignedTx;
/**
 * Clones the psbt without nonWitnessUtxo for non-segwit inputs and witnessUtxo is added instead.
 * It is not BIP-174 compliant, so use it carefully.
 */
function clonePsbtWithoutNonWitnessUtxo(psbt) {
    const newPsbt = psbt.clone();
    const txInputs = psbt.txInputs;
    psbt.data.inputs.forEach((input, i) => {
        if (input.nonWitnessUtxo && !input.witnessUtxo) {
            const tx = UtxoTransaction_1.UtxoTransaction.fromBuffer(input.nonWitnessUtxo, false, 'bigint', psbt.network);
            if (!txInputs[i].hash.equals(tx.getHash())) {
                throw new Error(`Non-witness UTXO hash for input #${i} doesn't match the hash specified in the prevout`);
            }
            newPsbt.data.inputs[i].witnessUtxo = tx.outs[txInputs[i].index];
        }
        delete newPsbt.data.inputs[i].nonWitnessUtxo;
    });
    return newPsbt;
}
exports.clonePsbtWithoutNonWitnessUtxo = clonePsbtWithoutNonWitnessUtxo;
/**
 * Deletes witnessUtxo for non-segwit inputs to make the PSBT BIP-174 compliant.
 */
function deleteWitnessUtxoForNonSegwitInputs(psbt) {
    psbt.data.inputs.forEach((input, i) => {
        const scriptType = getPsbtInputScriptType(input);
        if (scriptType === 'p2sh' || scriptType === 'p2shP2pk') {
            delete input.witnessUtxo;
        }
    });
}
exports.deleteWitnessUtxoForNonSegwitInputs = deleteWitnessUtxoForNonSegwitInputs;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHNidC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby93YWxsZXQvUHNidC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBaUM7QUFHakMsZ0RBQXFEO0FBRXJELHVDQUF1QztBQUN2QywwQ0FBdUM7QUFDdkMsd0RBQXFEO0FBQ3JELG9EQUE2RztBQUM3Ryw2Q0FBaUU7QUFDakUsd0NBQW9EO0FBQ3BELGdEQUEyRDtBQUMzRCx1Q0FBMkQ7QUFFM0QsOENBY3VCO0FBQ3ZCLHNDQUF1RDtBQUN2RCxvQ0FBMkM7QUFDM0MsMkNBQTBEO0FBQzFELGlEQUEyRTtBQUMzRSx1Q0FBZ0Q7QUFDaEQsMENBQStFO0FBcUUvRSxTQUFTLGlCQUFpQixDQUFDLE1BQWMsRUFBRSxVQUE2QjtJQUN0RSxNQUFNLGdCQUFnQixHQUFHLCtCQUFrQixDQUFDLE1BQU0sRUFBRSx3QkFBd0IsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUN6RixNQUFNLGFBQWEsR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRTtRQUN2RCxNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQ2hFLGdDQUFnQixDQUFDLGVBQWUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FDcEQsQ0FBQztRQUNGLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtZQUNkLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztTQUMxRjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztJQUNuRSxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FB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QUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDakU7UUFDRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQztJQUMvQyxDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUM7QUFoQkQsd0VBZ0JDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixtQ0FBbUMsQ0FBQyxJQUFjO0lBQ2hFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNwQyxNQUFNLFVBQVUsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqRCxJQUFJLFVBQVUsS0FBSyxNQUFNLElBQUksVUFBVSxLQUFLLFVBQVUsRUFBRTtZQUN0RCxPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUM7U0FDMUI7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFQRCxrRkFPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5pbXBvcnQgeyBHbG9iYWxYcHViLCBQYXJ0aWFsU2lnLCBQc2J0SW5wdXQsIFRhcFNjcmlwdFNpZyB9IGZyb20gJ2JpcDE3NC9zcmMvbGliL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY2hlY2tGb3JJbnB1dCB9IGZyb20gJ2JpcDE3NC9zcmMvbGliL3V0aWxzJztcbmltcG9ydCB7IEJJUDMySW50ZXJmYWNlIH0gZnJvbSAnYmlwMzInO1xuaW1wb3J0ICogYXMgYnM1OGNoZWNrIGZyb20gJ2JzNThjaGVjayc7XG5pbXBvcnQgeyBVdHhvUHNidCB9IGZyb20gJy4uL1V0eG9Qc2J0JztcbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbiB9IGZyb20gJy4uL1V0eG9UcmFuc2FjdGlvbic7XG5pbXBvcnQgeyBjcmVhdGVPdXRwdXRTY3JpcHQyb2YzLCBnZXRMZWFmSGFzaCwgc2NyaXB0VHlwZUZvckNoYWluLCB0b1hPbmx5UHVibGljS2V5IH0gZnJvbSAnLi4vb3V0cHV0U2NyaXB0cyc7XG5pbXBvcnQgeyBEZXJpdmVkV2FsbGV0S2V5cywgUm9vdFdhbGxldEtleXMgfSBmcm9tICcuL1dhbGxldEtleXMnO1xuaW1wb3J0IHsgdG9QcmV2T3V0cHV0V2l0aFByZXZUeCB9IGZyb20gJy4uL1Vuc3BlbnQnO1xuaW1wb3J0IHsgY3JlYXRlUHNidEZyb21UcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGlzV2FsbGV0VW5zcGVudCwgV2FsbGV0VW5zcGVudCB9IGZyb20gJy4vVW5zcGVudCc7XG5cbmltcG9ydCB7XG4gIGdldExlYWZWZXJzaW9uLFxuICBjYWxjdWxhdGVTY3JpcHRQYXRoTGV2ZWwsXG4gIGlzVmFsaWRDb250cm9sQm9jayxcbiAgUGFyc2VkUHViU2NyaXB0UDJtcyxcbiAgUGFyc2VkUHViU2NyaXB0VGFwcm9vdFNjcmlwdFBhdGgsXG4gIHBhcnNlUHViU2NyaXB0Mk9mMyxcbiAgUGFyc2VkUHViU2NyaXB0VGFwcm9vdCxcbiAgUGFyc2VkUHViU2NyaXB0VGFwcm9vdEtleVBhdGgsXG4gIHBhcnNlUHViU2NyaXB0LFxuICBQYXJzZWRQdWJTY3JpcHRQMnNoUDJwayxcbiAgUGFyc2VkU2NyaXB0VHlwZSxcbiAgaXNQbGFjZWhvbGRlclNpZ25hdHVyZSxcbiAgcGFyc2VTaWduYXR1cmVTY3JpcHQsXG59IGZyb20gJy4uL3BhcnNlSW5wdXQnO1xuaW1wb3J0IHsgcGFyc2VQc2J0TXVzaWcyUGFydGlhbFNpZ3MgfSBmcm9tICcuLi9NdXNpZzInO1xuaW1wb3J0IHsgaXNUdXBsZSwgVHJpcGxlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlVGFwcm9vdE91dHB1dFNjcmlwdCB9IGZyb20gJy4uLy4uL3RhcHJvb3QnO1xuaW1wb3J0IHsgb3Bjb2RlcyBhcyBvcHMsIHNjcmlwdCBhcyBic2NyaXB0LCBUeElucHV0IH0gZnJvbSAnYml0Y29pbmpzLWxpYic7XG5pbXBvcnQgeyBvcGNvZGVzLCBwYXltZW50cyB9IGZyb20gJy4uLy4uL2luZGV4JztcbmltcG9ydCB7IGdldFBzYnRJbnB1dFNpZ25hdHVyZUNvdW50LCBpc1BzYnRJbnB1dEZpbmFsaXplZCB9IGZyb20gJy4uL1BzYnRVdGlsJztcblxuLy8gb25seSB1c2VkIGZvciBidWlsZGluZyBgU2lnbmF0dXJlQ29udGFpbmVyYFxudHlwZSBCYXNlU2lnbmF0dXJlQ29udGFpbmVyPFQ+ID0ge1xuICBzaWduYXR1cmVzOiBUO1xufTtcblxudHlwZSBVbnNpZ25lZFNpZ25hdHVyZUNvbnRhaW5lciA9IEJhc2VTaWduYXR1cmVDb250YWluZXI8dW5kZWZpbmVkPjtcbnR5cGUgSGFsZlNpZ25lZFNpZ25hdHVyZUNvbnRhaW5lciA9IEJhc2VTaWduYXR1cmVDb250YWluZXI8W0J1ZmZlcl0+O1xudHlwZSBGdWxsU2lnbmVkU2lnbmF0dXJlQ29udGFpbmVyID0gQmFzZVNpZ25hdHVyZUNvbnRhaW5lcjxbQnVmZmVyLCBCdWZmZXJdPjtcblxudHlwZSBTaWduYXR1cmVDb250YWluZXIgPSBVbnNpZ25lZFNpZ25hdHVyZUNvbnRhaW5lciB8IEhhbGZTaWduZWRTaWduYXR1cmVDb250YWluZXIgfCBGdWxsU2lnbmVkU2lnbmF0dXJlQ29udGFpbmVyO1xuXG4vKipcbiAqIENvbnRlbnRzIG9mIGEgcHJlLWZpbmFsaXplZCBQU0JUIElucHV0IGZvciBwMnRyTXVzaWcyIGtleSBwYXRoIGluIHRoZSBub24tZmluYWxpemVkIHN0YXRlLlxuICogVCBpcyBbQnVmZmVyXSBmb3IgZmlyc3Qgc2lnbmF0dXJlLCBbQnVmZmVyLCBCdWZmZXJdIGZvciBib3RoIHNpZ25hdHVyZXMgYW5kIGB1bmRlZmluZWRgIGZvciBubyBzaWduYXR1cmVzLlxuICovXG50eXBlIEJhc2VUYXByb290S2V5UGF0aFNpZ25hdHVyZUNvbnRhaW5lcjxUPiA9IHtcbiAgc2lnbmF0dXJlczogVDtcbiAgLyoqIE9ubHkgY29udGFpbnMgcGFydGljaXBhbnRzIHRoYXQgaGF2ZSBhZGRlZCBhIHNpZ25hdHVyZSAqL1xuICBwYXJ0aWNpcGFudFB1YmxpY0tleXM6IFQ7XG59O1xuXG50eXBlIFVuc2lnbmVkVGFwcm9vdEtleVBhdGhTaWduYXR1cmVDb250YWluZXIgPSBCYXNlVGFwcm9vdEtleVBhdGhTaWduYXR1cmVDb250YWluZXI8dW5kZWZpbmVkPjtcbnR5cGUgSGFsZlNpZ25lZFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyID0gQmFzZVRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyPFtCdWZmZXJdPjtcbnR5cGUgRnVsbFNpZ25lZFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyID0gQmFzZVRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyPFtCdWZmZXIsIEJ1ZmZlcl0+O1xuXG50eXBlIFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyID1cbiAgfCBVbnNpZ25lZFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyXG4gIHwgSGFsZlNpZ25lZFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyXG4gIHwgRnVsbFNpZ25lZFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyO1xuXG4vKipcbiAqIFRvIGhvbGQgcGFyc2VkIHBzYnQgZGF0YSBmb3IgcDJtcyBiYXNlZCBzY3JpcHQgdHlwZXMgLSBwMnNoLCBwMndzaCwgYW5kIHAyc2hQMndzaFxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRQc2J0UDJtcyA9IFBhcnNlZFB1YlNjcmlwdFAybXMgJiBTaWduYXR1cmVDb250YWluZXI7XG5cbi8qKlxuICogVG8gaG9sZCBwYXJzZWQgcHNidCBkYXRhIGZvciBUYXByb290S2V5UGF0aFNwZW5kIHNjcmlwdCB0eXBlLlxuICovXG5leHBvcnQgdHlwZSBQYXJzZWRQc2J0VGFwcm9vdEtleVBhdGggPSBQYXJzZWRQdWJTY3JpcHRUYXByb290S2V5UGF0aCAmIFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyO1xuXG4vKipcbiAqIFRvIGhvbGQgcGFyc2VkIHBzYnQgZGF0YSBmb3IgVGFwcm9vdFNjcmlwdFBhdGhTcGVuZCBzY3JpcHQgcGF0aCBzY3JpcHQgdHlwZS5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyc2VkUHNidFRhcHJvb3RTY3JpcHRQYXRoID0gUGFyc2VkUHViU2NyaXB0VGFwcm9vdFNjcmlwdFBhdGggJlxuICBTaWduYXR1cmVDb250YWluZXIgJiB7XG4gICAgY29udHJvbEJsb2NrOiBCdWZmZXI7XG4gICAgbGVhZlZlcnNpb246IG51bWJlcjtcbiAgICAvKiogSW5kaWNhdGVzIHRoZSBsZXZlbCBpbnNpZGUgdGhlIHRhcHRyZWUuICovXG4gICAgc2NyaXB0UGF0aExldmVsOiBudW1iZXI7XG4gIH07XG5cbmV4cG9ydCB0eXBlIFBhcnNlZFBzYnRUYXByb290ID0gUGFyc2VkUHNidFRhcHJvb3RLZXlQYXRoIHwgUGFyc2VkUHNidFRhcHJvb3RTY3JpcHRQYXRoO1xuXG50eXBlIFAyc2hQMnBrU2lnbmF0dXJlQ29udGFpbmVyID0gVW5zaWduZWRTaWduYXR1cmVDb250YWluZXIgfCBIYWxmU2lnbmVkU2lnbmF0dXJlQ29udGFpbmVyO1xuXG5leHBvcnQgdHlwZSBQYXJzZWRQc2J0UDJzaFAycGsgPSBQYXJzZWRQdWJTY3JpcHRQMnNoUDJwayAmIFAyc2hQMnBrU2lnbmF0dXJlQ29udGFpbmVyO1xuXG5pbnRlcmZhY2UgV2FsbGV0U2lnbmVyIHtcbiAgd2FsbGV0S2V5OiBCSVAzMkludGVyZmFjZTtcbiAgcm9vdEtleTogQklQMzJJbnRlcmZhY2U7XG59XG5cbi8qKlxuICogcHNidCBpbnB1dCBpbmRleCBhbmQgaXRzIHVzZXIsIGJhY2t1cCwgYml0Z28gc2lnbmF0dXJlcyBzdGF0dXNcbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmF0dXJlVmFsaWRhdGlvbiA9IFtpbmRleDogbnVtYmVyLCBzaWdUcmlwbGU6IFRyaXBsZTxib29sZWFuPl07XG5cbmZ1bmN0aW9uIGdldFRhcHJvb3RTaWduZXJzKHNjcmlwdDogQnVmZmVyLCB3YWxsZXRLZXlzOiBEZXJpdmVkV2FsbGV0S2V5cyk6IFtXYWxsZXRTaWduZXIsIFdhbGxldFNpZ25lcl0ge1xuICBjb25zdCBwYXJzZWRQdWJsaWNLZXlzID0gcGFyc2VQdWJTY3JpcHQyT2YzKHNjcmlwdCwgJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnKS5wdWJsaWNLZXlzO1xuICBjb25zdCB3YWxsZXRTaWduZXJzID0gcGFyc2VkUHVibGljS2V5cy5tYXAoKHB1YmxpY0tleSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gd2FsbGV0S2V5cy5wdWJsaWNLZXlzLmZpbmRJbmRleCgod2FsbGV0UHVibGljS2V5KSA9PlxuICAgICAgdG9YT25seVB1YmxpY0tleSh3YWxsZXRQdWJsaWNLZXkpLmVxdWFscyhwdWJsaWNLZXkpXG4gICAgKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHsgd2FsbGV0S2V5OiB3YWxsZXRLZXlzLnRyaXBsZVtpbmRleF0sIHJvb3RLZXk6IHdhbGxldEtleXMucGFyZW50LnRyaXBsZVtpbmRleF0gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXByb290IHB1YmxpYyBrZXkgaXMgbm90IGEgd2FsbGV0IHB1YmxpYyBrZXknKTtcbiAgfSk7XG4gIHJldHVybiBbd2FsbGV0U2lnbmVyc1swXSwgd2FsbGV0U2lnbmVyc1sxXV07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBzYnRJbnB1dChcbiAgcHNidDogVXR4b1BzYnQsXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgdW5zcGVudDogV2FsbGV0VW5zcGVudDxiaWdpbnQ+LFxuICByb290V2FsbGV0S2V5czogUm9vdFdhbGxldEtleXNcbik6IHZvaWQge1xuICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQocHNidC5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZ2V0UHNidElucHV0U2lnbmF0dXJlQ291bnQoaW5wdXQpO1xuICBjb25zdCBzY3JpcHRUeXBlID0gc2NyaXB0VHlwZUZvckNoYWluKHVuc3BlbnQuY2hhaW4pO1xuICBpZiAoc2lnbmF0dXJlQ291bnQgPT09IDAgJiYgc2NyaXB0VHlwZSA9PT0gJ3AydHInKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdhbGxldEtleXMgPSByb290V2FsbGV0S2V5cy5kZXJpdmVGb3JDaGFpbkFuZEluZGV4KHVuc3BlbnQuY2hhaW4sIHVuc3BlbnQuaW5kZXgpO1xuXG4gIGlmIChzY3JpcHRUeXBlID09PSAncDJ0cicpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQudGFwTGVhZlNjcmlwdCkgfHwgaW5wdXQudGFwTGVhZlNjcmlwdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQU0JUIHN0YXRlLiBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy4nKTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQudGFwTGVhZlNjcmlwdC5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdGdvIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgdGFwIGxlYWYgc2NyaXB0IHBlciBpbnB1dCcpO1xuICAgIH1cblxuICAgIGNvbnN0IFtzaWduZXIsIGNvc2lnbmVyXSA9IGdldFRhcHJvb3RTaWduZXJzKGlucHV0LnRhcExlYWZTY3JpcHRbMF0uc2NyaXB0LCB3YWxsZXRLZXlzKTtcblxuICAgIGNvbnN0IGxlYWZIYXNoID0gZ2V0TGVhZkhhc2goe1xuICAgICAgcHVibGljS2V5czogd2FsbGV0S2V5cy5wdWJsaWNLZXlzLFxuICAgICAgc2lnbmVyOiBzaWduZXIud2FsbGV0S2V5LnB1YmxpY0tleSxcbiAgICAgIGNvc2lnbmVyOiBjb3NpZ25lci53YWxsZXRLZXkucHVibGljS2V5LFxuICAgIH0pO1xuXG4gICAgcHNidC51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7XG4gICAgICB0YXBCaXAzMkRlcml2YXRpb246IFtzaWduZXIsIGNvc2lnbmVyXS5tYXAoKHdhbGxldFNpZ25lcikgPT4gKHtcbiAgICAgICAgbGVhZkhhc2hlczogW2xlYWZIYXNoXSxcbiAgICAgICAgcHVia2V5OiB0b1hPbmx5UHVibGljS2V5KHdhbGxldFNpZ25lci53YWxsZXRLZXkucHVibGljS2V5KSxcbiAgICAgICAgcGF0aDogcm9vdFdhbGxldEtleXMuZ2V0RGVyaXZhdGlvblBhdGgod2FsbGV0U2lnbmVyLnJvb3RLZXksIHVuc3BlbnQuY2hhaW4sIHVuc3BlbnQuaW5kZXgpLFxuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludDogd2FsbGV0U2lnbmVyLnJvb3RLZXkuZmluZ2VycHJpbnQsXG4gICAgICB9KSksXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25hdHVyZUNvdW50ID09PSAwKSB7XG4gICAgICBjb25zdCB7IHdpdG5lc3NTY3JpcHQsIHJlZGVlbVNjcmlwdCB9ID0gY3JlYXRlT3V0cHV0U2NyaXB0Mm9mMyh3YWxsZXRLZXlzLnB1YmxpY0tleXMsIHNjcmlwdFR5cGUpO1xuICAgICAgaWYgKHdpdG5lc3NTY3JpcHQgJiYgcHNidC5kYXRhLmlucHV0c1tpbnB1dEluZGV4XS53aXRuZXNzU2NyaXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHNidC51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHdpdG5lc3NTY3JpcHQgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVkZWVtU2NyaXB0ICYmIHBzYnQuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF0ucmVkZWVtU2NyaXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHNidC51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHJlZGVlbVNjcmlwdCB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwc2J0LnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHtcbiAgICAgIGJpcDMyRGVyaXZhdGlvbjogWzAsIDEsIDJdLm1hcCgoaWR4KSA9PiAoe1xuICAgICAgICBwdWJrZXk6IHdhbGxldEtleXMudHJpcGxlW2lkeF0ucHVibGljS2V5LFxuICAgICAgICBwYXRoOiB3YWxsZXRLZXlzLnBhdGhzW2lkeF0sXG4gICAgICAgIG1hc3RlckZpbmdlcnByaW50OiByb290V2FsbGV0S2V5cy50cmlwbGVbaWR4XS5maW5nZXJwcmludCxcbiAgICAgIH0pKSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm4gUFNCVCBmaWxsZWQgd2l0aCBtZXRhdGRhdGEgYXMgcGVyIGlucHV0IHBhcmFtcyB0eCwgdW5zcGVudHMgYW5kIHJvb3RXYWxsZXRLZXlzLlxuICogVW5zaWduZWQgUFNCVCBmb3IgdGFwcm9vdCBpbnB1dCB3aXRoIHdpdG5lc3NVdHhvXG4gKiBVbnNpZ25lZCBQU0JUIGZvciBvdGhlciBpbnB1dCB3aXRoIHdpdG5lc3NVdHhvL25vbldpdG5lc3NVdHhvLCByZWRlZW1TY3JpcHQvd2l0bmVzc1NjcmlwdCwgYmlwMzJEZXJpdmF0aW9uXG4gKiBTaWduZWQgUFNCVCBmb3IgdGFwcm9vdCBpbnB1dCB3aXRoIHdpdG5lc3NVdHhvLCB0YXBMZWFmU2NyaXB0LCB0YXBCaXAzMkRlcml2YXRpb24sIHRhcFNjcmlwdFNpZ1xuICogU2lnbmVkIFBTQlQgZm9yIG90aGVyIGlucHV0IHdpdGggd2l0bmVzc1V0eG8vbm9uV2l0bmVzc1V0eG8sIHJlZGVlbVNjcmlwdC93aXRuZXNzU2NyaXB0LCBiaXAzMkRlcml2YXRpb24sIHBhcnRpYWxTaWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvV2FsbGV0UHNidChcbiAgdHg6IFV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+LFxuICB1bnNwZW50czogV2FsbGV0VW5zcGVudDxiaWdpbnQ+W10sXG4gIHJvb3RXYWxsZXRLZXlzOiBSb290V2FsbGV0S2V5c1xuKTogVXR4b1BzYnQge1xuICBjb25zdCBwcmV2T3V0cHV0cyA9IHVuc3BlbnRzLm1hcCgodSkgPT4ge1xuICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbChzY3JpcHRUeXBlRm9yQ2hhaW4odS5jaGFpbiksICdwMnRyTXVzaWcyJyk7XG4gICAgcmV0dXJuIHRvUHJldk91dHB1dFdpdGhQcmV2VHgodSwgdHgubmV0d29yayk7XG4gIH0pO1xuICBjb25zdCBwc2J0ID0gY3JlYXRlUHNidEZyb21UcmFuc2FjdGlvbih0eCwgcHJldk91dHB1dHMpO1xuICB1bnNwZW50cy5mb3JFYWNoKCh1LCBpKSA9PiB7XG4gICAgaWYgKGlzV2FsbGV0VW5zcGVudCh1KSAmJiB1LmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVwZGF0ZVBzYnRJbnB1dChwc2J0LCBpLCB1LCByb290V2FsbGV0S2V5cyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBzYnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHBzYnRcbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gc2lnbmVyXG4gKiBAcGFyYW0gdW5zcGVudFxuICogQHJldHVybiBzaWduZWQgUFNCVCB3aXRoIHNpZ25lcidzIGtleSBmb3IgdW5zcGVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbldhbGxldFBzYnQoXG4gIHBzYnQ6IFV0eG9Qc2J0LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHNpZ25lcjogQklQMzJJbnRlcmZhY2UsXG4gIHVuc3BlbnQ6IFdhbGxldFVuc3BlbnQ8YmlnaW50PlxuKTogdm9pZCB7XG4gIGNvbnN0IHNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlRm9yQ2hhaW4odW5zcGVudC5jaGFpbik7XG4gIGlmIChzY3JpcHRUeXBlID09PSAncDJ0cicgfHwgc2NyaXB0VHlwZSA9PT0gJ3AydHJNdXNpZzInKSB7XG4gICAgcHNidC5zaWduVGFwcm9vdElucHV0SEQoaW5wdXRJbmRleCwgc2lnbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwc2J0LnNpZ25JbnB1dEhEKGlucHV0SW5kZXgsIHNpZ25lcik7XG4gIH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyBzY3JpcHQgdHlwZSBvZiB0aGUgaW5wdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBzYnRJbnB1dFNjcmlwdFR5cGUoaW5wdXQ6IFBzYnRJbnB1dCk6IFBhcnNlZFNjcmlwdFR5cGUge1xuICBjb25zdCBpc1AycGsgPSAoc2NyaXB0OiBCdWZmZXIpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUoc2NyaXB0KTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNodW5rcz8ubGVuZ3RoID09PSAyICYmXG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihjaHVua3NbMF0pICYmXG4gICAgICAgIGJzY3JpcHQuaXNDYW5vbmljYWxQdWJLZXkoY2h1bmtzWzBdKSAmJlxuICAgICAgICBjaHVua3NbMV0gPT09IG9wY29kZXMuT1BfQ0hFQ0tTSUdcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgbGV0IHNjcmlwdFR5cGU6IFBhcnNlZFNjcmlwdFR5cGUgfCB1bmRlZmluZWQ7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQucmVkZWVtU2NyaXB0KSAmJiBCdWZmZXIuaXNCdWZmZXIoaW5wdXQud2l0bmVzc1NjcmlwdCkpIHtcbiAgICBzY3JpcHRUeXBlID0gJ3Ayc2hQMndzaCc7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0LnJlZGVlbVNjcmlwdCkpIHtcbiAgICBzY3JpcHRUeXBlID0gaXNQMnBrKGlucHV0LnJlZGVlbVNjcmlwdCkgPyAncDJzaFAycGsnIDogJ3Ayc2gnO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dC53aXRuZXNzU2NyaXB0KSkge1xuICAgIHNjcmlwdFR5cGUgPSAncDJ3c2gnO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0LnRhcExlYWZTY3JpcHQpICYmIGlucHV0LnRhcExlYWZTY3JpcHQubGVuZ3RoID4gMCkge1xuICAgIGlmIChzY3JpcHRUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGJvdGggJHtzY3JpcHRUeXBlfSBhbmQgdGFwcm9vdFNjcmlwdFBhdGggUFNCVCBtZXRhZGF0YS5gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnRhcExlYWZTY3JpcHQubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRnbyBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlIHRhcCBsZWFmIHNjcmlwdCBwZXIgaW5wdXQuJyk7XG4gICAgfVxuICAgIHNjcmlwdFR5cGUgPSAndGFwcm9vdFNjcmlwdFBhdGhTcGVuZCc7XG4gIH1cbiAgaWYgKGlucHV0LnRhcEludGVybmFsS2V5KSB7XG4gICAgaWYgKHNjcmlwdFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgYm90aCAke3NjcmlwdFR5cGV9IGFuZCB0YXByb290S2V5UGF0aCBQU0JUIG1ldGFkYXRhLmApO1xuICAgIH1cbiAgICBzY3JpcHRUeXBlID0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnO1xuICB9XG4gIGlmIChzY3JpcHRUeXBlKSB7XG4gICAgcmV0dXJuIHNjcmlwdFR5cGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcGFyc2UgaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUYXByb290S2V5UGF0aFNpZ25hdHVyZXMoaW5wdXQ6IFBzYnRJbnB1dCk6IFRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlQ29udGFpbmVyIHtcbiAgY29uc3QgcGFydGlhbFNpZ3MgPSBwYXJzZVBzYnRNdXNpZzJQYXJ0aWFsU2lncyhpbnB1dCk7XG4gIGlmICghcGFydGlhbFNpZ3MpIHtcbiAgICByZXR1cm4geyBzaWduYXR1cmVzOiB1bmRlZmluZWQsIHBhcnRpY2lwYW50UHVibGljS2V5czogdW5kZWZpbmVkIH07XG4gIH1cbiAgY29uc3Qgc2lnbmF0dXJlcyA9IHBhcnRpYWxTaWdzLm1hcCgocFNpZykgPT4gcFNpZy5wYXJ0aWFsU2lnKTtcbiAgY29uc3QgcGFydGljaXBhbnRQdWJsaWNLZXlzID0gcGFydGlhbFNpZ3MubWFwKChwU2lnKSA9PiBwU2lnLnBhcnRpY2lwYW50UHViS2V5KTtcbiAgcmV0dXJuIGlzVHVwbGU8QnVmZmVyPihzaWduYXR1cmVzKSAmJiBpc1R1cGxlPEJ1ZmZlcj4ocGFydGljaXBhbnRQdWJsaWNLZXlzKVxuICAgID8geyBzaWduYXR1cmVzLCBwYXJ0aWNpcGFudFB1YmxpY0tleXMgfVxuICAgIDogeyBzaWduYXR1cmVzOiBbc2lnbmF0dXJlc1swXV0sIHBhcnRpY2lwYW50UHVibGljS2V5czogW3BhcnRpY2lwYW50UHVibGljS2V5c1swXV0gfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsT3JUYXBTY3JpcHRTaWduYXR1cmVzKHNpZzogUGFydGlhbFNpZ1tdIHwgVGFwU2NyaXB0U2lnW10gfCB1bmRlZmluZWQpOiBTaWduYXR1cmVDb250YWluZXIge1xuICBpZiAoIXNpZz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlczogdW5kZWZpbmVkIH07XG4gIH1cbiAgaWYgKHNpZy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHNpZ25hdHVyZSBjb3VudCcpO1xuICB9XG4gIGNvbnN0IHNpZ25hdHVyZXMgPSBzaWcubWFwKCh0U2lnKSA9PiB0U2lnLnNpZ25hdHVyZSk7XG4gIHJldHVybiBpc1R1cGxlPEJ1ZmZlcj4oc2lnbmF0dXJlcykgPyB7IHNpZ25hdHVyZXMgfSA6IHsgc2lnbmF0dXJlczogW3NpZ25hdHVyZXNbMF1dIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlcyhcbiAgaW5wdXQ6IFBzYnRJbnB1dCxcbiAgc2NyaXB0VHlwZTogUGFyc2VkU2NyaXB0VHlwZVxuKTogU2lnbmF0dXJlQ29udGFpbmVyIHwgVGFwcm9vdEtleVBhdGhTaWduYXR1cmVDb250YWluZXIge1xuICByZXR1cm4gc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnXG4gICAgPyBwYXJzZVRhcHJvb3RLZXlQYXRoU2lnbmF0dXJlcyhpbnB1dClcbiAgICA6IHNjcmlwdFR5cGUgPT09ICd0YXByb290U2NyaXB0UGF0aFNwZW5kJ1xuICAgID8gcGFyc2VQYXJ0aWFsT3JUYXBTY3JpcHRTaWduYXR1cmVzKGlucHV0LnRhcFNjcmlwdFNpZylcbiAgICA6IHBhcnNlUGFydGlhbE9yVGFwU2NyaXB0U2lnbmF0dXJlcyhpbnB1dC5wYXJ0aWFsU2lnKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTY3JpcHQoXG4gIGlucHV0OiBQc2J0SW5wdXQsXG4gIHNjcmlwdFR5cGU6IFBhcnNlZFNjcmlwdFR5cGVcbik6IFBhcnNlZFB1YlNjcmlwdFAybXMgfCBQYXJzZWRQdWJTY3JpcHRUYXByb290IHwgUGFyc2VkUHViU2NyaXB0UDJzaFAycGsge1xuICBsZXQgcHViU2NyaXB0OiBCdWZmZXIgfCB1bmRlZmluZWQ7XG4gIGlmIChzY3JpcHRUeXBlID09PSAncDJzaCcgfHwgc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMnBrJykge1xuICAgIHB1YlNjcmlwdCA9IGlucHV0LnJlZGVlbVNjcmlwdDtcbiAgfSBlbHNlIGlmIChzY3JpcHRUeXBlID09PSAncDJ3c2gnIHx8IHNjcmlwdFR5cGUgPT09ICdwMnNoUDJ3c2gnKSB7XG4gICAgcHViU2NyaXB0ID0gaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgfSBlbHNlIGlmIChzY3JpcHRUeXBlID09PSAndGFwcm9vdFNjcmlwdFBhdGhTcGVuZCcpIHtcbiAgICBwdWJTY3JpcHQgPSBpbnB1dC50YXBMZWFmU2NyaXB0ID8gaW5wdXQudGFwTGVhZlNjcmlwdFswXS5zY3JpcHQgOiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnKSB7XG4gICAgaWYgKGlucHV0LndpdG5lc3NVdHhvPy5zY3JpcHQpIHtcbiAgICAgIHB1YlNjcmlwdCA9IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdDtcbiAgICB9IGVsc2UgaWYgKGlucHV0LnRhcEludGVybmFsS2V5ICYmIGlucHV0LnRhcE1lcmtsZVJvb3QpIHtcbiAgICAgIHB1YlNjcmlwdCA9IGNyZWF0ZVRhcHJvb3RPdXRwdXRTY3JpcHQoeyBpbnRlcm5hbFB1YktleTogaW5wdXQudGFwSW50ZXJuYWxLZXksIHRhcHRyZWVSb290OiBpbnB1dC50YXBNZXJrbGVSb290IH0pO1xuICAgIH1cbiAgfVxuICBpZiAoIXB1YlNjcmlwdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBQU0JUIHN0YXRlIGZvciAke3NjcmlwdFR5cGV9LiBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy5gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VQdWJTY3JpcHQocHViU2NyaXB0LCBzY3JpcHRUeXBlKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHBzYnQgbWV0YWRhdGEgYXJlIHBhcnNlZCBhcyBwZXIgYmVsb3cgY29uZGl0aW9ucy5cbiAqIHJlZGVlbVNjcmlwdC93aXRuZXNzU2NyaXB0L3RhcExlYWZTY3JpcHQgbWF0Y2hlcyBCaXRHby5cbiAqIHNpZ25hdHVyZSBhbmQgcHVibGljIGtleSBjb3VudCBtYXRjaGVzIEJpdEdvLlxuICogUDJTSC1QMlBLID0+IHNjcmlwdFR5cGUsIHJlZGVlbVNjcmlwdCwgcHVibGljIGtleSwgc2lnbmF0dXJlLlxuICogUDJTSCA9PiBzY3JpcHRUeXBlLCByZWRlZW1TY3JpcHQsIHB1YmxpYyBrZXlzLCBzaWduYXR1cmVzLlxuICogUFcyU0ggPT4gc2NyaXB0VHlwZSwgd2l0bmVzc1NjcmlwdCwgcHVibGljIGtleXMsIHNpZ25hdHVyZXMuXG4gKiBQMlNILVBXMlNIID0+IHNjcmlwdFR5cGUsIHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdCwgcHVibGljIGtleXMsIHNpZ25hdHVyZXMuXG4gKiBQMlRSIGFuZCBQMlRSIE1VU0lHMiBzY3JpcHQgcGF0aCA9PiBzY3JpcHRUeXBlICh0YXByb290U2NyaXB0UGF0aFNwZW5kKSwgcHViU2NyaXB0IChsZWFmIHNjcmlwdCksIGNvbnRyb2xCbG9jayxcbiAqIHNjcmlwdFBhdGhMZXZlbCwgbGVhZlZlcnNpb24sIHB1YmxpYyBrZXlzLCBzaWduYXR1cmVzLlxuICogUDJUUiBNVVNJRzIga2VwIHBhdGggPT4gc2NyaXB0VHlwZSAodGFwcm9vdEtleVBhdGhTcGVuZCksIHB1YlNjcmlwdCAoc2NyaXB0UHViS2V5KSwgcGFydGljaXBhbnQgcHViIGtleXMgKHNpZ25lciksXG4gKiBwdWJsaWMga2V5ICh0YXBPdXRwdXRrZXkpLCBzaWduYXR1cmVzIChwYXJ0aWFsIHNpZ25lciBzaWdzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHNidElucHV0KGlucHV0OiBQc2J0SW5wdXQpOiBQYXJzZWRQc2J0UDJtcyB8IFBhcnNlZFBzYnRUYXByb290IHwgUGFyc2VkUHNidFAyc2hQMnBrIHtcbiAgaWYgKGlzUHNidElucHV0RmluYWxpemVkKGlucHV0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmluYWxpemVkIFBTQlQgcGFyc2luZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgY29uc3Qgc2NyaXB0VHlwZSA9IGdldFBzYnRJbnB1dFNjcmlwdFR5cGUoaW5wdXQpO1xuICBjb25zdCBwYXJzZWRQdWJTY3JpcHQgPSBwYXJzZVNjcmlwdChpbnB1dCwgc2NyaXB0VHlwZSk7XG4gIGNvbnN0IHNpZ25hdHVyZXMgPSBwYXJzZVNpZ25hdHVyZXMoaW5wdXQsIHNjcmlwdFR5cGUpO1xuXG4gIGlmIChwYXJzZWRQdWJTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnICYmICdwYXJ0aWNpcGFudFB1YmxpY0tleXMnIGluIHNpZ25hdHVyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkUHViU2NyaXB0LFxuICAgICAgLi4uc2lnbmF0dXJlcyxcbiAgICB9O1xuICB9XG4gIGlmIChwYXJzZWRQdWJTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnKSB7XG4gICAgaWYgKCFpbnB1dC50YXBMZWFmU2NyaXB0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUFNCVCBzdGF0ZSBmb3IgdGFwcm9vdFNjcmlwdFBhdGhTcGVuZC4gTWlzc2luZyByZXF1aXJlZCBmaWVsZHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xCbG9jayA9IGlucHV0LnRhcExlYWZTY3JpcHRbMF0uY29udHJvbEJsb2NrO1xuICAgIGlmICghaXNWYWxpZENvbnRyb2xCb2NrKGNvbnRyb2xCbG9jaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQU0JUIHRhcHJvb3RTY3JpcHRQYXRoU3BlbmQgY29udHJvbEJsb2NrLicpO1xuICAgIH1cbiAgICBjb25zdCBzY3JpcHRQYXRoTGV2ZWwgPSBjYWxjdWxhdGVTY3JpcHRQYXRoTGV2ZWwoY29udHJvbEJsb2NrKTtcbiAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGdldExlYWZWZXJzaW9uKGNvbnRyb2xCbG9jayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFB1YlNjcmlwdCxcbiAgICAgIC4uLnNpZ25hdHVyZXMsXG4gICAgICBjb250cm9sQmxvY2ssXG4gICAgICBzY3JpcHRQYXRoTGV2ZWwsXG4gICAgICBsZWFmVmVyc2lvbixcbiAgICB9O1xuICB9XG4gIGlmIChcbiAgICBwYXJzZWRQdWJTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3Ayc2gnIHx8XG4gICAgcGFyc2VkUHViU2NyaXB0LnNjcmlwdFR5cGUgPT09ICdwMndzaCcgfHxcbiAgICBwYXJzZWRQdWJTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMndzaCdcbiAgKSB7XG4gICAgaWYgKHBhcnNlZFB1YlNjcmlwdC5zY3JpcHRUeXBlID09PSAncDJzaFAyd3NoJykge1xuICAgICAgcGFyc2VkUHViU2NyaXB0LnJlZGVlbVNjcmlwdCA9IGlucHV0LnJlZGVlbVNjcmlwdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFB1YlNjcmlwdCxcbiAgICAgIC4uLnNpZ25hdHVyZXMsXG4gICAgfTtcbiAgfVxuICBpZiAocGFyc2VkUHViU2NyaXB0LnNjcmlwdFR5cGUgPT09ICdwMnNoUDJwaycgJiYgKCFzaWduYXR1cmVzLnNpZ25hdHVyZXMgfHwgIWlzVHVwbGUoc2lnbmF0dXJlcy5zaWduYXR1cmVzKSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkUHViU2NyaXB0LFxuICAgICAgc2lnbmF0dXJlczogc2lnbmF0dXJlcy5zaWduYXR1cmVzLFxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHB1YiBzY3JpcHQnKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyBzdHJpY3RseSBwYXJzZSB0aGUgaW5wdXQgYW5kIGdldCBzaWduYXR1cmUgY291bnQuXG4gKiB1bnNpZ25lZCgwKSwgaGFsZi1zaWduZWQoMSkgb3IgZnVsbHktc2lnbmVkKDIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJpY3RTaWduYXR1cmVDb3VudChpbnB1dDogVHhJbnB1dCB8IFBzYnRJbnB1dCk6IDAgfCAxIHwgMiB7XG4gIGNvbnN0IGNhbGN1bGF0ZVNpZ25hdHVyZUNvdW50ID0gKFxuICAgIHNpZ25hdHVyZXM6IFtCdWZmZXIgfCAwLCBCdWZmZXIgfCAwLCBCdWZmZXIgfCAwXSB8IFtCdWZmZXIsIEJ1ZmZlcl0gfCBbQnVmZmVyXSB8IHVuZGVmaW5lZFxuICApOiAwIHwgMSB8IDIgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gc2lnbmF0dXJlcyA/IHNpZ25hdHVyZXMuZmlsdGVyKChzKSA9PiAhaXNQbGFjZWhvbGRlclNpZ25hdHVyZShzKSkubGVuZ3RoIDogMDtcbiAgICBpZiAoY291bnQgPT09IDAgfHwgY291bnQgPT09IDEgfHwgY291bnQgPT09IDIpIHtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZSBjb3VudCcpO1xuICB9O1xuXG4gIGlmICgnaGFzaCcgaW4gaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuc2NyaXB0Py5sZW5ndGggfHwgaW5wdXQud2l0bmVzcz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJzZWRJbnB1dCA9IHBhcnNlU2lnbmF0dXJlU2NyaXB0KGlucHV0KTtcbiAgICAgIHJldHVybiBwYXJzZWRJbnB1dC5zY3JpcHRUeXBlID09PSAndGFwcm9vdEtleVBhdGhTcGVuZCcgPyAyIDogY2FsY3VsYXRlU2lnbmF0dXJlQ291bnQocGFyc2VkSW5wdXQuc2lnbmF0dXJlcyk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYWxjdWxhdGVTaWduYXR1cmVDb3VudChwYXJzZVBzYnRJbnB1dChpbnB1dCkuc2lnbmF0dXJlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyBzdHJpY3RseSBwYXJzZSBpbnB1dCBhbmQgZ2V0IHNpZ25hdHVyZSBjb3VudCBmb3IgYWxsIGlucHV0cy5cbiAqIDA9dW5zaWduZWQsIDE9aGFsZi1zaWduZWQgb3IgMj1mdWxseS1zaWduZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmljdFNpZ25hdHVyZUNvdW50cyhcbiAgdHg6IFV0eG9Qc2J0IHwgVXR4b1RyYW5zYWN0aW9uPG51bWJlciB8IGJpZ2ludD4gfCBQc2J0SW5wdXRbXSB8IFR4SW5wdXRbXVxuKTogKDAgfCAxIHwgMilbXSB7XG4gIGNvbnN0IGlucHV0cyA9IHR4IGluc3RhbmNlb2YgVXR4b1BzYnQgPyB0eC5kYXRhLmlucHV0cyA6IHR4IGluc3RhbmNlb2YgVXR4b1RyYW5zYWN0aW9uID8gdHguaW5zIDogdHg7XG4gIHJldHVybiBpbnB1dHMubWFwKChpbnB1dCwgXykgPT4gZ2V0U3RyaWN0U2lnbmF0dXJlQ291bnQoaW5wdXQpKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHRydWUgaWZmIGlucHV0cyBhcnJheSBpcyBvZiBQc2J0SW5wdXRUeXBlIHR5cGVcbiAqICovXG5leHBvcnQgZnVuY3Rpb24gaXNQc2J0SW5wdXRBcnJheShpbnB1dHM6IFBzYnRJbnB1dFtdIHwgVHhJbnB1dFtdKTogaW5wdXRzIGlzIFBzYnRJbnB1dFtdIHtcbiAgcmV0dXJuICFpc1R4SW5wdXRBcnJheShpbnB1dHMpO1xufVxuXG4vKipcbiAqIEByZXR1cm4gdHJ1ZSBpZmYgaW5wdXRzIGFycmF5IGlzIG9mIFR4SW5wdXQgdHlwZVxuICogKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1R4SW5wdXRBcnJheShpbnB1dHM6IFBzYnRJbnB1dFtdIHwgVHhJbnB1dFtdKTogaW5wdXRzIGlzIFR4SW5wdXRbXSB7XG4gIGFzc2VydCghIWlucHV0cy5sZW5ndGgsICdlbXB0eSBpbnB1dHMgYXJyYXknKTtcbiAgcmV0dXJuICdoYXNoJyBpbiBpbnB1dHNbMF07XG59XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZmYgZ2l2ZW4gcHNidC90cmFuc2FjdGlvbi90eC1pbnB1dC1hcnJheS9wc2J0LWlucHV0LWFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSB0YXByb290IGtleSBwYXRoIHNwZW5kIGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RyYW5zYWN0aW9uV2l0aEtleVBhdGhTcGVuZElucHV0KFxuICBkYXRhOiBVdHhvUHNidCB8IFV0eG9UcmFuc2FjdGlvbjxiaWdpbnQgfCBudW1iZXI+IHwgUHNidElucHV0W10gfCBUeElucHV0W11cbik6IGJvb2xlYW4ge1xuICBjb25zdCBpbnB1dHMgPSBkYXRhIGluc3RhbmNlb2YgVXR4b1BzYnQgPyBkYXRhLmRhdGEuaW5wdXRzIDogZGF0YSBpbnN0YW5jZW9mIFV0eG9UcmFuc2FjdGlvbiA/IGRhdGEuaW5zIDogZGF0YTtcbiAgaWYgKCFpbnB1dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1BzYnRJbnB1dEFycmF5KGlucHV0cykpIHtcbiAgICByZXR1cm4gaW5wdXRzLnNvbWUoKGlucHV0LCBfKSA9PiBnZXRQc2J0SW5wdXRTY3JpcHRUeXBlKGlucHV0KSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnKTtcbiAgfVxuICByZXR1cm4gaW5wdXRzLnNvbWUoKGlucHV0LCBfKSA9PiB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIG5vdCBzaWduZWQsIGl0IGNhbm5vdCBiZSBhIHRhcHJvb3RLZXlQYXRoU3BlbmQgaW5wdXQgYmVjYXVzZSB5b3UgY2FuIG9ubHlcbiAgICAvLyBleHRyYWN0IGEgZnVsbHkgc2lnbmVkIHBzYnQgaW50byBhIHRyYW5zYWN0aW9uIHdpdGggdGFwcm9vdEtleVBhdGhTcGVuZCBpbnB1dHMuXG4gICAgaWYgKGdldFN0cmljdFNpZ25hdHVyZUNvdW50KGlucHV0KSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VTaWduYXR1cmVTY3JpcHQoaW5wdXQpLnNjcmlwdFR5cGUgPT09ICd0YXByb290S2V5UGF0aFNwZW5kJztcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBSb290V2FsbGV0S2V5cyBhcyB0aGUgZ2xvYmFsWHB1YnMgb24gdGhlIHBzYnRcbiAqXG4gKiBXZSBkbyBhbGwgdGhlIG1hdGNoaW5nIG9mIHRoZSAodGFwKWJpcDMyRGVyaXZhdGlvbnMgbWFzdGVyRmluZ2VycHJpbnQgdG8gdGhlIGZpbmdlcnByaW50IG9mIHRoZVxuICogZXh0ZW5kZWRQdWJrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRYcHVic1RvUHNidChwc2J0OiBVdHhvUHNidCwgcm9vdFdhbGxldEtleXM6IFJvb3RXYWxsZXRLZXlzKTogdm9pZCB7XG4gIGNvbnN0IHNhZmVSb290V2FsbGV0S2V5cyA9IG5ldyBSb290V2FsbGV0S2V5cyhcbiAgICByb290V2FsbGV0S2V5cy50cmlwbGUubWFwKChiaXAzMikgPT4gYmlwMzIubmV1dGVyZWQoKSkgYXMgVHJpcGxlPEJJUDMySW50ZXJmYWNlPixcbiAgICByb290V2FsbGV0S2V5cy5kZXJpdmF0aW9uUHJlZml4ZXNcbiAgKTtcbiAgY29uc3QgeFB1YnMgPSBzYWZlUm9vdFdhbGxldEtleXMudHJpcGxlLm1hcChcbiAgICAoYmlwMzIpOiBHbG9iYWxYcHViID0+ICh7XG4gICAgICBleHRlbmRlZFB1YmtleTogYnM1OGNoZWNrLmRlY29kZShiaXAzMi50b0Jhc2U1OCgpKSxcbiAgICAgIG1hc3RlckZpbmdlcnByaW50OiBiaXAzMi5maW5nZXJwcmludCxcbiAgICAgIC8vIFRPRE86IEJHLTczNzk3IC0gYmlwMTc0IGN1cnJlbnRseSByZXF1aXJlcyBtIHByZWZpeCBmb3IgdGhpcyB0byBiZSBhIHZhbGlkIGdsb2JhbFhwdWJcbiAgICAgIHBhdGg6ICdtJyxcbiAgICB9KVxuICApO1xuICBwc2J0LnVwZGF0ZUdsb2JhbCh7IGdsb2JhbFhwdWI6IHhQdWJzIH0pO1xufVxuXG4vKipcbiAqIHZhbGlkYXRlcyBzaWduYXR1cmVzIGZvciBlYWNoIDIgb2YgMyBpbnB1dCBhZ2FpbnN0IHVzZXIsIGJhY2t1cCwgYml0Z28ga2V5cyBkZXJpdmVkIGZyb20gcm9vdFdhbGxldEtleXMuXG4gKiBAcmV0dXJucyBhcnJheSBvZiBpbnB1dCBpbmRleCBhbmQgaXRzIFtpcyB2YWxpZCB1c2VyIHNpZyBleGlzdCwgaXMgdmFsaWQgYmFja3VwIHNpZyBleGlzdCwgaXMgdmFsaWQgdXNlciBiaXRnbyBleGlzdF1cbiAqIEZvciBwMnNoUDJwayBpbnB1dCwgW2ZhbHNlLCBmYWxzZSwgZmFsc2VdIGlzIHJldHVybmVkIHNpbmNlIGl0IGlzIG5vdCBhIDIgb2YgMyBzaWcgaW5wdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduYXR1cmVWYWxpZGF0aW9uQXJyYXlQc2J0KHBzYnQ6IFV0eG9Qc2J0LCByb290V2FsbGV0S2V5czogUm9vdFdhbGxldEtleXMpOiBTaWduYXR1cmVWYWxpZGF0aW9uW10ge1xuICByZXR1cm4gcHNidC5kYXRhLmlucHV0cy5tYXAoKGlucHV0LCBpKSA9PiB7XG4gICAgY29uc3Qgc2lnVmFsQXJyYXlGb3JJbnB1dDogVHJpcGxlPGJvb2xlYW4+ID1cbiAgICAgIGdldFBzYnRJbnB1dFNjcmlwdFR5cGUoaW5wdXQpID09PSAncDJzaFAycGsnXG4gICAgICAgID8gW2ZhbHNlLCBmYWxzZSwgZmFsc2VdXG4gICAgICAgIDogcHNidC5nZXRTaWduYXR1cmVWYWxpZGF0aW9uQXJyYXkoaSwgeyByb290Tm9kZXM6IHJvb3RXYWxsZXRLZXlzLnRyaXBsZSB9KTtcbiAgICByZXR1cm4gW2ksIHNpZ1ZhbEFycmF5Rm9ySW5wdXRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgaGFsZiBzaWduZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgcHNidCBmb3IgcDJtcyBiYXNlZCBzY3JpcHQgdHlwZXMgLSBwMnNoLCBwMndzaCwgYW5kIHAyc2hQMndzaC5cbiAqIFRoZSBwdXJwb3NlIGlzIHRvIHByb3ZpZGUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0byBrZXl0ZXJuYWwgKEtSUykgdGhhdCBvbmx5IHN1cHBvcnRzIG5ldHdvcmsgdHJhbnNhY3Rpb24gYW5kIHAybXMgc2NyaXB0IHR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFAybXNPbmx5SGFsZlNpZ25lZFR4KHBzYnQ6IFV0eG9Qc2J0KTogVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4ge1xuICBhc3NlcnQoISEocHNidC5kYXRhLmlucHV0cy5sZW5ndGggJiYgcHNidC5kYXRhLm91dHB1dHMubGVuZ3RoKSwgJ2VtcHR5IGlucHV0cyBvciBvdXRwdXRzJyk7XG4gIGNvbnN0IHR4ID0gcHNidC5nZXRVbnNpZ25lZFR4KCk7XG5cbiAgZnVuY3Rpb24gaXNQMm1zUGFyc2VkUHNidElucHV0KFxuICAgIHBhcnNlZDogUGFyc2VkUHNidFAybXMgfCBQYXJzZWRQc2J0VGFwcm9vdCB8IFBhcnNlZFBzYnRQMnNoUDJwa1xuICApOiBwYXJzZWQgaXMgUGFyc2VkUHNidFAybXMge1xuICAgIHJldHVybiBbJ3Ayc2gnLCAncDJzaFAyd3NoJywgJ3Ayd3NoJ10uaW5jbHVkZXMocGFyc2VkLnNjcmlwdFR5cGUpO1xuICB9XG5cbiAgcHNidC5kYXRhLmlucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlUHNidElucHV0KGlucHV0KTtcbiAgICBhc3NlcnQoaXNQMm1zUGFyc2VkUHNidElucHV0KHBhcnNlZCksIGB1bnN1cHBvcnRlZCBzY3JpcHQgdHlwZSAke3BhcnNlZC5zY3JpcHRUeXBlfWApO1xuICAgIGFzc2VydChpbnB1dC5wYXJ0aWFsU2lnPy5sZW5ndGggPT09IDEsIGB1bmV4cGVjdGVkIHNpZ25hdHVyZSBjb3VudCAke2lucHV0LnBhcnRpYWxTaWc/Lmxlbmd0aH1gKTtcbiAgICBjb25zdCBbcGFydGlhbFNpZ10gPSBpbnB1dC5wYXJ0aWFsU2lnO1xuICAgIGFzc2VydChcbiAgICAgIGlucHV0LnNpZ2hhc2hUeXBlICE9PSB1bmRlZmluZWQgJiYgaW5wdXQuc2lnaGFzaFR5cGUgPT09IGJzY3JpcHQuc2lnbmF0dXJlLmRlY29kZShwYXJ0aWFsU2lnLnNpZ25hdHVyZSkuaGFzaFR5cGUsXG4gICAgICAnc2lnbmF0dXJlIHNpZ2hhc2ggZG9lcyBub3QgbWF0Y2ggaW5wdXQgc2lnaGFzaCB0eXBlJ1xuICAgICk7XG5cbiAgICAvLyB0eXBlIGNhc3RpbmcgaXMgdG8gYWRkcmVzcyB0aGUgaW52YWxpZCB0eXBlIGNoZWNraW5nIGluIHBheW1lbnRzLnAybXNcbiAgICBjb25zdCBzaWduYXR1cmVzID0gcGFyc2VkLnB1YmxpY0tleXMubWFwKChwaykgPT5cbiAgICAgIHBhcnRpYWxTaWcucHVia2V5LmVxdWFscyhwaykgPyBwYXJ0aWFsU2lnLnNpZ25hdHVyZSA6IChvcHMuT1BfMCBhcyB1bmtub3duIGFzIEJ1ZmZlcilcbiAgICApO1xuXG4gICAgY29uc3QgaXNQMlNIID0gISFwYXJzZWQucmVkZWVtU2NyaXB0O1xuICAgIGNvbnN0IGlzUDJXU0ggPSAhIXBhcnNlZC53aXRuZXNzU2NyaXB0O1xuXG4gICAgY29uc3QgcGF5bWVudCA9IHBheW1lbnRzLnAybXMoeyBvdXRwdXQ6IHBhcnNlZC5wdWJTY3JpcHQsIHNpZ25hdHVyZXMgfSwgeyB2YWxpZGF0ZTogZmFsc2UsIGFsbG93SW5jb21wbGV0ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBwMndzaCA9IGlzUDJXU0ggPyBwYXltZW50cy5wMndzaCh7IHJlZGVlbTogcGF5bWVudCB9KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwMnNoID0gaXNQMlNIID8gcGF5bWVudHMucDJzaCh7IHJlZGVlbTogcDJ3c2ggfHwgcGF5bWVudCB9KSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChwMnNoPy5pbnB1dCkge1xuICAgICAgdHguc2V0SW5wdXRTY3JpcHQoaSwgcDJzaC5pbnB1dCk7XG4gICAgfVxuICAgIGlmIChwMndzaD8ud2l0bmVzcykge1xuICAgICAgdHguc2V0V2l0bmVzcyhpLCBwMndzaC53aXRuZXNzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn1cblxuLyoqXG4gKiBDbG9uZXMgdGhlIHBzYnQgd2l0aG91dCBub25XaXRuZXNzVXR4byBmb3Igbm9uLXNlZ3dpdCBpbnB1dHMgYW5kIHdpdG5lc3NVdHhvIGlzIGFkZGVkIGluc3RlYWQuXG4gKiBJdCBpcyBub3QgQklQLTE3NCBjb21wbGlhbnQsIHNvIHVzZSBpdCBjYXJlZnVsbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVBzYnRXaXRob3V0Tm9uV2l0bmVzc1V0eG8ocHNidDogVXR4b1BzYnQpOiBVdHhvUHNidCB7XG4gIGNvbnN0IG5ld1BzYnQgPSBwc2J0LmNsb25lKCk7XG4gIGNvbnN0IHR4SW5wdXRzID0gcHNidC50eElucHV0cztcblxuICBwc2J0LmRhdGEuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvICYmICFpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgY29uc3QgdHggPSBVdHhvVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcjxiaWdpbnQ+KGlucHV0Lm5vbldpdG5lc3NVdHhvLCBmYWxzZSwgJ2JpZ2ludCcsIHBzYnQubmV0d29yayk7XG4gICAgICBpZiAoIXR4SW5wdXRzW2ldLmhhc2guZXF1YWxzKHR4LmdldEhhc2goKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24td2l0bmVzcyBVVFhPIGhhc2ggZm9yIGlucHV0ICMke2l9IGRvZXNuJ3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0YCk7XG4gICAgICB9XG4gICAgICBuZXdQc2J0LmRhdGEuaW5wdXRzW2ldLndpdG5lc3NVdHhvID0gdHgub3V0c1t0eElucHV0c1tpXS5pbmRleF07XG4gICAgfVxuICAgIGRlbGV0ZSBuZXdQc2J0LmRhdGEuaW5wdXRzW2ldLm5vbldpdG5lc3NVdHhvO1xuICB9KTtcblxuICByZXR1cm4gbmV3UHNidDtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHdpdG5lc3NVdHhvIGZvciBub24tc2Vnd2l0IGlucHV0cyB0byBtYWtlIHRoZSBQU0JUIEJJUC0xNzQgY29tcGxpYW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlV2l0bmVzc1V0eG9Gb3JOb25TZWd3aXRJbnB1dHMocHNidDogVXR4b1BzYnQpOiB2b2lkIHtcbiAgcHNidC5kYXRhLmlucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdFR5cGUgPSBnZXRQc2J0SW5wdXRTY3JpcHRUeXBlKGlucHV0KTtcbiAgICBpZiAoc2NyaXB0VHlwZSA9PT0gJ3Ayc2gnIHx8IHNjcmlwdFR5cGUgPT09ICdwMnNoUDJwaycpIHtcbiAgICAgIGRlbGV0ZSBpbnB1dC53aXRuZXNzVXR4bztcbiAgICB9XG4gIH0pO1xufVxuIl19