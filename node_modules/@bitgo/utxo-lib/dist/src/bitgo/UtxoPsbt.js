"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtxoPsbt = void 0;
const assert = require("assert");
const bip174_1 = require("bip174");
const utils_1 = require("bip174/src/lib/utils");
const bufferutils_1 = require("bitcoinjs-lib/src/bufferutils");
const bip32_1 = require("bip32");
const bs58check = require("bs58check");
const proprietaryKeyVal_1 = require("bip174/src/lib/proprietaryKeyVal");
const __1 = require("..");
const UtxoTransaction_1 = require("./UtxoTransaction");
const Unspent_1 = require("./Unspent");
const scriptTypes_1 = require("./psbt/scriptTypes");
const fromHalfSigned_1 = require("./psbt/fromHalfSigned");
const outputScripts_1 = require("./outputScripts");
const parseInput_1 = require("./parseInput");
const Musig2_1 = require("./Musig2");
const types_1 = require("./types");
const taproot_1 = require("../taproot");
const PsbtUtil_1 = require("./PsbtUtil");
function defaultSighashTypes(network) {
    const sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL];
    switch (__1.getMainnet(network)) {
        case __1.networks.bitcoincash:
        case __1.networks.bitcoinsv:
        case __1.networks.bitcoingold:
        case __1.networks.ecash:
            return [...sighashTypes, ...sighashTypes.map((s) => s | UtxoTransaction_1.UtxoTransaction.SIGHASH_FORKID)];
        default:
            return sighashTypes;
    }
}
function toSignatureParams(network, v) {
    if (Array.isArray(v))
        return toSignatureParams(network, { sighashTypes: v });
    return { deterministic: false, sighashTypes: defaultSighashTypes(network), ...v };
}
/**
 * @param a
 * @param b
 * @returns true if the two public keys are equal ignoring the y coordinate.
 */
function equalPublicKeyIgnoreY(a, b) {
    return outputScripts_1.toXOnlyPublicKey(a).equals(outputScripts_1.toXOnlyPublicKey(b));
}
// TODO: upstream does `checkInputsForPartialSigs` before doing things like
// `setVersion`. Our inputs could have tapscriptsigs (or in future tapkeysigs)
// and not fail that check. Do we want to do anything about that?
class UtxoPsbt extends __1.Psbt {
    constructor() {
        super(...arguments);
        this.nonceStore = new Musig2_1.Musig2NonceStore();
    }
    static transactionFromBuffer(buffer, network) {
        return UtxoTransaction_1.UtxoTransaction.fromBuffer(buffer, false, 'bigint', network);
    }
    static createPsbt(opts, data) {
        return new UtxoPsbt(opts, data || new bip174_1.Psbt(new __1.PsbtTransaction({ tx: new UtxoTransaction_1.UtxoTransaction(opts.network) })));
    }
    static fromBuffer(buffer, opts) {
        const transactionFromBuffer = (buffer) => {
            const tx = this.transactionFromBuffer(buffer, opts.network);
            return new __1.PsbtTransaction({ tx });
        };
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer, {
            bip32PathsAbsolute: opts.bip32PathsAbsolute,
        });
        const psbt = this.createPsbt(opts, psbtBase);
        // Upstream checks for duplicate inputs here, but it seems to be of dubious value.
        return psbt;
    }
    static fromHex(data, opts) {
        return this.fromBuffer(Buffer.from(data, 'hex'), opts);
    }
    /**
     * @param parent - Parent key. Matched with `bip32Derivations` using `fingerprint` property.
     * @param bip32Derivations - possible derivations for input or output
     * @param ignoreY - when true, ignore the y coordinate when matching public keys
     * @return derived bip32 node if matching derivation is found, undefined if none is found
     * @throws Error if more than one match is found
     */
    static deriveKeyPair(parent, bip32Derivations, { ignoreY }) {
        const matchingDerivations = bip32Derivations.filter((bipDv) => {
            return bipDv.masterFingerprint.equals(parent.fingerprint);
        });
        if (!matchingDerivations.length) {
            // No fingerprint match
            return undefined;
        }
        if (matchingDerivations.length !== 1) {
            throw new Error(`more than one matching derivation for fingerprint ${parent.fingerprint.toString('hex')}: ${matchingDerivations.length}`);
        }
        const [derivation] = matchingDerivations;
        const node = parent.derivePath(derivation.path);
        if (!node.publicKey.equals(derivation.pubkey)) {
            if (!ignoreY || !equalPublicKeyIgnoreY(node.publicKey, derivation.pubkey)) {
                throw new Error('pubkey did not match bip32Derivation');
            }
        }
        return node;
    }
    static deriveKeyPairForInput(bip32, input) {
        var _a, _b, _c, _d;
        return ((_a = input.tapBip32Derivation) === null || _a === void 0 ? void 0 : _a.length)
            ? (_b = UtxoPsbt.deriveKeyPair(bip32, input.tapBip32Derivation, { ignoreY: true })) === null || _b === void 0 ? void 0 : _b.publicKey
            : ((_c = input.bip32Derivation) === null || _c === void 0 ? void 0 : _c.length)
                ? (_d = UtxoPsbt.deriveKeyPair(bip32, input.bip32Derivation, { ignoreY: false })) === null || _d === void 0 ? void 0 : _d.publicKey
                : bip32 === null || bip32 === void 0 ? void 0 : bip32.publicKey;
    }
    get network() {
        return this.tx.network;
    }
    toHex() {
        return this.toBuffer().toString('hex');
    }
    /**
     * It is expensive to attempt to compute every output address using psbt.txOutputs[outputIndex]
     * to then just get the script. Here, we are doing the same thing as what txOutputs() does in
     * bitcoinjs-lib, but without iterating over each output.
     * @param outputIndex
     * @returns output script at the given index
     */
    getOutputScript(outputIndex) {
        return this.__CACHE.__TX.outs[outputIndex].script;
    }
    getNonWitnessPreviousTxids() {
        const txInputs = this.txInputs; // These are somewhat costly to extract
        const txidSet = new Set();
        this.data.inputs.forEach((input, index) => {
            if (!input.witnessUtxo) {
                throw new Error('Must have witness UTXO for all inputs');
            }
            if (!scriptTypes_1.isSegwit(input.witnessUtxo.script, input.redeemScript)) {
                txidSet.add(Unspent_1.getOutputIdForInput(txInputs[index]).txid);
            }
        });
        return [...txidSet];
    }
    addNonWitnessUtxos(txBufs) {
        const txInputs = this.txInputs; // These are somewhat costly to extract
        this.data.inputs.forEach((input, index) => {
            if (!input.witnessUtxo) {
                throw new Error('Must have witness UTXO for all inputs');
            }
            if (!scriptTypes_1.isSegwit(input.witnessUtxo.script, input.redeemScript)) {
                const { txid } = Unspent_1.getOutputIdForInput(txInputs[index]);
                if (txBufs[txid] === undefined) {
                    throw new Error('Not all required previous transactions provided');
                }
                this.updateInput(index, { nonWitnessUtxo: txBufs[txid] });
            }
        });
        return this;
    }
    static fromTransaction(transaction, prevOutputs) {
        if (prevOutputs.length !== transaction.ins.length) {
            throw new Error(`Transaction has ${transaction.ins.length} inputs, but ${prevOutputs.length} previous outputs provided`);
        }
        const clonedTransaction = transaction.clone();
        const updates = fromHalfSigned_1.unsign(clonedTransaction, prevOutputs);
        const psbtBase = new bip174_1.Psbt(new __1.PsbtTransaction({ tx: clonedTransaction }));
        clonedTransaction.ins.forEach(() => psbtBase.inputs.push({ unknownKeyVals: [] }));
        clonedTransaction.outs.forEach(() => psbtBase.outputs.push({ unknownKeyVals: [] }));
        const psbt = this.createPsbt({ network: transaction.network }, psbtBase);
        updates.forEach((update, index) => {
            psbt.updateInput(index, update);
            psbt.updateInput(index, { witnessUtxo: { script: prevOutputs[index].script, value: prevOutputs[index].value } });
        });
        return psbt;
    }
    getUnsignedTx() {
        return this.tx.clone();
    }
    static newTransaction(network) {
        return new UtxoTransaction_1.UtxoTransaction(network);
    }
    get tx() {
        return this.data.globalMap.unsignedTx.tx;
    }
    checkForSignatures(propName) {
        this.data.inputs.forEach((input) => {
            var _a, _b;
            if (((_a = input.tapScriptSig) === null || _a === void 0 ? void 0 : _a.length) || input.tapKeySig || ((_b = input.partialSig) === null || _b === void 0 ? void 0 : _b.length)) {
                throw new Error(`Cannot modify ${propName !== null && propName !== void 0 ? propName : 'transaction'} - signatures exist.`);
            }
        });
    }
    /**
     * @returns true if the input at inputIndex is a taproot key path.
     * Checks for presence of minimum required key path input fields and absence of any script path only input fields.
     */
    isTaprootKeyPathInput(inputIndex) {
        var _a, _b, _c;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        return (!!input.tapInternalKey &&
            !!input.tapMerkleRoot &&
            !(((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) ||
                ((_b = input.tapScriptSig) === null || _b === void 0 ? void 0 : _b.length) ||
                ((_c = input.tapBip32Derivation) === null || _c === void 0 ? void 0 : _c.some((v) => v.leafHashes.length))));
    }
    /**
     * @returns true if the input at inputIndex is a taproot script path.
     * Checks for presence of minimum required script path input fields and absence of any key path only input fields.
     */
    isTaprootScriptPathInput(inputIndex) {
        var _a;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        return (!!((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) &&
            !(this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTICIPANT_PUB_KEYS,
            }).length ||
                this.getProprietaryKeyVals(inputIndex, {
                    identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                    subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PUB_NONCE,
                }).length ||
                this.getProprietaryKeyVals(inputIndex, {
                    identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                    subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,
                }).length));
    }
    /**
     * @returns true if the input at inputIndex is a taproot
     */
    isTaprootInput(inputIndex) {
        var _a, _b, _c;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const isP2TR = (script) => {
            try {
                taproot_1.getTaprootOutputKey(script);
                return true;
            }
            catch (e) {
                return false;
            }
        };
        return !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) ||
            ((_b = input.tapBip32Derivation) === null || _b === void 0 ? void 0 : _b.length) ||
            ((_c = input.tapScriptSig) === null || _c === void 0 ? void 0 : _c.length) ||
            this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTICIPANT_PUB_KEYS,
            }).length ||
            this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PUB_NONCE,
            }).length ||
            this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,
            }).length ||
            (input.witnessUtxo && isP2TR(input.witnessUtxo.script)));
    }
    isMultisigTaprootScript(script) {
        try {
            parseInput_1.parsePubScript2Of3(script, 'taprootScriptPathSpend');
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts
     */
    finalizeAllInputs() {
        utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
        this.data.inputs.map((input, idx) => {
            var _a;
            if ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) {
                return this.isMultisigTaprootScript(input.tapLeafScript[0].script)
                    ? this.finalizeTaprootInput(idx)
                    : this.finalizeTapInputWithSingleLeafScriptAndSignature(idx);
            }
            else if (this.isTaprootKeyPathInput(idx)) {
                return this.finalizeTaprootMusig2Input(idx);
            }
            return this.finalizeInput(idx);
        });
        return this;
    }
    finalizeTaprootInput(inputIndex) {
        var _a, _b;
        const checkPartialSigSighashes = (sig) => {
            const sighashType = sig.length === 64 ? __1.Transaction.SIGHASH_DEFAULT : sig.readUInt8(sig.length - 1);
            const inputSighashType = input.sighashType === undefined ? __1.Transaction.SIGHASH_DEFAULT : input.sighashType;
            assert(sighashType === inputSighashType, 'signature sighash does not match input sighash type');
        };
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        // witness = control-block script first-sig second-sig
        if (((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) !== 1) {
            throw new Error('Only one leaf script supported for finalizing');
        }
        const { controlBlock, script } = input.tapLeafScript[0];
        const witness = [script, controlBlock];
        const [pubkey1, pubkey2] = parseInput_1.parsePubScript2Of3(script, 'taprootScriptPathSpend').publicKeys;
        for (const pk of [pubkey1, pubkey2]) {
            const sig = (_b = input.tapScriptSig) === null || _b === void 0 ? void 0 : _b.find(({ pubkey }) => equalPublicKeyIgnoreY(pk, pubkey));
            if (!sig) {
                throw new Error('Could not find signatures in Script Sig.');
            }
            checkPartialSigSighashes(sig.signature);
            witness.unshift(sig.signature);
        }
        const witnessLength = witness.reduce((s, b) => s + b.length + bufferutils_1.varuint.encodingLength(b.length), 1);
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(witnessLength);
        bufferWriter.writeVector(witness);
        const finalScriptWitness = bufferWriter.end();
        this.data.updateInput(inputIndex, { finalScriptWitness });
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    /**
     * Finalizes a taproot musig2 input by aggregating all partial sigs.
     * IMPORTANT: Always call validate* function before finalizing.
     */
    finalizeTaprootMusig2Input(inputIndex) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const partialSigs = Musig2_1.parsePsbtMusig2PartialSigs(input);
        if ((partialSigs === null || partialSigs === void 0 ? void 0 : partialSigs.length) !== 2) {
            throw new Error(`invalid number of partial signatures ${partialSigs ? partialSigs.length : 0} to finalize`);
        }
        const { partialSigs: pSigs, sigHashType } = Musig2_1.getSigHashTypeFromSigs(partialSigs);
        const { sessionKey } = this.getMusig2SessionKey(inputIndex, sigHashType);
        const aggSig = Musig2_1.musig2AggregateSigs(pSigs.map((pSig) => pSig.partialSig), sessionKey);
        const sig = sigHashType === __1.Transaction.SIGHASH_DEFAULT ? aggSig : Buffer.concat([aggSig, Buffer.of(sigHashType)]);
        // single signature with 64/65 bytes size is script witness for key path spend
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(1 + bufferutils_1.varuint.encodingLength(sig.length) + sig.length);
        bufferWriter.writeVector([sig]);
        const finalScriptWitness = bufferWriter.end();
        this.data.updateInput(inputIndex, { finalScriptWitness });
        this.data.clearFinalizedInput(inputIndex);
        // deleting only BitGo proprietary key values.
        this.deleteProprietaryKeyVals(inputIndex, { identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER });
        return this;
    }
    finalizeTapInputWithSingleLeafScriptAndSignature(inputIndex) {
        var _a, _b;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        if (((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) !== 1) {
            throw new Error('Only one leaf script supported for finalizing');
        }
        if (((_b = input.tapScriptSig) === null || _b === void 0 ? void 0 : _b.length) !== 1) {
            throw new Error('Could not find signatures in Script Sig.');
        }
        const { controlBlock, script } = input.tapLeafScript[0];
        const witness = [input.tapScriptSig[0].signature, script, controlBlock];
        const witnessLength = witness.reduce((s, b) => s + b.length + bufferutils_1.varuint.encodingLength(b.length), 1);
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(witnessLength);
        bufferWriter.writeVector(witness);
        const finalScriptWitness = bufferWriter.end();
        this.data.updateInput(inputIndex, { finalScriptWitness });
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts
     *
     * Unlike the function it overrides, this does not take a validator. In BitGo
     * context, we know how we want to validate so we just hard code the right
     * validator.
     */
    validateSignaturesOfAllInputs() {
        utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
        const results = this.data.inputs.map((input, idx) => {
            return this.validateSignaturesOfInputCommon(idx);
        });
        return results.reduce((final, res) => res && final, true);
    }
    /**
     * @returns true iff any matching valid signature is found for a derived pub key from given HD key pair.
     */
    validateSignaturesOfInputHD(inputIndex, hdKeyPair) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const pubKey = UtxoPsbt.deriveKeyPairForInput(hdKeyPair, input);
        if (!pubKey) {
            throw new Error('can not derive from HD key pair');
        }
        return this.validateSignaturesOfInputCommon(inputIndex, pubKey);
    }
    /**
     * @returns true iff any valid signature(s) are found from bip32 data of PSBT or for given pub key.
     */
    validateSignaturesOfInputCommon(inputIndex, pubkey) {
        try {
            if (this.isTaprootScriptPathInput(inputIndex)) {
                return this.validateTaprootSignaturesOfInput(inputIndex, pubkey);
            }
            else if (this.isTaprootKeyPathInput(inputIndex)) {
                return this.validateTaprootMusig2SignaturesOfInput(inputIndex, pubkey);
            }
            return this.validateSignaturesOfInput(inputIndex, (p, m, s) => __1.ecc.verify(m, p, s, true), pubkey);
        }
        catch (err) {
            // Not an elegant solution. Might need upstream changes like custom error types.
            if (err.message === 'No signatures for this pubkey') {
                return false;
            }
            throw err;
        }
    }
    getMusig2SessionKey(inputIndex, sigHashType) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        if (!input.tapInternalKey || !input.tapMerkleRoot) {
            throw new Error('both tapInternalKey and tapMerkleRoot are required');
        }
        const participants = this.getMusig2Participants(inputIndex, input.tapInternalKey, input.tapMerkleRoot);
        const nonces = this.getMusig2Nonces(inputIndex, participants);
        const { hash } = this.getTaprootHashForSig(inputIndex, [sigHashType]);
        const sessionKey = Musig2_1.createMusig2SigningSession({
            pubNonces: [nonces[0].pubNonce, nonces[1].pubNonce],
            pubKeys: participants.participantPubKeys,
            txHash: hash,
            internalPubKey: input.tapInternalKey,
            tapTreeRoot: input.tapMerkleRoot,
        });
        return { participants, nonces, hash, sessionKey };
    }
    /**
     * @returns true for following cases.
     * If valid musig2 partial signatures exists for both 2 keys, it will also verify aggregated sig
     * for aggregated tweaked key (output key), otherwise only verifies partial sig.
     * If pubkey is passed in input, it will check sig only for that pubkey,
     * if no sig exits for such key, throws error.
     * For invalid state of input data, it will throw errors.
     */
    validateTaprootMusig2SignaturesOfInput(inputIndex, pubkey) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const partialSigs = Musig2_1.parsePsbtMusig2PartialSigs(input);
        if (!partialSigs) {
            throw new Error(`No signatures to validate`);
        }
        let myPartialSigs = partialSigs;
        if (pubkey) {
            myPartialSigs = partialSigs.filter((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, pubkey));
            if ((myPartialSigs === null || myPartialSigs === void 0 ? void 0 : myPartialSigs.length) < 1) {
                throw new Error('No signatures for this pubkey');
            }
        }
        const { partialSigs: mySigs, sigHashType } = Musig2_1.getSigHashTypeFromSigs(myPartialSigs);
        const { participants, nonces, hash, sessionKey } = this.getMusig2SessionKey(inputIndex, sigHashType);
        const results = mySigs.map((mySig) => {
            const myNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, mySig.participantPubKey));
            if (!myNonce) {
                throw new Error('Found no pub nonce for pubkey');
            }
            return Musig2_1.musig2PartialSigVerify(mySig.partialSig, mySig.participantPubKey, myNonce.pubNonce, sessionKey);
        });
        // For valid single sig or 1 or 2 failure sigs, no need to validate aggregated sig. So skip.
        const result = results.every((res) => res);
        if (!result || mySigs.length < 2) {
            return result;
        }
        const aggSig = Musig2_1.musig2AggregateSigs(mySigs.map((mySig) => mySig.partialSig), sessionKey);
        return __1.ecc.verifySchnorr(hash, participants.tapOutputKey, aggSig);
    }
    validateTaprootSignaturesOfInput(inputIndex, pubkey) {
        var _a, _b;
        const input = this.data.inputs[inputIndex];
        const tapSigs = (input || {}).tapScriptSig;
        if (!input || !tapSigs || tapSigs.length < 1) {
            throw new Error('No signatures to validate');
        }
        let mySigs;
        if (pubkey) {
            mySigs = tapSigs.filter((sig) => equalPublicKeyIgnoreY(sig.pubkey, pubkey));
            if (mySigs.length < 1) {
                throw new Error('No signatures for this pubkey');
            }
        }
        else {
            mySigs = tapSigs;
        }
        const results = [];
        assert(((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) === 1, `single tapLeafScript is expected. Got ${(_b = input.tapLeafScript) === null || _b === void 0 ? void 0 : _b.length}`);
        const [tapLeafScript] = input.tapLeafScript;
        const pubKeys = this.isMultisigTaprootScript(tapLeafScript.script)
            ? parseInput_1.parsePubScript2Of3(tapLeafScript.script, 'taprootScriptPathSpend').publicKeys
            : undefined;
        for (const pSig of mySigs) {
            const { signature, leafHash, pubkey } = pSig;
            if (pubKeys) {
                assert(pubKeys.find((pk) => pubkey.equals(pk)), 'public key not found in tap leaf script');
            }
            let sigHashType;
            let sig;
            if (signature.length === 65) {
                sigHashType = signature[64];
                sig = signature.slice(0, 64);
            }
            else {
                sigHashType = __1.Transaction.SIGHASH_DEFAULT;
                sig = signature;
            }
            const { hash } = this.getTaprootHashForSig(inputIndex, [sigHashType], leafHash);
            results.push(__1.ecc.verifySchnorr(hash, pubkey, sig));
        }
        return results.every((res) => res);
    }
    /**
     * @param inputIndex
     * @param rootNodes optional input root bip32 nodes to verify with. If it is not provided, globalXpub will be used.
     * @return array of boolean values. True when corresponding index in `publicKeys` has signed the transaction.
     * If no signature in the tx or no public key matching signature, the validation is considered as false.
     */
    getSignatureValidationArray(inputIndex, { rootNodes } = {}) {
        var _a, _b;
        if (!rootNodes && (!((_a = this.data.globalMap.globalXpub) === null || _a === void 0 ? void 0 : _a.length) || !types_1.isTriple(this.data.globalMap.globalXpub))) {
            throw new Error('Cannot get signature validation array without 3 global xpubs');
        }
        const bip32s = rootNodes
            ? rootNodes
            : (_b = this.data.globalMap.globalXpub) === null || _b === void 0 ? void 0 : _b.map((xpub) => bip32_1.BIP32Factory(__1.ecc).fromBase58(bs58check.encode(xpub.extendedPubkey)));
        if (!bip32s) {
            throw new Error('either globalMap or rootNodes is required');
        }
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        if (!PsbtUtil_1.getPsbtInputSignatureCount(input)) {
            return [false, false, false];
        }
        return bip32s.map((bip32) => {
            const pubKey = UtxoPsbt.deriveKeyPairForInput(bip32, input);
            if (!pubKey) {
                return false;
            }
            try {
                return this.validateSignaturesOfInputCommon(inputIndex, pubKey);
            }
            catch (err) {
                // Not an elegant solution. Might need upstream changes like custom error types.
                if (err.message === 'No signatures for this pubkey') {
                    return false;
                }
                throw err;
            }
        });
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts
     */
    signAllInputsHD(hdKeyPair, params) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const { sighashTypes, deterministic } = toSignatureParams(this.network, params);
        const results = [];
        for (let i = 0; i < this.data.inputs.length; i++) {
            try {
                this.signInputHD(i, hdKeyPair, { sighashTypes, deterministic });
                results.push(true);
            }
            catch (err) {
                results.push(false);
            }
        }
        if (results.every((v) => !v)) {
            throw new Error('No inputs were signed');
        }
        return this;
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts:signInputHD
     */
    signTaprootInputHD(inputIndex, hdKeyPair, { sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL], deterministic = false } = {}) {
        var _a, _b;
        if (!this.isTaprootInput(inputIndex)) {
            throw new Error('not a taproot input');
        }
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        if (!input.tapBip32Derivation || input.tapBip32Derivation.length === 0) {
            throw new Error('Need tapBip32Derivation to sign Taproot with HD');
        }
        const myDerivations = input.tapBip32Derivation
            .map((bipDv) => {
            if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
                return bipDv;
            }
        })
            .filter((v) => !!v);
        if (myDerivations.length === 0) {
            throw new Error('Need one tapBip32Derivation masterFingerprint to match the HDSigner fingerprint');
        }
        function getDerivedNode(bipDv) {
            const node = hdKeyPair.derivePath(bipDv.path);
            if (!equalPublicKeyIgnoreY(bipDv.pubkey, node.publicKey)) {
                throw new Error('pubkey did not match tapBip32Derivation');
            }
            return node;
        }
        if ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) {
            const signers = myDerivations.map((bipDv) => {
                const signer = getDerivedNode(bipDv);
                if (!('signSchnorr' in signer)) {
                    throw new Error('signSchnorr function is required to sign p2tr');
                }
                return { signer, leafHashes: bipDv.leafHashes };
            });
            signers.forEach(({ signer, leafHashes }) => this.signTaprootInput(inputIndex, signer, leafHashes, sighashTypes));
        }
        else if ((_b = input.tapInternalKey) === null || _b === void 0 ? void 0 : _b.length) {
            const signers = myDerivations.map((bipDv) => {
                const signer = getDerivedNode(bipDv);
                if (!('privateKey' in signer) || !signer.privateKey) {
                    throw new Error('privateKey is required to sign p2tr musig2');
                }
                return signer;
            });
            signers.forEach((signer) => this.signTaprootMusig2Input(inputIndex, signer, { sighashTypes, deterministic }));
        }
        return this;
    }
    signInputHD(inputIndex, hdKeyPair, params) {
        const { sighashTypes, deterministic } = toSignatureParams(this.network, params);
        if (this.isTaprootInput(inputIndex)) {
            return this.signTaprootInputHD(inputIndex, hdKeyPair, { sighashTypes, deterministic });
        }
        else {
            return super.signInputHD(inputIndex, hdKeyPair, sighashTypes);
        }
    }
    getMusig2Participants(inputIndex, tapInternalKey, tapMerkleRoot) {
        const participantsKeyValData = Musig2_1.parsePsbtMusig2Participants(this.data.inputs[inputIndex]);
        if (!participantsKeyValData) {
            throw new Error(`Found 0 matching participant key value instead of 1`);
        }
        Musig2_1.assertPsbtMusig2Participants(participantsKeyValData, tapInternalKey, tapMerkleRoot);
        return participantsKeyValData;
    }
    getMusig2Nonces(inputIndex, participantsKeyValData) {
        const noncesKeyValsData = Musig2_1.parsePsbtMusig2Nonces(this.data.inputs[inputIndex]);
        if (!noncesKeyValsData || !types_1.isTuple(noncesKeyValsData)) {
            throw new Error(`Found ${(noncesKeyValsData === null || noncesKeyValsData === void 0 ? void 0 : noncesKeyValsData.length) ? noncesKeyValsData.length : 0} matching nonce key value instead of 2`);
        }
        Musig2_1.assertPsbtMusig2Nonces(noncesKeyValsData, participantsKeyValData);
        return noncesKeyValsData;
    }
    /**
     * Signs p2tr musig2 key path input with 2 aggregated keys.
     *
     * Note: Only can sign deterministically as the cosigner
     * @param inputIndex
     * @param signer - XY public key and private key are required
     * @param sighashTypes
     * @param deterministic If true, sign the musig input deterministically
     */
    signTaprootMusig2Input(inputIndex, signer, { sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL], deterministic = false } = {}) {
        if (!this.isTaprootKeyPathInput(inputIndex)) {
            throw new Error('not a taproot musig2 input');
        }
        const input = this.data.inputs[inputIndex];
        if (!input.tapInternalKey || !input.tapMerkleRoot) {
            throw new Error('missing required input data');
        }
        // Retrieve and check that we have two participant nonces
        const participants = this.getMusig2Participants(inputIndex, input.tapInternalKey, input.tapMerkleRoot);
        const { tapOutputKey, participantPubKeys } = participants;
        const signerPubKey = participantPubKeys.find((pubKey) => equalPublicKeyIgnoreY(pubKey, signer.publicKey));
        if (!signerPubKey) {
            throw new Error('signer pub key should match one of participant pub keys');
        }
        const nonces = this.getMusig2Nonces(inputIndex, participants);
        const { hash, sighashType } = this.getTaprootHashForSig(inputIndex, sighashTypes);
        let partialSig;
        if (deterministic) {
            if (!equalPublicKeyIgnoreY(signerPubKey, participantPubKeys[1])) {
                throw new Error('can only add a deterministic signature on the cosigner');
            }
            const firstSignerNonce = nonces.find((n) => equalPublicKeyIgnoreY(n.participantPubKey, participantPubKeys[0]));
            if (!firstSignerNonce) {
                throw new Error('could not find the user nonce');
            }
            partialSig = Musig2_1.musig2DeterministicSign({
                privateKey: signer.privateKey,
                otherNonce: firstSignerNonce.pubNonce,
                publicKeys: participantPubKeys,
                internalPubKey: input.tapInternalKey,
                tapTreeRoot: input.tapMerkleRoot,
                hash,
            }).sig;
        }
        else {
            const sessionKey = Musig2_1.createMusig2SigningSession({
                pubNonces: [nonces[0].pubNonce, nonces[1].pubNonce],
                pubKeys: participantPubKeys,
                txHash: hash,
                internalPubKey: input.tapInternalKey,
                tapTreeRoot: input.tapMerkleRoot,
            });
            const signerNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, signerPubKey));
            if (!signerNonce) {
                throw new Error('pubNonce is missing. retry signing process');
            }
            partialSig = Musig2_1.musig2PartialSign(signer.privateKey, signerNonce.pubNonce, sessionKey, this.nonceStore);
        }
        if (sighashType !== __1.Transaction.SIGHASH_DEFAULT) {
            partialSig = Buffer.concat([partialSig, Buffer.of(sighashType)]);
        }
        const sig = Musig2_1.encodePsbtMusig2PartialSig({
            participantPubKey: signerPubKey,
            tapOutputKey,
            partialSig: partialSig,
        });
        this.addProprietaryKeyValToInput(inputIndex, sig);
        return this;
    }
    signTaprootInput(inputIndex, signer, leafHashes, sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL]) {
        var _a;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        // Figure out if this is script path or not, if not, tweak the private key
        if (!((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new Error('tapLeafScript is required for p2tr script path');
        }
        const pubkey = outputScripts_1.toXOnlyPublicKey(signer.publicKey);
        if (input.tapLeafScript.length !== 1) {
            throw new Error('Only one leaf script supported for signing');
        }
        const [tapLeafScript] = input.tapLeafScript;
        if (this.isMultisigTaprootScript(tapLeafScript.script)) {
            const pubKeys = parseInput_1.parsePubScript2Of3(tapLeafScript.script, 'taprootScriptPathSpend').publicKeys;
            assert(pubKeys.find((pk) => pubkey.equals(pk)), 'public key not found in tap leaf script');
        }
        const parsedControlBlock = __1.taproot.parseControlBlock(__1.ecc, tapLeafScript.controlBlock);
        const { leafVersion } = parsedControlBlock;
        if (leafVersion !== tapLeafScript.leafVersion) {
            throw new Error('Tap script leaf version mismatch with control block');
        }
        const leafHash = __1.taproot.getTapleafHash(__1.ecc, parsedControlBlock, tapLeafScript.script);
        if (!leafHashes.find((l) => l.equals(leafHash))) {
            throw new Error(`Signer cannot sign for leaf hash ${leafHash.toString('hex')}`);
        }
        const { hash, sighashType } = this.getTaprootHashForSig(inputIndex, sighashTypes, leafHash);
        let signature = signer.signSchnorr(hash);
        if (sighashType !== __1.Transaction.SIGHASH_DEFAULT) {
            signature = Buffer.concat([signature, Buffer.of(sighashType)]);
        }
        this.data.updateInput(inputIndex, {
            tapScriptSig: [
                {
                    pubkey,
                    signature,
                    leafHash,
                },
            ],
        });
        return this;
    }
    getTaprootOutputScript(inputIndex) {
        var _a;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        if ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) {
            return __1.taproot.createTaprootOutputScript({
                controlBlock: input.tapLeafScript[0].controlBlock,
                leafScript: input.tapLeafScript[0].script,
            });
        }
        else if (input.tapInternalKey && input.tapMerkleRoot) {
            return __1.taproot.createTaprootOutputScript({
                internalPubKey: input.tapInternalKey,
                taptreeRoot: input.tapMerkleRoot,
            });
        }
        throw new Error('not a taproot input');
    }
    getTaprootHashForSig(inputIndex, sighashTypes, leafHash) {
        if (!this.isTaprootInput(inputIndex)) {
            throw new Error('not a taproot input');
        }
        const sighashType = this.data.inputs[inputIndex].sighashType || __1.Transaction.SIGHASH_DEFAULT;
        if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
            throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` +
                `sighashTypes array of whitelisted types. Sighash type: ${sighashType}`);
        }
        const txInputs = this.txInputs; // These are somewhat costly to extract
        const prevoutScripts = [];
        const prevoutValues = [];
        this.data.inputs.forEach((input, i) => {
            let prevout;
            if (input.nonWitnessUtxo) {
                // TODO: This could be costly, either cache it here, or find a way to share with super
                const nonWitnessUtxoTx = this.constructor.transactionFromBuffer(input.nonWitnessUtxo, this.tx.network);
                const prevoutHash = txInputs[i].hash;
                const utxoHash = nonWitnessUtxoTx.getHash();
                // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
                if (!prevoutHash.equals(utxoHash)) {
                    throw new Error(`Non-witness UTXO hash for input #${i} doesn't match the hash specified in the prevout`);
                }
                const prevoutIndex = txInputs[i].index;
                prevout = nonWitnessUtxoTx.outs[prevoutIndex];
            }
            else if (input.witnessUtxo) {
                prevout = input.witnessUtxo;
            }
            else {
                throw new Error('Need a Utxo input item for signing');
            }
            prevoutScripts.push(prevout.script);
            prevoutValues.push(prevout.value);
        });
        const outputScript = this.getTaprootOutputScript(inputIndex);
        if (!outputScript.equals(prevoutScripts[inputIndex])) {
            throw new Error(`Witness script for input #${inputIndex} doesn't match the scriptPubKey in the prevout`);
        }
        const hash = this.tx.hashForWitnessV1(inputIndex, prevoutScripts, prevoutValues, sighashType, leafHash);
        return { hash, sighashType };
    }
    /**
     * Adds proprietary key value pair to PSBT input.
     * Default identifierEncoding is utf-8 for identifier.
     */
    addProprietaryKeyValToInput(inputIndex, keyValueData) {
        return this.addUnknownKeyValToInput(inputIndex, {
            key: proprietaryKeyVal_1.encodeProprietaryKey(keyValueData.key),
            value: keyValueData.value,
        });
    }
    /**
     * Adds or updates (if exists) proprietary key value pair to PSBT input.
     * Default identifierEncoding is utf-8 for identifier.
     */
    addOrUpdateProprietaryKeyValToInput(inputIndex, keyValueData) {
        var _a;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        const key = proprietaryKeyVal_1.encodeProprietaryKey(keyValueData.key);
        const { value } = keyValueData;
        if ((_a = input.unknownKeyVals) === null || _a === void 0 ? void 0 : _a.length) {
            const ukvIndex = input.unknownKeyVals.findIndex((ukv) => ukv.key.equals(key));
            if (ukvIndex > -1) {
                input.unknownKeyVals[ukvIndex] = { key, value };
                return this;
            }
        }
        this.addUnknownKeyValToInput(inputIndex, {
            key,
            value,
        });
        return this;
    }
    /**
     * To search any data from proprietary key value against keydata.
     * Default identifierEncoding is utf-8 for identifier.
     */
    getProprietaryKeyVals(inputIndex, keySearch) {
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        return PsbtUtil_1.getPsbtInputProprietaryKeyVals(input, keySearch);
    }
    /**
     * To delete any data from proprietary key value.
     * Default identifierEncoding is utf-8 for identifier.
     */
    deleteProprietaryKeyVals(inputIndex, keysToDelete) {
        var _a;
        const input = utils_1.checkForInput(this.data.inputs, inputIndex);
        if (!((_a = input.unknownKeyVals) === null || _a === void 0 ? void 0 : _a.length)) {
            return this;
        }
        if (keysToDelete && keysToDelete.subtype === undefined && Buffer.isBuffer(keysToDelete.keydata)) {
            throw new Error('invalid proprietary key search filter combination. subtype is required');
        }
        input.unknownKeyVals = input.unknownKeyVals.filter((keyValue, i) => {
            const key = proprietaryKeyVal_1.decodeProprietaryKey(keyValue.key);
            return !(keysToDelete === undefined ||
                (keysToDelete.identifier === key.identifier &&
                    (keysToDelete.subtype === undefined ||
                        (keysToDelete.subtype === key.subtype &&
                            (!Buffer.isBuffer(keysToDelete.keydata) || keysToDelete.keydata.equals(key.keydata))))));
        });
        return this;
    }
    createMusig2NonceForInput(inputIndex, keyPair, keyType, params = { deterministic: false }) {
        const input = this.data.inputs[inputIndex];
        if (!input.tapInternalKey) {
            throw new Error('tapInternalKey is required to create nonce');
        }
        if (!input.tapMerkleRoot) {
            throw new Error('tapMerkleRoot is required to create nonce');
        }
        const getDerivedKeyPair = () => {
            var _a;
            if (!((_a = input.tapBip32Derivation) === null || _a === void 0 ? void 0 : _a.length)) {
                throw new Error('tapBip32Derivation is required to create nonce');
            }
            const derived = UtxoPsbt.deriveKeyPair(keyPair, input.tapBip32Derivation, { ignoreY: true });
            if (!derived) {
                throw new Error('No bip32Derivation masterFingerprint matched the HD keyPair fingerprint');
            }
            return derived;
        };
        const derivedKeyPair = keyType === 'root' ? getDerivedKeyPair() : keyPair;
        if (!derivedKeyPair.privateKey) {
            throw new Error('privateKey is required to create nonce');
        }
        const participants = Musig2_1.parsePsbtMusig2Participants(input);
        if (!participants) {
            throw new Error(`Found 0 matching participant key value instead of 1`);
        }
        Musig2_1.assertPsbtMusig2Participants(participants, input.tapInternalKey, input.tapMerkleRoot);
        const { tapOutputKey, participantPubKeys } = participants;
        const participantPubKey = participantPubKeys.find((pubKey) => equalPublicKeyIgnoreY(pubKey, derivedKeyPair.publicKey));
        if (!Buffer.isBuffer(participantPubKey)) {
            throw new Error('participant plain pub key should match one bip32Derivation plain pub key');
        }
        const { hash } = this.getTaprootHashForSig(inputIndex);
        let pubNonce;
        if (params.deterministic) {
            if (params.sessionId) {
                throw new Error('Cannot add extra entropy when generating a deterministic nonce');
            }
            // There must be only 2 participant pubKeys if it got to this point
            if (!equalPublicKeyIgnoreY(participantPubKey, participantPubKeys[1])) {
                throw new Error(`Only the cosigner's nonce can be set deterministically`);
            }
            const nonces = Musig2_1.parsePsbtMusig2Nonces(input);
            if (!nonces) {
                throw new Error(`No nonces found on input #${inputIndex}`);
            }
            if (nonces.length > 2) {
                throw new Error(`Cannot have more than 2 nonces`);
            }
            const firstSignerNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, participantPubKeys[0]));
            if (!firstSignerNonce) {
                throw new Error('signer nonce must be set if cosigner nonce is to be derived deterministically');
            }
            pubNonce = Musig2_1.createMusig2DeterministicNonce({
                privateKey: derivedKeyPair.privateKey,
                otherNonce: firstSignerNonce.pubNonce,
                publicKeys: participantPubKeys,
                internalPubKey: input.tapInternalKey,
                tapTreeRoot: input.tapMerkleRoot,
                hash,
            });
        }
        else {
            pubNonce = Buffer.from(this.nonceStore.createMusig2Nonce(derivedKeyPair.privateKey, participantPubKey, tapOutputKey, hash, params.sessionId));
        }
        return { tapOutputKey, participantPubKey, pubNonce };
    }
    setMusig2NoncesInner(keyPair, keyType, inputIndex, params = { deterministic: false }) {
        if (keyPair.isNeutered()) {
            throw new Error('private key is required to generate nonce');
        }
        if (Buffer.isBuffer(params.sessionId) && params.sessionId.length !== 32) {
            throw new Error(`Invalid sessionId size ${params.sessionId.length}`);
        }
        const inputIndexes = inputIndex === undefined ? [...Array(this.inputCount).keys()] : [inputIndex];
        inputIndexes.forEach((index) => {
            if (!this.isTaprootKeyPathInput(index)) {
                return;
            }
            const nonce = this.createMusig2NonceForInput(index, keyPair, keyType, params);
            this.addOrUpdateProprietaryKeyValToInput(index, Musig2_1.encodePsbtMusig2PubNonce(nonce));
        });
        return this;
    }
    /**
     * Generates and sets MuSig2 nonce to taproot key path input at inputIndex.
     * If input is not a taproot key path, no action.
     *
     * @param inputIndex input index
     * @param keyPair derived key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     * @param deterministic If true, set the cosigner nonce deterministically
     */
    setInputMusig2Nonce(inputIndex, derivedKeyPair, params = { deterministic: false }) {
        return this.setMusig2NoncesInner(derivedKeyPair, 'derived', inputIndex, params);
    }
    /**
     * Generates and sets MuSig2 nonce to taproot key path input at inputIndex.
     * If input is not a taproot key path, no action.
     *
     * @param inputIndex input index
     * @param keyPair HD root key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     * @param deterministic If true, set the cosigner nonce deterministically
     */
    setInputMusig2NonceHD(inputIndex, keyPair, params = { deterministic: false }) {
        utils_1.checkForInput(this.data.inputs, inputIndex);
        return this.setMusig2NoncesInner(keyPair, 'root', inputIndex, params);
    }
    /**
     * Generates and sets MuSig2 nonce to all taproot key path inputs. Other inputs will be skipped.
     *
     * @param inputIndex input index
     * @param keyPair derived key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     */
    setAllInputsMusig2Nonce(keyPair, params = { deterministic: false }) {
        return this.setMusig2NoncesInner(keyPair, 'derived', undefined, params);
    }
    /**
     * Generates and sets MuSig2 nonce to all taproot key path inputs. Other inputs will be skipped.
     *
     * @param inputIndex input index
     * @param keyPair HD root key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     */
    setAllInputsMusig2NonceHD(keyPair, params = { deterministic: false }) {
        return this.setMusig2NoncesInner(keyPair, 'root', undefined, params);
    }
    clone() {
        return super.clone();
    }
    extractTransaction(disableFeeCheck) {
        const tx = super.extractTransaction(disableFeeCheck);
        if (tx instanceof UtxoTransaction_1.UtxoTransaction) {
            return tx;
        }
        throw new Error('extractTransaction did not return instace of UtxoTransaction');
    }
}
exports.UtxoPsbt = UtxoPsbt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXR4b1BzYnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYml0Z28vVXR4b1BzYnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBQ2pDLG1DQUEwQztBQVExQyxnREFBcUQ7QUFDckQsK0RBQXNFO0FBRXRFLGlDQUFxRDtBQUNyRCx1Q0FBdUM7QUFDdkMsd0VBQThGO0FBRTlGLDBCQVdZO0FBQ1osdURBQW9EO0FBQ3BELHVDQUFnRDtBQUNoRCxvREFBOEM7QUFDOUMsMERBQStDO0FBQy9DLG1EQUFtRDtBQUNuRCw2Q0FBa0Q7QUFDbEQscUNBa0JrQjtBQUNsQixtQ0FBMkQ7QUFDM0Qsd0NBQWlEO0FBQ2pELHlDQU9vQjtBQVlwQixTQUFTLG1CQUFtQixDQUFDLE9BQWdCO0lBQzNDLE1BQU0sWUFBWSxHQUFHLENBQUMsZUFBVyxDQUFDLGVBQWUsRUFBRSxlQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDNUUsUUFBUSxjQUFVLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDM0IsS0FBSyxZQUFRLENBQUMsV0FBVyxDQUFDO1FBQzFCLEtBQUssWUFBUSxDQUFDLFNBQVMsQ0FBQztRQUN4QixLQUFLLFlBQVEsQ0FBQyxXQUFXLENBQUM7UUFDMUIsS0FBSyxZQUFRLENBQUMsS0FBSztZQUNqQixPQUFPLENBQUMsR0FBRyxZQUFZLEVBQUUsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsaUNBQWUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1FBQzNGO1lBQ0UsT0FBTyxZQUFZLENBQUM7S0FDdkI7QUFDSCxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxPQUFnQixFQUFFLENBQXVDO0lBQ2xGLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFBRSxPQUFPLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxFQUFFLFlBQVksRUFBRSxD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Q2pDLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7SUFDbEYsQ0FBQztDQUNGO0FBNW9DRCw0QkE0b0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBQc2J0IGFzIFBzYnRCYXNlIH0gZnJvbSAnYmlwMTc0JztcbmltcG9ydCB7XG4gIEJpcDMyRGVyaXZhdGlvbixcbiAgUHNidElucHV0LFxuICBUYXBCaXAzMkRlcml2YXRpb24sXG4gIFRyYW5zYWN0aW9uIGFzIElUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25Gcm9tQnVmZmVyLFxufSBmcm9tICdiaXAxNzQvc3JjL2xpYi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGNoZWNrRm9ySW5wdXQgfSBmcm9tICdiaXAxNzQvc3JjL2xpYi91dGlscyc7XG5pbXBvcnQgeyBCdWZmZXJXcml0ZXIsIHZhcnVpbnQgfSBmcm9tICdiaXRjb2luanMtbGliL3NyYy9idWZmZXJ1dGlscyc7XG5pbXBvcnQgeyBTZXNzaW9uS2V5IH0gZnJvbSAnQGJyYW5kb25ibGFjay9tdXNpZyc7XG5pbXBvcnQgeyBCSVAzMkZhY3RvcnksIEJJUDMySW50ZXJmYWNlIH0gZnJvbSAnYmlwMzInO1xuaW1wb3J0ICogYXMgYnM1OGNoZWNrIGZyb20gJ2JzNThjaGVjayc7XG5pbXBvcnQgeyBkZWNvZGVQcm9wcmlldGFyeUtleSwgZW5jb2RlUHJvcHJpZXRhcnlLZXkgfSBmcm9tICdiaXAxNzQvc3JjL2xpYi9wcm9wcmlldGFyeUtleVZhbCc7XG5cbmltcG9ydCB7XG4gIHRhcHJvb3QsXG4gIEhEU2lnbmVyLFxuICBQc2J0LFxuICBQc2J0VHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uLFxuICBUeE91dHB1dCxcbiAgTmV0d29yayxcbiAgZWNjIGFzIGVjY0xpYixcbiAgZ2V0TWFpbm5ldCxcbiAgbmV0d29ya3MsXG59IGZyb20gJy4uJztcbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbiB9IGZyb20gJy4vVXR4b1RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGdldE91dHB1dElkRm9ySW5wdXQgfSBmcm9tICcuL1Vuc3BlbnQnO1xuaW1wb3J0IHsgaXNTZWd3aXQgfSBmcm9tICcuL3BzYnQvc2NyaXB0VHlwZXMnO1xuaW1wb3J0IHsgdW5zaWduIH0gZnJvbSAnLi9wc2J0L2Zyb21IYWxmU2lnbmVkJztcbmltcG9ydCB7IHRvWE9ubHlQdWJsaWNLZXkgfSBmcm9tICcuL291dHB1dFNjcmlwdHMnO1xuaW1wb3J0IHsgcGFyc2VQdWJTY3JpcHQyT2YzIH0gZnJvbSAnLi9wYXJzZUlucHV0JztcbmltcG9ydCB7XG4gIGNyZWF0ZU11c2lnMlNpZ25pbmdTZXNzaW9uLFxuICBlbmNvZGVQc2J0TXVzaWcyUGFydGlhbFNpZyxcbiAgZW5jb2RlUHNidE11c2lnMlB1Yk5vbmNlLFxuICBtdXNpZzJQYXJ0aWFsU2lnbixcbiAgcGFyc2VQc2J0TXVzaWcyTm9uY2VzLFxuICBwYXJzZVBzYnRNdXNpZzJQYXJ0aWNpcGFudHMsXG4gIFBzYnRNdXNpZzJQYXJ0aWNpcGFudHMsXG4gIGFzc2VydFBzYnRNdXNpZzJOb25jZXMsXG4gIGFzc2VydFBzYnRNdXNpZzJQYXJ0aWNpcGFudHMsXG4gIE11c2lnMk5vbmNlU3RvcmUsXG4gIFBzYnRNdXNpZzJQdWJOb25jZSxcbiAgcGFyc2VQc2J0TXVzaWcyUGFydGlhbFNpZ3MsXG4gIG11c2lnMlBhcnRpYWxTaWdWZXJpZnksXG4gIG11c2lnMkFnZ3JlZ2F0ZVNpZ3MsXG4gIGdldFNpZ0hhc2hUeXBlRnJvbVNpZ3MsXG4gIG11c2lnMkRldGVybWluaXN0aWNTaWduLFxuICBjcmVhdGVNdXNpZzJEZXRlcm1pbmlzdGljTm9uY2UsXG59IGZyb20gJy4vTXVzaWcyJztcbmltcG9ydCB7IGlzVHJpcGxlLCBpc1R1cGxlLCBUcmlwbGUsIFR1cGxlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRUYXByb290T3V0cHV0S2V5IH0gZnJvbSAnLi4vdGFwcm9vdCc7XG5pbXBvcnQge1xuICBnZXRQc2J0SW5wdXRQcm9wcmlldGFyeUtleVZhbHMsXG4gIGdldFBzYnRJbnB1dFNpZ25hdHVyZUNvdW50LFxuICBQcm9wcmlldGFyeUtleVNlYXJjaCxcbiAgUHJvcHJpZXRhcnlLZXlTdWJ0eXBlLFxuICBQcm9wcmlldGFyeUtleVZhbHVlLFxuICBQU0JUX1BST1BSSUVUQVJZX0lERU5USUZJRVIsXG59IGZyb20gJy4vUHNidFV0aWwnO1xuXG50eXBlIFNpZ25hdHVyZVBhcmFtcyA9IHtcbiAgLyoqIFdoZW4gdHJ1ZSwgYW5kIGFkZCB0aGUgc2Vjb25kIChsYXN0KSBub25jZSBhbmQgc2lnbmF0dXJlIGZvciBhIHRhcHJvb3Qga2V5XG4gICAqIHBhdGggc3BlbmQgZGV0ZXJtaW5pc3RpY2FsbHkuIFRocm93cyBhbiBlcnJvciBpZiBkb25lIGZvciB0aGUgZmlyc3Qgbm9uY2Uvc2lnbmF0dXJlXG4gICAqIG9mIGEgdGFwcm9vdCBrZXlwYXRoIHNwZW5kLiBJZ25vcmUgZm9yIGFsbCBvdGhlciBpbnB1dCB0eXBlcy5cbiAgICovXG4gIGRldGVybWluaXN0aWM6IGJvb2xlYW47XG4gIC8qKiBBbGxvd2VkIHNpZ2hhc2ggdHlwZXMgKi9cbiAgc2lnaGFzaFR5cGVzOiBudW1iZXJbXTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRTaWdoYXNoVHlwZXMobmV0d29yazogTmV0d29yayk6IG51bWJlcltdIHtcbiAgY29uc3Qgc2lnaGFzaFR5cGVzID0gW1RyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCwgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdO1xuICBzd2l0Y2ggKGdldE1haW5uZXQobmV0d29yaykpIHtcbiAgICBjYXNlIG5ldHdvcmtzLmJpdGNvaW5jYXNoOlxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbnN2OlxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbmdvbGQ6XG4gICAgY2FzZSBuZXR3b3Jrcy5lY2FzaDpcbiAgICAgIHJldHVybiBbLi4uc2lnaGFzaFR5cGVzLCAuLi5zaWdoYXNoVHlwZXMubWFwKChzKSA9PiBzIHwgVXR4b1RyYW5zYWN0aW9uLlNJR0hBU0hfRk9SS0lEKV07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzaWdoYXNoVHlwZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TaWduYXR1cmVQYXJhbXMobmV0d29yazogTmV0d29yaywgdj86IFBhcnRpYWw8U2lnbmF0dXJlUGFyYW1zPiB8IG51bWJlcltdKTogU2lnbmF0dXJlUGFyYW1zIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiB0b1NpZ25hdHVyZVBhcmFtcyhuZXR3b3JrLCB7IHNpZ2hhc2hUeXBlczogdiB9KTtcbiAgcmV0dXJuIHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UsIHNpZ2hhc2hUeXBlczogZGVmYXVsdFNpZ2hhc2hUeXBlcyhuZXR3b3JrKSwgLi4udiB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIHB1YmxpYyBrZXlzIGFyZSBlcXVhbCBpZ25vcmluZyB0aGUgeSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBlcXVhbFB1YmxpY0tleUlnbm9yZVkoYTogQnVmZmVyLCBiOiBCdWZmZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRvWE9ubHlQdWJsaWNLZXkoYSkuZXF1YWxzKHRvWE9ubHlQdWJsaWNLZXkoYikpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhEVGFwcm9vdFNpZ25lciBleHRlbmRzIEhEU2lnbmVyIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHN0cmluZyBtdXN0IG1hdGNoIC9ebShcXC9cXGQrJz8pKyQvXG4gICAqIGV4LiBtLzQ0Jy8wJy8wJy8xLzIzIGxldmVscyB3aXRoICcgbXVzdCBiZSBoYXJkIGRlcml2YXRpb25zXG4gICAqL1xuICBkZXJpdmVQYXRoKHBhdGg6IHN0cmluZyk6IEhEVGFwcm9vdFNpZ25lcjtcbiAgLyoqXG4gICAqIElucHV0IGhhc2ggKHRoZSBcIm1lc3NhZ2UgZGlnZXN0XCIpIGZvciB0aGUgc2lnbmF0dXJlIGFsZ29yaXRobVxuICAgKiBSZXR1cm4gYSA2NCBieXRlIHNpZ25hdHVyZSAoMzIgYnl0ZSByIGFuZCAzMiBieXRlIHMgaW4gdGhhdCBvcmRlcilcbiAgICovXG4gIHNpZ25TY2hub3JyKGhhc2g6IEJ1ZmZlcik6IEJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBIRCBzaWduZXIgb2JqZWN0IGZvciB0YXByb290IHAydHIgbXVzaWcyIGtleSBwYXRoIHNpZ25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIRFRhcHJvb3RNdXNpZzJTaWduZXIgZXh0ZW5kcyBIRFNpZ25lciB7XG4gIC8qKlxuICAgKiBNdXNpZzIgcmVxdWlyZXMgc2lnbmVyJ3MgMzItYnl0ZXMgcHJpdmF0ZSBrZXkgdG8gYmUgcGFzc2VkIHRvIGl0LlxuICAgKi9cbiAgcHJpdmF0ZUtleTogQnVmZmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCBzdHJpbmcgbXVzdCBtYXRjaCAvXm0oXFwvXFxkKyc/KSskL1xuICAgKiBleC4gbS80NCcvMCcvMCcvMS8yMyBsZXZlbHMgd2l0aCAnIG11c3QgYmUgaGFyZCBkZXJpdmF0aW9uc1xuICAgKi9cbiAgZGVyaXZlUGF0aChwYXRoOiBzdHJpbmcpOiBIRFRhcHJvb3RNdXNpZzJTaWduZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nobm9yclNpZ25lciB7XG4gIHB1YmxpY0tleTogQnVmZmVyO1xuICBzaWduU2Nobm9ycihoYXNoOiBCdWZmZXIpOiBCdWZmZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXVzaWcyU2lnbmVyIHtcbiAgcHVibGljS2V5OiBCdWZmZXI7XG4gIHByaXZhdGVLZXk6IEJ1ZmZlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYXByb290U2lnbmVyIHtcbiAgbGVhZkhhc2hlczogQnVmZmVyW107XG4gIHNpZ25lcjogU2Nobm9yclNpZ25lcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQc2J0T3B0cyB7XG4gIG5ldHdvcms6IE5ldHdvcms7XG4gIG1heGltdW1GZWVSYXRlPzogbnVtYmVyOyAvLyBbc2F0L2J5dGVdXG4gIGJpcDMyUGF0aHNBYnNvbHV0ZT86IGJvb2xlYW47XG59XG5cbi8vIFRPRE86IHVwc3RyZWFtIGRvZXMgYGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZ3NgIGJlZm9yZSBkb2luZyB0aGluZ3MgbGlrZVxuLy8gYHNldFZlcnNpb25gLiBPdXIgaW5wdXRzIGNvdWxkIGhhdmUgdGFwc2NyaXB0c2lncyAob3IgaW4gZnV0dXJlIHRhcGtleXNpZ3MpXG4vLyBhbmQgbm90IGZhaWwgdGhhdCBjaGVjay4gRG8gd2Ugd2FudCB0byBkbyBhbnl0aGluZyBhYm91dCB0aGF0P1xuZXhwb3J0IGNsYXNzIFV0eG9Qc2J0PFR4IGV4dGVuZHMgVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4gPSBVdHhvVHJhbnNhY3Rpb248YmlnaW50Pj4gZXh0ZW5kcyBQc2J0IHtcbiAgcHJpdmF0ZSBub25jZVN0b3JlID0gbmV3IE11c2lnMk5vbmNlU3RvcmUoKTtcblxuICBwcm90ZWN0ZWQgc3RhdGljIHRyYW5zYWN0aW9uRnJvbUJ1ZmZlcihidWZmZXI6IEJ1ZmZlciwgbmV0d29yazogTmV0d29yayk6IFV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+IHtcbiAgICByZXR1cm4gVXR4b1RyYW5zYWN0aW9uLmZyb21CdWZmZXI8YmlnaW50PihidWZmZXIsIGZhbHNlLCAnYmlnaW50JywgbmV0d29yayk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlUHNidChvcHRzOiBQc2J0T3B0cywgZGF0YT86IFBzYnRCYXNlKTogVXR4b1BzYnQge1xuICAgIHJldHVybiBuZXcgVXR4b1BzYnQoXG4gICAgICBvcHRzLFxuICAgICAgZGF0YSB8fCBuZXcgUHNidEJhc2UobmV3IFBzYnRUcmFuc2FjdGlvbih7IHR4OiBuZXcgVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4ob3B0cy5uZXR3b3JrKSB9KSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyOiBCdWZmZXIsIG9wdHM6IFBzYnRPcHRzKTogVXR4b1BzYnQge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uRnJvbUJ1ZmZlcjogVHJhbnNhY3Rpb25Gcm9tQnVmZmVyID0gKGJ1ZmZlcjogQnVmZmVyKTogSVRyYW5zYWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbkZyb21CdWZmZXIoYnVmZmVyLCBvcHRzLm5ldHdvcmspO1xuICAgICAgcmV0dXJuIG5ldyBQc2J0VHJhbnNhY3Rpb24oeyB0eCB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHBzYnRCYXNlID0gUHNidEJhc2UuZnJvbUJ1ZmZlcihidWZmZXIsIHRyYW5zYWN0aW9uRnJvbUJ1ZmZlciwge1xuICAgICAgYmlwMzJQYXRoc0Fic29sdXRlOiBvcHRzLmJpcDMyUGF0aHNBYnNvbHV0ZSxcbiAgICB9KTtcbiAgICBjb25zdCBwc2J0ID0gdGhpcy5jcmVhdGVQc2J0KG9wdHMsIHBzYnRCYXNlKTtcbiAgICAvLyBVcHN0cmVhbSBjaGVja3MgZm9yIGR1cGxpY2F0ZSBpbnB1dHMgaGVyZSwgYnV0IGl0IHNlZW1zIHRvIGJlIG9mIGR1YmlvdXMgdmFsdWUuXG4gICAgcmV0dXJuIHBzYnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUhleChkYXRhOiBzdHJpbmcsIG9wdHM6IFBzYnRPcHRzKTogVXR4b1BzYnQge1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyZW50IC0gUGFyZW50IGtleS4gTWF0Y2hlZCB3aXRoIGBiaXAzMkRlcml2YXRpb25zYCB1c2luZyBgZmluZ2VycHJpbnRgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gYmlwMzJEZXJpdmF0aW9ucyAtIHBvc3NpYmxlIGRlcml2YXRpb25zIGZvciBpbnB1dCBvciBvdXRwdXRcbiAgICogQHBhcmFtIGlnbm9yZVkgLSB3aGVuIHRydWUsIGlnbm9yZSB0aGUgeSBjb29yZGluYXRlIHdoZW4gbWF0Y2hpbmcgcHVibGljIGtleXNcbiAgICogQHJldHVybiBkZXJpdmVkIGJpcDMyIG5vZGUgaWYgbWF0Y2hpbmcgZGVyaXZhdGlvbiBpcyBmb3VuZCwgdW5kZWZpbmVkIGlmIG5vbmUgaXMgZm91bmRcbiAgICogQHRocm93cyBFcnJvciBpZiBtb3JlIHRoYW4gb25lIG1hdGNoIGlzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZGVyaXZlS2V5UGFpcihcbiAgICBwYXJlbnQ6IEJJUDMySW50ZXJmYWNlLFxuICAgIGJpcDMyRGVyaXZhdGlvbnM6IEJpcDMyRGVyaXZhdGlvbltdLFxuICAgIHsgaWdub3JlWSB9OiB7IGlnbm9yZVk6IGJvb2xlYW4gfVxuICApOiBCSVAzMkludGVyZmFjZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgbWF0Y2hpbmdEZXJpdmF0aW9ucyA9IGJpcDMyRGVyaXZhdGlvbnMuZmlsdGVyKChiaXBEdikgPT4ge1xuICAgICAgcmV0dXJuIGJpcER2Lm1hc3RlckZpbmdlcnByaW50LmVxdWFscyhwYXJlbnQuZmluZ2VycHJpbnQpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFtYXRjaGluZ0Rlcml2YXRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gTm8gZmluZ2VycHJpbnQgbWF0Y2hcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoaW5nRGVyaXZhdGlvbnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBtb3JlIHRoYW4gb25lIG1hdGNoaW5nIGRlcml2YXRpb24gZm9yIGZpbmdlcnByaW50ICR7cGFyZW50LmZpbmdlcnByaW50LnRvU3RyaW5nKCdoZXgnKX06ICR7XG4gICAgICAgICAgbWF0Y2hpbmdEZXJpdmF0aW9ucy5sZW5ndGhcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgW2Rlcml2YXRpb25dID0gbWF0Y2hpbmdEZXJpdmF0aW9ucztcbiAgICBjb25zdCBub2RlID0gcGFyZW50LmRlcml2ZVBhdGgoZGVyaXZhdGlvbi5wYXRoKTtcblxuICAgIGlmICghbm9kZS5wdWJsaWNLZXkuZXF1YWxzKGRlcml2YXRpb24ucHVia2V5KSkge1xuICAgICAgaWYgKCFpZ25vcmVZIHx8ICFlcXVhbFB1YmxpY0tleUlnbm9yZVkobm9kZS5wdWJsaWNLZXksIGRlcml2YXRpb24ucHVia2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YmtleSBkaWQgbm90IG1hdGNoIGJpcDMyRGVyaXZhdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc3RhdGljIGRlcml2ZUtleVBhaXJGb3JJbnB1dChiaXAzMjogQklQMzJJbnRlcmZhY2UsIGlucHV0OiBQc2J0SW5wdXQpOiBCdWZmZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24/Lmxlbmd0aFxuICAgICAgPyBVdHhvUHNidC5kZXJpdmVLZXlQYWlyKGJpcDMyLCBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24sIHsgaWdub3JlWTogdHJ1ZSB9KT8ucHVibGljS2V5XG4gICAgICA6IGlucHV0LmJpcDMyRGVyaXZhdGlvbj8ubGVuZ3RoXG4gICAgICA/IFV0eG9Qc2J0LmRlcml2ZUtleVBhaXIoYmlwMzIsIGlucHV0LmJpcDMyRGVyaXZhdGlvbiwgeyBpZ25vcmVZOiBmYWxzZSB9KT8ucHVibGljS2V5XG4gICAgICA6IGJpcDMyPy5wdWJsaWNLZXk7XG4gIH1cblxuICBnZXQgbmV0d29yaygpOiBOZXR3b3JrIHtcbiAgICByZXR1cm4gdGhpcy50eC5uZXR3b3JrO1xuICB9XG5cbiAgdG9IZXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBpcyBleHBlbnNpdmUgdG8gYXR0ZW1wdCB0byBjb21wdXRlIGV2ZXJ5IG91dHB1dCBhZGRyZXNzIHVzaW5nIHBzYnQudHhPdXRwdXRzW291dHB1dEluZGV4XVxuICAgKiB0byB0aGVuIGp1c3QgZ2V0IHRoZSBzY3JpcHQuIEhlcmUsIHdlIGFyZSBkb2luZyB0aGUgc2FtZSB0aGluZyBhcyB3aGF0IHR4T3V0cHV0cygpIGRvZXMgaW5cbiAgICogYml0Y29pbmpzLWxpYiwgYnV0IHdpdGhvdXQgaXRlcmF0aW5nIG92ZXIgZWFjaCBvdXRwdXQuXG4gICAqIEBwYXJhbSBvdXRwdXRJbmRleFxuICAgKiBAcmV0dXJucyBvdXRwdXQgc2NyaXB0IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKi9cbiAgZ2V0T3V0cHV0U2NyaXB0KG91dHB1dEluZGV4OiBudW1iZXIpOiBCdWZmZXIge1xuICAgIHJldHVybiAodGhpcyBhcyBhbnkpLl9fQ0FDSEUuX19UWC5vdXRzW291dHB1dEluZGV4XS5zY3JpcHQgYXMgQnVmZmVyO1xuICB9XG5cbiAgZ2V0Tm9uV2l0bmVzc1ByZXZpb3VzVHhpZHMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHR4SW5wdXRzID0gdGhpcy50eElucHV0czsgLy8gVGhlc2UgYXJlIHNvbWV3aGF0IGNvc3RseSB0byBleHRyYWN0XG4gICAgY29uc3QgdHhpZFNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIHRoaXMuZGF0YS5pbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBoYXZlIHdpdG5lc3MgVVRYTyBmb3IgYWxsIGlucHV0cycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1NlZ3dpdChpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQsIGlucHV0LnJlZGVlbVNjcmlwdCkpIHtcbiAgICAgICAgdHhpZFNldC5hZGQoZ2V0T3V0cHV0SWRGb3JJbnB1dCh0eElucHV0c1tpbmRleF0pLnR4aWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbLi4udHhpZFNldF07XG4gIH1cblxuICBhZGROb25XaXRuZXNzVXR4b3ModHhCdWZzOiBSZWNvcmQ8c3RyaW5nLCBCdWZmZXI+KTogdGhpcyB7XG4gICAgY29uc3QgdHhJbnB1dHMgPSB0aGlzLnR4SW5wdXRzOyAvLyBUaGVzZSBhcmUgc29tZXdoYXQgY29zdGx5IHRvIGV4dHJhY3RcbiAgICB0aGlzLmRhdGEuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgaGF2ZSB3aXRuZXNzIFVUWE8gZm9yIGFsbCBpbnB1dHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTZWd3aXQoaW5wdXQud2l0bmVzc1V0eG8uc2NyaXB0LCBpbnB1dC5yZWRlZW1TY3JpcHQpKSB7XG4gICAgICAgIGNvbnN0IHsgdHhpZCB9ID0gZ2V0T3V0cHV0SWRGb3JJbnB1dCh0eElucHV0c1tpbmRleF0pO1xuICAgICAgICBpZiAodHhCdWZzW3R4aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbGwgcmVxdWlyZWQgcHJldmlvdXMgdHJhbnNhY3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dChpbmRleCwgeyBub25XaXRuZXNzVXR4bzogdHhCdWZzW3R4aWRdIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4sIHByZXZPdXRwdXRzOiBUeE91dHB1dDxiaWdpbnQ+W10pOiBVdHhvUHNidCB7XG4gICAgaWYgKHByZXZPdXRwdXRzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJhbnNhY3Rpb24gaGFzICR7dHJhbnNhY3Rpb24uaW5zLmxlbmd0aH0gaW5wdXRzLCBidXQgJHtwcmV2T3V0cHV0cy5sZW5ndGh9IHByZXZpb3VzIG91dHB1dHMgcHJvdmlkZWRgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLmNsb25lKCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IHVuc2lnbihjbG9uZWRUcmFuc2FjdGlvbiwgcHJldk91dHB1dHMpO1xuXG4gICAgY29uc3QgcHNidEJhc2UgPSBuZXcgUHNidEJhc2UobmV3IFBzYnRUcmFuc2FjdGlvbih7IHR4OiBjbG9uZWRUcmFuc2FjdGlvbiB9KSk7XG4gICAgY2xvbmVkVHJhbnNhY3Rpb24uaW5zLmZvckVhY2goKCkgPT4gcHNidEJhc2UuaW5wdXRzLnB1c2goeyB1bmtub3duS2V5VmFsczogW10gfSkpO1xuICAgIGNsb25lZFRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaCgoKSA9PiBwc2J0QmFzZS5vdXRwdXRzLnB1c2goeyB1bmtub3duS2V5VmFsczogW10gfSkpO1xuICAgIGNvbnN0IHBzYnQgPSB0aGlzLmNyZWF0ZVBzYnQoeyBuZXR3b3JrOiB0cmFuc2FjdGlvbi5uZXR3b3JrIH0sIHBzYnRCYXNlKTtcblxuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlLCBpbmRleCkgPT4ge1xuICAgICAgcHNidC51cGRhdGVJbnB1dChpbmRleCwgdXBkYXRlKTtcbiAgICAgIHBzYnQudXBkYXRlSW5wdXQoaW5kZXgsIHsgd2l0bmVzc1V0eG86IHsgc2NyaXB0OiBwcmV2T3V0cHV0c1tpbmRleF0uc2NyaXB0LCB2YWx1ZTogcHJldk91dHB1dHNbaW5kZXhdLnZhbHVlIH0gfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHNidDtcbiAgfVxuXG4gIGdldFVuc2lnbmVkVHgoKTogVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4ge1xuICAgIHJldHVybiB0aGlzLnR4LmNsb25lKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIG5ld1RyYW5zYWN0aW9uKG5ldHdvcms6IE5ldHdvcmspOiBVdHhvVHJhbnNhY3Rpb248YmlnaW50PiB7XG4gICAgcmV0dXJuIG5ldyBVdHhvVHJhbnNhY3Rpb248YmlnaW50PihuZXR3b3JrKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgdHgoKTogVHgge1xuICAgIHJldHVybiAodGhpcy5kYXRhLmdsb2JhbE1hcC51bnNpZ25lZFR4IGFzIFBzYnRUcmFuc2FjdGlvbikudHggYXMgVHg7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tGb3JTaWduYXR1cmVzKHByb3BOYW1lPzogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kYXRhLmlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0LnRhcFNjcmlwdFNpZz8ubGVuZ3RoIHx8IGlucHV0LnRhcEtleVNpZyB8fCBpbnB1dC5wYXJ0aWFsU2lnPy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbW9kaWZ5ICR7cHJvcE5hbWUgPz8gJ3RyYW5zYWN0aW9uJ30gLSBzaWduYXR1cmVzIGV4aXN0LmApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IGlucHV0SW5kZXggaXMgYSB0YXByb290IGtleSBwYXRoLlxuICAgKiBDaGVja3MgZm9yIHByZXNlbmNlIG9mIG1pbmltdW0gcmVxdWlyZWQga2V5IHBhdGggaW5wdXQgZmllbGRzIGFuZCBhYnNlbmNlIG9mIGFueSBzY3JpcHQgcGF0aCBvbmx5IGlucHV0IGZpZWxkcy5cbiAgICovXG4gIGlzVGFwcm9vdEtleVBhdGhJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgICEhaW5wdXQudGFwSW50ZXJuYWxLZXkgJiZcbiAgICAgICEhaW5wdXQudGFwTWVya2xlUm9vdCAmJlxuICAgICAgIShcbiAgICAgICAgaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoIHx8XG4gICAgICAgIGlucHV0LnRhcFNjcmlwdFNpZz8ubGVuZ3RoIHx8XG4gICAgICAgIGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbj8uc29tZSgodikgPT4gdi5sZWFmSGFzaGVzLmxlbmd0aClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IGlucHV0SW5kZXggaXMgYSB0YXByb290IHNjcmlwdCBwYXRoLlxuICAgKiBDaGVja3MgZm9yIHByZXNlbmNlIG9mIG1pbmltdW0gcmVxdWlyZWQgc2NyaXB0IHBhdGggaW5wdXQgZmllbGRzIGFuZCBhYnNlbmNlIG9mIGFueSBrZXkgcGF0aCBvbmx5IGlucHV0IGZpZWxkcy5cbiAgICovXG4gIGlzVGFwcm9vdFNjcmlwdFBhdGhJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgICEhaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoICYmXG4gICAgICAhKFxuICAgICAgICB0aGlzLmdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7XG4gICAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICAgIHN1YnR5cGU6IFByb3ByaWV0YXJ5S2V5U3VidHlwZS5NVVNJRzJfUEFSVElDSVBBTlRfUFVCX0tFWVMsXG4gICAgICAgIH0pLmxlbmd0aCB8fFxuICAgICAgICB0aGlzLmdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7XG4gICAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICAgIHN1YnR5cGU6IFByb3ByaWV0YXJ5S2V5U3VidHlwZS5NVVNJRzJfUFVCX05PTkNFLFxuICAgICAgICB9KS5sZW5ndGggfHxcbiAgICAgICAgdGhpcy5nZXRQcm9wcmlldGFyeUtleVZhbHMoaW5wdXRJbmRleCwge1xuICAgICAgICAgIGlkZW50aWZpZXI6IFBTQlRfUFJPUFJJRVRBUllfSURFTlRJRklFUixcbiAgICAgICAgICBzdWJ0eXBlOiBQcm9wcmlldGFyeUtleVN1YnR5cGUuTVVTSUcyX1BBUlRJQUxfU0lHLFxuICAgICAgICB9KS5sZW5ndGhcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IGlucHV0SW5kZXggaXMgYSB0YXByb290XG4gICAqL1xuICBpc1RhcHJvb3RJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3QgaXNQMlRSID0gKHNjcmlwdDogQnVmZmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBnZXRUYXByb290T3V0cHV0S2V5KHNjcmlwdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gISEoXG4gICAgICBpbnB1dC50YXBJbnRlcm5hbEtleSB8fFxuICAgICAgaW5wdXQudGFwTWVya2xlUm9vdCB8fFxuICAgICAgaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoIHx8XG4gICAgICBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24/Lmxlbmd0aCB8fFxuICAgICAgaW5wdXQudGFwU2NyaXB0U2lnPy5sZW5ndGggfHxcbiAgICAgIHRoaXMuZ2V0UHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0SW5kZXgsIHtcbiAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICBzdWJ0eXBlOiBQcm9wcmlldGFyeUtleVN1YnR5cGUuTVVTSUcyX1BBUlRJQ0lQQU5UX1BVQl9LRVlTLFxuICAgICAgfSkubGVuZ3RoIHx8XG4gICAgICB0aGlzLmdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7XG4gICAgICAgIGlkZW50aWZpZXI6IFBTQlRfUFJPUFJJRVRBUllfSURFTlRJRklFUixcbiAgICAgICAgc3VidHlwZTogUHJvcHJpZXRhcnlLZXlTdWJ0eXBlLk1VU0lHMl9QVUJfTk9OQ0UsXG4gICAgICB9KS5sZW5ndGggfHxcbiAgICAgIHRoaXMuZ2V0UHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0SW5kZXgsIHtcbiAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICBzdWJ0eXBlOiBQcm9wcmlldGFyeUtleVN1YnR5cGUuTVVTSUcyX1BBUlRJQUxfU0lHLFxuICAgICAgfSkubGVuZ3RoIHx8XG4gICAgICAoaW5wdXQud2l0bmVzc1V0eG8gJiYgaXNQMlRSKGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCkpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNNdWx0aXNpZ1RhcHJvb3RTY3JpcHQoc2NyaXB0OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VQdWJTY3JpcHQyT2YzKHNjcmlwdCwgJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9zdGx5IGNvcGllZCBmcm9tIGJpdGNvaW5qcy1saWIvdHNfc3JjL3BzYnQudHNcbiAgICovXG4gIGZpbmFsaXplQWxsSW5wdXRzKCk6IHRoaXMge1xuICAgIGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgdGhpcy5kYXRhLmlucHV0cy5tYXAoKGlucHV0LCBpZHgpID0+IHtcbiAgICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNNdWx0aXNpZ1RhcHJvb3RTY3JpcHQoaW5wdXQudGFwTGVhZlNjcmlwdFswXS5zY3JpcHQpXG4gICAgICAgICAgPyB0aGlzLmZpbmFsaXplVGFwcm9vdElucHV0KGlkeClcbiAgICAgICAgICA6IHRoaXMuZmluYWxpemVUYXBJbnB1dFdpdGhTaW5nbGVMZWFmU2NyaXB0QW5kU2lnbmF0dXJlKGlkeCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUYXByb290S2V5UGF0aElucHV0KGlkeCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemVUYXByb290TXVzaWcySW5wdXQoaWR4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplSW5wdXQoaWR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZpbmFsaXplVGFwcm9vdElucHV0KGlucHV0SW5kZXg6IG51bWJlcik6IHRoaXMge1xuICAgIGNvbnN0IGNoZWNrUGFydGlhbFNpZ1NpZ2hhc2hlcyA9IChzaWc6IEJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3Qgc2lnaGFzaFR5cGUgPSBzaWcubGVuZ3RoID09PSA2NCA/IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCA6IHNpZy5yZWFkVUludDgoc2lnLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgaW5wdXRTaWdoYXNoVHlwZSA9IGlucHV0LnNpZ2hhc2hUeXBlID09PSB1bmRlZmluZWQgPyBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQgOiBpbnB1dC5zaWdoYXNoVHlwZTtcbiAgICAgIGFzc2VydChzaWdoYXNoVHlwZSA9PT0gaW5wdXRTaWdoYXNoVHlwZSwgJ3NpZ25hdHVyZSBzaWdoYXNoIGRvZXMgbm90IG1hdGNoIGlucHV0IHNpZ2hhc2ggdHlwZScpO1xuICAgIH07XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIC8vIHdpdG5lc3MgPSBjb250cm9sLWJsb2NrIHNjcmlwdCBmaXJzdC1zaWcgc2Vjb25kLXNpZ1xuICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgbGVhZiBzY3JpcHQgc3VwcG9ydGVkIGZvciBmaW5hbGl6aW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udHJvbEJsb2NrLCBzY3JpcHQgfSA9IGlucHV0LnRhcExlYWZTY3JpcHRbMF07XG4gICAgY29uc3Qgd2l0bmVzczogQnVmZmVyW10gPSBbc2NyaXB0LCBjb250cm9sQmxvY2tdO1xuICAgIGNvbnN0IFtwdWJrZXkxLCBwdWJrZXkyXSA9IHBhcnNlUHViU2NyaXB0Mk9mMyhzY3JpcHQsICd0YXByb290U2NyaXB0UGF0aFNwZW5kJykucHVibGljS2V5cztcbiAgICBmb3IgKGNvbnN0IHBrIG9mIFtwdWJrZXkxLCBwdWJrZXkyXSkge1xuICAgICAgY29uc3Qgc2lnID0gaW5wdXQudGFwU2NyaXB0U2lnPy5maW5kKCh7IHB1YmtleSB9KSA9PiBlcXVhbFB1YmxpY0tleUlnbm9yZVkocGssIHB1YmtleSkpO1xuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBzaWduYXR1cmVzIGluIFNjcmlwdCBTaWcuJyk7XG4gICAgICB9XG4gICAgICBjaGVja1BhcnRpYWxTaWdTaWdoYXNoZXMoc2lnLnNpZ25hdHVyZSk7XG4gICAgICB3aXRuZXNzLnVuc2hpZnQoc2lnLnNpZ25hdHVyZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2l0bmVzc0xlbmd0aCA9IHdpdG5lc3MucmVkdWNlKChzLCBiKSA9PiBzICsgYi5sZW5ndGggKyB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGIubGVuZ3RoKSwgMSk7XG5cbiAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHdpdG5lc3NMZW5ndGgpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVZlY3Rvcih3aXRuZXNzKTtcbiAgICBjb25zdCBmaW5hbFNjcmlwdFdpdG5lc3MgPSBidWZmZXJXcml0ZXIuZW5kKCk7XG5cbiAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgdGhpcy5kYXRhLmNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZXMgYSB0YXByb290IG11c2lnMiBpbnB1dCBieSBhZ2dyZWdhdGluZyBhbGwgcGFydGlhbCBzaWdzLlxuICAgKiBJTVBPUlRBTlQ6IEFsd2F5cyBjYWxsIHZhbGlkYXRlKiBmdW5jdGlvbiBiZWZvcmUgZmluYWxpemluZy5cbiAgICovXG4gIGZpbmFsaXplVGFwcm9vdE11c2lnMklucHV0KGlucHV0SW5kZXg6IG51bWJlcik6IHRoaXMge1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBwYXJ0aWFsU2lncyA9IHBhcnNlUHNidE11c2lnMlBhcnRpYWxTaWdzKGlucHV0KTtcbiAgICBpZiAocGFydGlhbFNpZ3M/Lmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG51bWJlciBvZiBwYXJ0aWFsIHNpZ25hdHVyZXMgJHtwYXJ0aWFsU2lncyA/IHBhcnRpYWxTaWdzLmxlbmd0aCA6IDB9IHRvIGZpbmFsaXplYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcGFydGlhbFNpZ3M6IHBTaWdzLCBzaWdIYXNoVHlwZSB9ID0gZ2V0U2lnSGFzaFR5cGVGcm9tU2lncyhwYXJ0aWFsU2lncyk7XG4gICAgY29uc3QgeyBzZXNzaW9uS2V5IH0gPSB0aGlzLmdldE11c2lnMlNlc3Npb25LZXkoaW5wdXRJbmRleCwgc2lnSGFzaFR5cGUpO1xuXG4gICAgY29uc3QgYWdnU2lnID0gbXVzaWcyQWdncmVnYXRlU2lncyhcbiAgICAgIHBTaWdzLm1hcCgocFNpZykgPT4gcFNpZy5wYXJ0aWFsU2lnKSxcbiAgICAgIHNlc3Npb25LZXlcbiAgICApO1xuXG4gICAgY29uc3Qgc2lnID0gc2lnSGFzaFR5cGUgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCA/IGFnZ1NpZyA6IEJ1ZmZlci5jb25jYXQoW2FnZ1NpZywgQnVmZmVyLm9mKHNpZ0hhc2hUeXBlKV0pO1xuXG4gICAgLy8gc2luZ2xlIHNpZ25hdHVyZSB3aXRoIDY0LzY1IGJ5dGVzIHNpemUgaXMgc2NyaXB0IHdpdG5lc3MgZm9yIGtleSBwYXRoIHNwZW5kXG4gICAgY29uc3QgYnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eSgxICsgdmFydWludC5lbmNvZGluZ0xlbmd0aChzaWcubGVuZ3RoKSArIHNpZy5sZW5ndGgpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVZlY3Rvcihbc2lnXSk7XG4gICAgY29uc3QgZmluYWxTY3JpcHRXaXRuZXNzID0gYnVmZmVyV3JpdGVyLmVuZCgpO1xuXG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIHRoaXMuZGF0YS5jbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpO1xuICAgIC8vIGRlbGV0aW5nIG9ubHkgQml0R28gcHJvcHJpZXRhcnkga2V5IHZhbHVlcy5cbiAgICB0aGlzLmRlbGV0ZVByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7IGlkZW50aWZpZXI6IFBTQlRfUFJPUFJJRVRBUllfSURFTlRJRklFUiB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZpbmFsaXplVGFwSW5wdXRXaXRoU2luZ2xlTGVhZlNjcmlwdEFuZFNpZ25hdHVyZShpbnB1dEluZGV4OiBudW1iZXIpOiB0aGlzIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKGlucHV0LnRhcExlYWZTY3JpcHQ/Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBsZWFmIHNjcmlwdCBzdXBwb3J0ZWQgZm9yIGZpbmFsaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnRhcFNjcmlwdFNpZz8ubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHNpZ25hdHVyZXMgaW4gU2NyaXB0IFNpZy4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbnRyb2xCbG9jaywgc2NyaXB0IH0gPSBpbnB1dC50YXBMZWFmU2NyaXB0WzBdO1xuICAgIGNvbnN0IHdpdG5lc3M6IEJ1ZmZlcltdID0gW2lucHV0LnRhcFNjcmlwdFNpZ1swXS5zaWduYXR1cmUsIHNjcmlwdCwgY29udHJvbEJsb2NrXTtcbiAgICBjb25zdCB3aXRuZXNzTGVuZ3RoID0gd2l0bmVzcy5yZWR1Y2UoKHMsIGIpID0+IHMgKyBiLmxlbmd0aCArIHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoYi5sZW5ndGgpLCAxKTtcblxuICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkod2l0bmVzc0xlbmd0aCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVmVjdG9yKHdpdG5lc3MpO1xuICAgIGNvbnN0IGZpbmFsU2NyaXB0V2l0bmVzcyA9IGJ1ZmZlcldyaXRlci5lbmQoKTtcblxuICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IGZpbmFsU2NyaXB0V2l0bmVzcyB9KTtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vc3RseSBjb3BpZWQgZnJvbSBiaXRjb2luanMtbGliL3RzX3NyYy9wc2J0LnRzXG4gICAqXG4gICAqIFVubGlrZSB0aGUgZnVuY3Rpb24gaXQgb3ZlcnJpZGVzLCB0aGlzIGRvZXMgbm90IHRha2UgYSB2YWxpZGF0b3IuIEluIEJpdEdvXG4gICAqIGNvbnRleHQsIHdlIGtub3cgaG93IHdlIHdhbnQgdG8gdmFsaWRhdGUgc28gd2UganVzdCBoYXJkIGNvZGUgdGhlIHJpZ2h0XG4gICAqIHZhbGlkYXRvci5cbiAgICovXG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mQWxsSW5wdXRzKCk6IGJvb2xlYW4ge1xuICAgIGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZGF0YS5pbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0Q29tbW9uKGlkeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChmaW5hbCwgcmVzKSA9PiByZXMgJiYgZmluYWwsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWZmIGFueSBtYXRjaGluZyB2YWxpZCBzaWduYXR1cmUgaXMgZm91bmQgZm9yIGEgZGVyaXZlZCBwdWIga2V5IGZyb20gZ2l2ZW4gSEQga2V5IHBhaXIuXG4gICAqL1xuICB2YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0SEQoaW5wdXRJbmRleDogbnVtYmVyLCBoZEtleVBhaXI6IEJJUDMySW50ZXJmYWNlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGNvbnN0IHB1YktleSA9IFV0eG9Qc2J0LmRlcml2ZUtleVBhaXJGb3JJbnB1dChoZEtleVBhaXIsIGlucHV0KTtcbiAgICBpZiAoIXB1YktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW4gbm90IGRlcml2ZSBmcm9tIEhEIGtleSBwYWlyJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXRDb21tb24oaW5wdXRJbmRleCwgcHViS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmZiBhbnkgdmFsaWQgc2lnbmF0dXJlKHMpIGFyZSBmb3VuZCBmcm9tIGJpcDMyIGRhdGEgb2YgUFNCVCBvciBmb3IgZ2l2ZW4gcHViIGtleS5cbiAgICovXG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXRDb21tb24oaW5wdXRJbmRleDogbnVtYmVyLCBwdWJrZXk/OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuaXNUYXByb290U2NyaXB0UGF0aElucHV0KGlucHV0SW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVGFwcm9vdFNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXgsIHB1YmtleSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUYXByb290S2V5UGF0aElucHV0KGlucHV0SW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVGFwcm9vdE11c2lnMlNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXgsIHB1YmtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXgsIChwLCBtLCBzKSA9PiBlY2NMaWIudmVyaWZ5KG0sIHAsIHMsIHRydWUpLCBwdWJrZXkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gTm90IGFuIGVsZWdhbnQgc29sdXRpb24uIE1pZ2h0IG5lZWQgdXBzdHJlYW0gY2hhbmdlcyBsaWtlIGN1c3RvbSBlcnJvciB0eXBlcy5cbiAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ05vIHNpZ25hdHVyZXMgZm9yIHRoaXMgcHVia2V5Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNdXNpZzJTZXNzaW9uS2V5KFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBzaWdIYXNoVHlwZTogbnVtYmVyXG4gICk6IHtcbiAgICBwYXJ0aWNpcGFudHM6IFBzYnRNdXNpZzJQYXJ0aWNpcGFudHM7XG4gICAgbm9uY2VzOiBUdXBsZTxQc2J0TXVzaWcyUHViTm9uY2U+O1xuICAgIGhhc2g6IEJ1ZmZlcjtcbiAgICBzZXNzaW9uS2V5OiBTZXNzaW9uS2V5O1xuICB9IHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCFpbnB1dC50YXBJbnRlcm5hbEtleSB8fCAhaW5wdXQudGFwTWVya2xlUm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIHRhcEludGVybmFsS2V5IGFuZCB0YXBNZXJrbGVSb290IGFyZSByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHRoaXMuZ2V0TXVzaWcyUGFydGljaXBhbnRzKGlucHV0SW5kZXgsIGlucHV0LnRhcEludGVybmFsS2V5LCBpbnB1dC50YXBNZXJrbGVSb290KTtcbiAgICBjb25zdCBub25jZXMgPSB0aGlzLmdldE11c2lnMk5vbmNlcyhpbnB1dEluZGV4LCBwYXJ0aWNpcGFudHMpO1xuXG4gICAgY29uc3QgeyBoYXNoIH0gPSB0aGlzLmdldFRhcHJvb3RIYXNoRm9yU2lnKGlucHV0SW5kZXgsIFtzaWdIYXNoVHlwZV0pO1xuXG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IGNyZWF0ZU11c2lnMlNpZ25pbmdTZXNzaW9uKHtcbiAgICAgIHB1Yk5vbmNlczogW25vbmNlc1swXS5wdWJOb25jZSwgbm9uY2VzWzFdLnB1Yk5vbmNlXSxcbiAgICAgIHB1YktleXM6IHBhcnRpY2lwYW50cy5wYXJ0aWNpcGFudFB1YktleXMsXG4gICAgICB0eEhhc2g6IGhhc2gsXG4gICAgICBpbnRlcm5hbFB1YktleTogaW5wdXQudGFwSW50ZXJuYWxLZXksXG4gICAgICB0YXBUcmVlUm9vdDogaW5wdXQudGFwTWVya2xlUm9vdCxcbiAgICB9KTtcbiAgICByZXR1cm4geyBwYXJ0aWNpcGFudHMsIG5vbmNlcywgaGFzaCwgc2Vzc2lvbktleSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgZm9yIGZvbGxvd2luZyBjYXNlcy5cbiAgICogSWYgdmFsaWQgbXVzaWcyIHBhcnRpYWwgc2lnbmF0dXJlcyBleGlzdHMgZm9yIGJvdGggMiBrZXlzLCBpdCB3aWxsIGFsc28gdmVyaWZ5IGFnZ3JlZ2F0ZWQgc2lnXG4gICAqIGZvciBhZ2dyZWdhdGVkIHR3ZWFrZWQga2V5IChvdXRwdXQga2V5KSwgb3RoZXJ3aXNlIG9ubHkgdmVyaWZpZXMgcGFydGlhbCBzaWcuXG4gICAqIElmIHB1YmtleSBpcyBwYXNzZWQgaW4gaW5wdXQsIGl0IHdpbGwgY2hlY2sgc2lnIG9ubHkgZm9yIHRoYXQgcHVia2V5LFxuICAgKiBpZiBubyBzaWcgZXhpdHMgZm9yIHN1Y2gga2V5LCB0aHJvd3MgZXJyb3IuXG4gICAqIEZvciBpbnZhbGlkIHN0YXRlIG9mIGlucHV0IGRhdGEsIGl0IHdpbGwgdGhyb3cgZXJyb3JzLlxuICAgKi9cbiAgdmFsaWRhdGVUYXByb290TXVzaWcyU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleDogbnVtYmVyLCBwdWJrZXk/OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3QgcGFydGlhbFNpZ3MgPSBwYXJzZVBzYnRNdXNpZzJQYXJ0aWFsU2lncyhpbnB1dCk7XG4gICAgaWYgKCFwYXJ0aWFsU2lncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzaWduYXR1cmVzIHRvIHZhbGlkYXRlYCk7XG4gICAgfVxuXG4gICAgbGV0IG15UGFydGlhbFNpZ3MgPSBwYXJ0aWFsU2lncztcbiAgICBpZiAocHVia2V5KSB7XG4gICAgICBteVBhcnRpYWxTaWdzID0gcGFydGlhbFNpZ3MuZmlsdGVyKChrdikgPT4gZXF1YWxQdWJsaWNLZXlJZ25vcmVZKGt2LnBhcnRpY2lwYW50UHViS2V5LCBwdWJrZXkpKTtcbiAgICAgIGlmIChteVBhcnRpYWxTaWdzPy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHBhcnRpYWxTaWdzOiBteVNpZ3MsIHNpZ0hhc2hUeXBlIH0gPSBnZXRTaWdIYXNoVHlwZUZyb21TaWdzKG15UGFydGlhbFNpZ3MpO1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnRzLCBub25jZXMsIGhhc2gsIHNlc3Npb25LZXkgfSA9IHRoaXMuZ2V0TXVzaWcyU2Vzc2lvbktleShpbnB1dEluZGV4LCBzaWdIYXNoVHlwZSk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gbXlTaWdzLm1hcCgobXlTaWcpID0+IHtcbiAgICAgIGNvbnN0IG15Tm9uY2UgPSBub25jZXMuZmluZCgoa3YpID0+IGVxdWFsUHVibGljS2V5SWdub3JlWShrdi5wYXJ0aWNpcGFudFB1YktleSwgbXlTaWcucGFydGljaXBhbnRQdWJLZXkpKTtcbiAgICAgIGlmICghbXlOb25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIG5vIHB1YiBub25jZSBmb3IgcHVia2V5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXVzaWcyUGFydGlhbFNpZ1ZlcmlmeShteVNpZy5wYXJ0aWFsU2lnLCBteVNpZy5wYXJ0aWNpcGFudFB1YktleSwgbXlOb25jZS5wdWJOb25jZSwgc2Vzc2lvbktleSk7XG4gICAgfSk7XG5cbiAgICAvLyBGb3IgdmFsaWQgc2luZ2xlIHNpZyBvciAxIG9yIDIgZmFpbHVyZSBzaWdzLCBubyBuZWVkIHRvIHZhbGlkYXRlIGFnZ3JlZ2F0ZWQgc2lnLiBTbyBza2lwLlxuICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHMuZXZlcnkoKHJlcykgPT4gcmVzKTtcbiAgICBpZiAoIXJlc3VsdCB8fCBteVNpZ3MubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBhZ2dTaWcgPSBtdXNpZzJBZ2dyZWdhdGVTaWdzKFxuICAgICAgbXlTaWdzLm1hcCgobXlTaWcpID0+IG15U2lnLnBhcnRpYWxTaWcpLFxuICAgICAgc2Vzc2lvbktleVxuICAgICk7XG5cbiAgICByZXR1cm4gZWNjTGliLnZlcmlmeVNjaG5vcnIoaGFzaCwgcGFydGljaXBhbnRzLnRhcE91dHB1dEtleSwgYWdnU2lnKTtcbiAgfVxuXG4gIHZhbGlkYXRlVGFwcm9vdFNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXg6IG51bWJlciwgcHVia2V5PzogQnVmZmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGNvbnN0IHRhcFNpZ3MgPSAoaW5wdXQgfHwge30pLnRhcFNjcmlwdFNpZztcbiAgICBpZiAoIWlucHV0IHx8ICF0YXBTaWdzIHx8IHRhcFNpZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduYXR1cmVzIHRvIHZhbGlkYXRlJyk7XG4gICAgfVxuICAgIGxldCBteVNpZ3M7XG4gICAgaWYgKHB1YmtleSkge1xuICAgICAgbXlTaWdzID0gdGFwU2lncy5maWx0ZXIoKHNpZykgPT4gZXF1YWxQdWJsaWNLZXlJZ25vcmVZKHNpZy5wdWJrZXksIHB1YmtleSkpO1xuICAgICAgaWYgKG15U2lncy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbXlTaWdzID0gdGFwU2lncztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0czogYm9vbGVhbltdID0gW107XG5cbiAgICBhc3NlcnQoaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoID09PSAxLCBgc2luZ2xlIHRhcExlYWZTY3JpcHQgaXMgZXhwZWN0ZWQuIEdvdCAke2lucHV0LnRhcExlYWZTY3JpcHQ/Lmxlbmd0aH1gKTtcbiAgICBjb25zdCBbdGFwTGVhZlNjcmlwdF0gPSBpbnB1dC50YXBMZWFmU2NyaXB0O1xuICAgIGNvbnN0IHB1YktleXMgPSB0aGlzLmlzTXVsdGlzaWdUYXByb290U2NyaXB0KHRhcExlYWZTY3JpcHQuc2NyaXB0KVxuICAgICAgPyBwYXJzZVB1YlNjcmlwdDJPZjModGFwTGVhZlNjcmlwdC5zY3JpcHQsICd0YXByb290U2NyaXB0UGF0aFNwZW5kJykucHVibGljS2V5c1xuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBmb3IgKGNvbnN0IHBTaWcgb2YgbXlTaWdzKSB7XG4gICAgICBjb25zdCB7IHNpZ25hdHVyZSwgbGVhZkhhc2gsIHB1YmtleSB9ID0gcFNpZztcbiAgICAgIGlmIChwdWJLZXlzKSB7XG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICBwdWJLZXlzLmZpbmQoKHBrKSA9PiBwdWJrZXkuZXF1YWxzKHBrKSksXG4gICAgICAgICAgJ3B1YmxpYyBrZXkgbm90IGZvdW5kIGluIHRhcCBsZWFmIHNjcmlwdCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxldCBzaWdIYXNoVHlwZTogbnVtYmVyO1xuICAgICAgbGV0IHNpZzogQnVmZmVyO1xuICAgICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgIHNpZ0hhc2hUeXBlID0gc2lnbmF0dXJlWzY0XTtcbiAgICAgICAgc2lnID0gc2lnbmF0dXJlLnNsaWNlKDAsIDY0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ0hhc2hUeXBlID0gVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUO1xuICAgICAgICBzaWcgPSBzaWduYXR1cmU7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGhhc2ggfSA9IHRoaXMuZ2V0VGFwcm9vdEhhc2hGb3JTaWcoaW5wdXRJbmRleCwgW3NpZ0hhc2hUeXBlXSwgbGVhZkhhc2gpO1xuICAgICAgcmVzdWx0cy5wdXNoKGVjY0xpYi52ZXJpZnlTY2hub3JyKGhhc2gsIHB1YmtleSwgc2lnKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KChyZXMpID0+IHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGlucHV0SW5kZXhcbiAgICogQHBhcmFtIHJvb3ROb2RlcyBvcHRpb25hbCBpbnB1dCByb290IGJpcDMyIG5vZGVzIHRvIHZlcmlmeSB3aXRoLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIGdsb2JhbFhwdWIgd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzLiBUcnVlIHdoZW4gY29ycmVzcG9uZGluZyBpbmRleCBpbiBgcHVibGljS2V5c2AgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIElmIG5vIHNpZ25hdHVyZSBpbiB0aGUgdHggb3Igbm8gcHVibGljIGtleSBtYXRjaGluZyBzaWduYXR1cmUsIHRoZSB2YWxpZGF0aW9uIGlzIGNvbnNpZGVyZWQgYXMgZmFsc2UuXG4gICAqL1xuICBnZXRTaWduYXR1cmVWYWxpZGF0aW9uQXJyYXkoXG4gICAgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIHsgcm9vdE5vZGVzIH06IHsgcm9vdE5vZGVzPzogVHJpcGxlPEJJUDMySW50ZXJmYWNlPiB9ID0ge31cbiAgKTogVHJpcGxlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXJvb3ROb2RlcyAmJiAoIXRoaXMuZGF0YS5nbG9iYWxNYXAuZ2xvYmFsWHB1Yj8ubGVuZ3RoIHx8ICFpc1RyaXBsZSh0aGlzLmRhdGEuZ2xvYmFsTWFwLmdsb2JhbFhwdWIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IHNpZ25hdHVyZSB2YWxpZGF0aW9uIGFycmF5IHdpdGhvdXQgMyBnbG9iYWwgeHB1YnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXAzMnMgPSByb290Tm9kZXNcbiAgICAgID8gcm9vdE5vZGVzXG4gICAgICA6IHRoaXMuZGF0YS5nbG9iYWxNYXAuZ2xvYmFsWHB1Yj8ubWFwKCh4cHViKSA9PlxuICAgICAgICAgIEJJUDMyRmFjdG9yeShlY2NMaWIpLmZyb21CYXNlNTgoYnM1OGNoZWNrLmVuY29kZSh4cHViLmV4dGVuZGVkUHVia2V5KSlcbiAgICAgICAgKTtcblxuICAgIGlmICghYmlwMzJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBnbG9iYWxNYXAgb3Igcm9vdE5vZGVzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmICghZ2V0UHNidElucHV0U2lnbmF0dXJlQ291bnQoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICAgIH1cblxuICAgIHJldHVybiBiaXAzMnMubWFwKChiaXAzMikgPT4ge1xuICAgICAgY29uc3QgcHViS2V5ID0gVXR4b1BzYnQuZGVyaXZlS2V5UGFpckZvcklucHV0KGJpcDMyLCBpbnB1dCk7XG4gICAgICBpZiAoIXB1YktleSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0Q29tbW9uKGlucHV0SW5kZXgsIHB1YktleSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gTm90IGFuIGVsZWdhbnQgc29sdXRpb24uIE1pZ2h0IG5lZWQgdXBzdHJlYW0gY2hhbmdlcyBsaWtlIGN1c3RvbSBlcnJvciB0eXBlcy5cbiAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSAnTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KSBhcyBUcmlwbGU8Ym9vbGVhbj47XG4gIH1cblxuICAvKipcbiAgICogTW9zdGx5IGNvcGllZCBmcm9tIGJpdGNvaW5qcy1saWIvdHNfc3JjL3BzYnQudHNcbiAgICovXG4gIHNpZ25BbGxJbnB1dHNIRChcbiAgICBoZEtleVBhaXI6IEhEVGFwcm9vdFNpZ25lciB8IEhEVGFwcm9vdE11c2lnMlNpZ25lcixcbiAgICBwYXJhbXM/OiBudW1iZXJbXSB8IFBhcnRpYWw8U2lnbmF0dXJlUGFyYW1zPlxuICApOiB0aGlzIHtcbiAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCB7IHNpZ2hhc2hUeXBlcywgZGV0ZXJtaW5pc3RpYyB9ID0gdG9TaWduYXR1cmVQYXJhbXModGhpcy5uZXR3b3JrLCBwYXJhbXMpO1xuXG4gICAgY29uc3QgcmVzdWx0czogYm9vbGVhbltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNpZ25JbnB1dEhEKGksIGhkS2V5UGFpciwgeyBzaWdoYXNoVHlwZXMsIGRldGVybWluaXN0aWMgfSk7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0cy5ldmVyeSgodikgPT4gIXYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3N0bHkgY29waWVkIGZyb20gYml0Y29pbmpzLWxpYi90c19zcmMvcHNidC50czpzaWduSW5wdXRIRFxuICAgKi9cbiAgc2lnblRhcHJvb3RJbnB1dEhEKFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBoZEtleVBhaXI6IEhEVGFwcm9vdFNpZ25lciB8IEhEVGFwcm9vdE11c2lnMlNpZ25lcixcbiAgICB7IHNpZ2hhc2hUeXBlcyA9IFtUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQsIFRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSwgZGV0ZXJtaW5pc3RpYyA9IGZhbHNlIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBpZiAoIXRoaXMuaXNUYXByb290SW5wdXQoaW5wdXRJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgdGFwcm9vdCBpbnB1dCcpO1xuICAgIH1cbiAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCFpbnB1dC50YXBCaXAzMkRlcml2YXRpb24gfHwgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIHRhcEJpcDMyRGVyaXZhdGlvbiB0byBzaWduIFRhcHJvb3Qgd2l0aCBIRCcpO1xuICAgIH1cbiAgICBjb25zdCBteURlcml2YXRpb25zID0gaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uXG4gICAgICAubWFwKChiaXBEdikgPT4ge1xuICAgICAgICBpZiAoYmlwRHYubWFzdGVyRmluZ2VycHJpbnQuZXF1YWxzKGhkS2V5UGFpci5maW5nZXJwcmludCkpIHtcbiAgICAgICAgICByZXR1cm4gYmlwRHY7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2KSA9PiAhIXYpIGFzIFRhcEJpcDMyRGVyaXZhdGlvbltdO1xuICAgIGlmIChteURlcml2YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIG9uZSB0YXBCaXAzMkRlcml2YXRpb24gbWFzdGVyRmluZ2VycHJpbnQgdG8gbWF0Y2ggdGhlIEhEU2lnbmVyIGZpbmdlcnByaW50Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVyaXZlZE5vZGUoYmlwRHY6IFRhcEJpcDMyRGVyaXZhdGlvbik6IEhEVGFwcm9vdE11c2lnMlNpZ25lciB8IEhEVGFwcm9vdFNpZ25lciB7XG4gICAgICBjb25zdCBub2RlID0gaGRLZXlQYWlyLmRlcml2ZVBhdGgoYmlwRHYucGF0aCk7XG4gICAgICBpZiAoIWVxdWFsUHVibGljS2V5SWdub3JlWShiaXBEdi5wdWJrZXksIG5vZGUucHVibGljS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YmtleSBkaWQgbm90IG1hdGNoIHRhcEJpcDMyRGVyaXZhdGlvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LnRhcExlYWZTY3JpcHQ/Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc2lnbmVyczogVGFwcm9vdFNpZ25lcltdID0gbXlEZXJpdmF0aW9ucy5tYXAoKGJpcER2KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGdldERlcml2ZWROb2RlKGJpcER2KTtcbiAgICAgICAgaWYgKCEoJ3NpZ25TY2hub3JyJyBpbiBzaWduZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduU2Nobm9yciBmdW5jdGlvbiBpcyByZXF1aXJlZCB0byBzaWduIHAydHInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzaWduZXIsIGxlYWZIYXNoZXM6IGJpcER2LmxlYWZIYXNoZXMgfTtcbiAgICAgIH0pO1xuICAgICAgc2lnbmVycy5mb3JFYWNoKCh7IHNpZ25lciwgbGVhZkhhc2hlcyB9KSA9PiB0aGlzLnNpZ25UYXByb290SW5wdXQoaW5wdXRJbmRleCwgc2lnbmVyLCBsZWFmSGFzaGVzLCBzaWdoYXNoVHlwZXMpKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LnRhcEludGVybmFsS2V5Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNpZ25lcnM6IE11c2lnMlNpZ25lcltdID0gbXlEZXJpdmF0aW9ucy5tYXAoKGJpcER2KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGdldERlcml2ZWROb2RlKGJpcER2KTtcbiAgICAgICAgaWYgKCEoJ3ByaXZhdGVLZXknIGluIHNpZ25lcikgfHwgIXNpZ25lci5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlS2V5IGlzIHJlcXVpcmVkIHRvIHNpZ24gcDJ0ciBtdXNpZzInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmVyO1xuICAgICAgfSk7XG4gICAgICBzaWduZXJzLmZvckVhY2goKHNpZ25lcikgPT4gdGhpcy5zaWduVGFwcm9vdE11c2lnMklucHV0KGlucHV0SW5kZXgsIHNpZ25lciwgeyBzaWdoYXNoVHlwZXMsIGRldGVybWluaXN0aWMgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNpZ25JbnB1dEhEKFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBoZEtleVBhaXI6IEhEVGFwcm9vdFNpZ25lciB8IEhEVGFwcm9vdE11c2lnMlNpZ25lcixcbiAgICBwYXJhbXM/OiBudW1iZXJbXSB8IFBhcnRpYWw8U2lnbmF0dXJlUGFyYW1zPlxuICApOiB0aGlzIHtcbiAgICBjb25zdCB7IHNpZ2hhc2hUeXBlcywgZGV0ZXJtaW5pc3RpYyB9ID0gdG9TaWduYXR1cmVQYXJhbXModGhpcy5uZXR3b3JrLCBwYXJhbXMpO1xuICAgIGlmICh0aGlzLmlzVGFwcm9vdElucHV0KGlucHV0SW5kZXgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduVGFwcm9vdElucHV0SEQoaW5wdXRJbmRleCwgaGRLZXlQYWlyLCB7IHNpZ2hhc2hUeXBlcywgZGV0ZXJtaW5pc3RpYyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnNpZ25JbnB1dEhEKGlucHV0SW5kZXgsIGhkS2V5UGFpciwgc2lnaGFzaFR5cGVzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE11c2lnMlBhcnRpY2lwYW50cyhpbnB1dEluZGV4OiBudW1iZXIsIHRhcEludGVybmFsS2V5OiBCdWZmZXIsIHRhcE1lcmtsZVJvb3Q6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBhcnRpY2lwYW50c0tleVZhbERhdGEgPSBwYXJzZVBzYnRNdXNpZzJQYXJ0aWNpcGFudHModGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XSk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudHNLZXlWYWxEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIDAgbWF0Y2hpbmcgcGFydGljaXBhbnQga2V5IHZhbHVlIGluc3RlYWQgb2YgMWApO1xuICAgIH1cbiAgICBhc3NlcnRQc2J0TXVzaWcyUGFydGljaXBhbnRzKHBhcnRpY2lwYW50c0tleVZhbERhdGEsIHRhcEludGVybmFsS2V5LCB0YXBNZXJrbGVSb290KTtcbiAgICByZXR1cm4gcGFydGljaXBhbnRzS2V5VmFsRGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TXVzaWcyTm9uY2VzKGlucHV0SW5kZXg6IG51bWJlciwgcGFydGljaXBhbnRzS2V5VmFsRGF0YTogUHNidE11c2lnMlBhcnRpY2lwYW50cykge1xuICAgIGNvbnN0IG5vbmNlc0tleVZhbHNEYXRhID0gcGFyc2VQc2J0TXVzaWcyTm9uY2VzKHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF0pO1xuICAgIGlmICghbm9uY2VzS2V5VmFsc0RhdGEgfHwgIWlzVHVwbGUobm9uY2VzS2V5VmFsc0RhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGb3VuZCAke25vbmNlc0tleVZhbHNEYXRhPy5sZW5ndGggPyBub25jZXNLZXlWYWxzRGF0YS5sZW5ndGggOiAwfSBtYXRjaGluZyBub25jZSBrZXkgdmFsdWUgaW5zdGVhZCBvZiAyYFxuICAgICAgKTtcbiAgICB9XG4gICAgYXNzZXJ0UHNidE11c2lnMk5vbmNlcyhub25jZXNLZXlWYWxzRGF0YSwgcGFydGljaXBhbnRzS2V5VmFsRGF0YSk7XG4gICAgcmV0dXJuIG5vbmNlc0tleVZhbHNEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIHAydHIgbXVzaWcyIGtleSBwYXRoIGlucHV0IHdpdGggMiBhZ2dyZWdhdGVkIGtleXMuXG4gICAqXG4gICAqIE5vdGU6IE9ubHkgY2FuIHNpZ24gZGV0ZXJtaW5pc3RpY2FsbHkgYXMgdGhlIGNvc2lnbmVyXG4gICAqIEBwYXJhbSBpbnB1dEluZGV4XG4gICAqIEBwYXJhbSBzaWduZXIgLSBYWSBwdWJsaWMga2V5IGFuZCBwcml2YXRlIGtleSBhcmUgcmVxdWlyZWRcbiAgICogQHBhcmFtIHNpZ2hhc2hUeXBlc1xuICAgKiBAcGFyYW0gZGV0ZXJtaW5pc3RpYyBJZiB0cnVlLCBzaWduIHRoZSBtdXNpZyBpbnB1dCBkZXRlcm1pbmlzdGljYWxseVxuICAgKi9cbiAgc2lnblRhcHJvb3RNdXNpZzJJbnB1dChcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAgc2lnbmVyOiBNdXNpZzJTaWduZXIsXG4gICAgeyBzaWdoYXNoVHlwZXMgPSBbVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxULCBUcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sIGRldGVybWluaXN0aWMgPSBmYWxzZSB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgaWYgKCF0aGlzLmlzVGFwcm9vdEtleVBhdGhJbnB1dChpbnB1dEluZGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSB0YXByb290IG11c2lnMiBpbnB1dCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XTtcblxuICAgIGlmICghaW5wdXQudGFwSW50ZXJuYWxLZXkgfHwgIWlucHV0LnRhcE1lcmtsZVJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBpbnB1dCBkYXRhJyk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYW5kIGNoZWNrIHRoYXQgd2UgaGF2ZSB0d28gcGFydGljaXBhbnQgbm9uY2VzXG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gdGhpcy5nZXRNdXNpZzJQYXJ0aWNpcGFudHMoaW5wdXRJbmRleCwgaW5wdXQudGFwSW50ZXJuYWxLZXksIGlucHV0LnRhcE1lcmtsZVJvb3QpO1xuICAgIGNvbnN0IHsgdGFwT3V0cHV0S2V5LCBwYXJ0aWNpcGFudFB1YktleXMgfSA9IHBhcnRpY2lwYW50cztcbiAgICBjb25zdCBzaWduZXJQdWJLZXkgPSBwYXJ0aWNpcGFudFB1YktleXMuZmluZCgocHViS2V5KSA9PiBlcXVhbFB1YmxpY0tleUlnbm9yZVkocHViS2V5LCBzaWduZXIucHVibGljS2V5KSk7XG4gICAgaWYgKCFzaWduZXJQdWJLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVyIHB1YiBrZXkgc2hvdWxkIG1hdGNoIG9uZSBvZiBwYXJ0aWNpcGFudCBwdWIga2V5cycpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vbmNlcyA9IHRoaXMuZ2V0TXVzaWcyTm9uY2VzKGlucHV0SW5kZXgsIHBhcnRpY2lwYW50cyk7XG4gICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gdGhpcy5nZXRUYXByb290SGFzaEZvclNpZyhpbnB1dEluZGV4LCBzaWdoYXNoVHlwZXMpO1xuXG4gICAgbGV0IHBhcnRpYWxTaWc6IEJ1ZmZlcjtcbiAgICBpZiAoZGV0ZXJtaW5pc3RpYykge1xuICAgICAgaWYgKCFlcXVhbFB1YmxpY0tleUlnbm9yZVkoc2lnbmVyUHViS2V5LCBwYXJ0aWNpcGFudFB1YktleXNbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuIG9ubHkgYWRkIGEgZGV0ZXJtaW5pc3RpYyBzaWduYXR1cmUgb24gdGhlIGNvc2lnbmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0U2lnbmVyTm9uY2UgPSBub25jZXMuZmluZCgobikgPT4gZXF1YWxQdWJsaWNLZXlJZ25vcmVZKG4ucGFydGljaXBhbnRQdWJLZXksIHBhcnRpY2lwYW50UHViS2V5c1swXSkpO1xuICAgICAgaWYgKCFmaXJzdFNpZ25lck5vbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGZpbmQgdGhlIHVzZXIgbm9uY2UnKTtcbiAgICAgIH1cblxuICAgICAgcGFydGlhbFNpZyA9IG11c2lnMkRldGVybWluaXN0aWNTaWduKHtcbiAgICAgICAgcHJpdmF0ZUtleTogc2lnbmVyLnByaXZhdGVLZXksXG4gICAgICAgIG90aGVyTm9uY2U6IGZpcnN0U2lnbmVyTm9uY2UucHViTm9uY2UsXG4gICAgICAgIHB1YmxpY0tleXM6IHBhcnRpY2lwYW50UHViS2V5cyxcbiAgICAgICAgaW50ZXJuYWxQdWJLZXk6IGlucHV0LnRhcEludGVybmFsS2V5LFxuICAgICAgICB0YXBUcmVlUm9vdDogaW5wdXQudGFwTWVya2xlUm9vdCxcbiAgICAgICAgaGFzaCxcbiAgICAgIH0pLnNpZztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IGNyZWF0ZU11c2lnMlNpZ25pbmdTZXNzaW9uKHtcbiAgICAgICAgcHViTm9uY2VzOiBbbm9uY2VzWzBdLnB1Yk5vbmNlLCBub25jZXNbMV0ucHViTm9uY2VdLFxuICAgICAgICBwdWJLZXlzOiBwYXJ0aWNpcGFudFB1YktleXMsXG4gICAgICAgIHR4SGFzaDogaGFzaCxcbiAgICAgICAgaW50ZXJuYWxQdWJLZXk6IGlucHV0LnRhcEludGVybmFsS2V5LFxuICAgICAgICB0YXBUcmVlUm9vdDogaW5wdXQudGFwTWVya2xlUm9vdCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzaWduZXJOb25jZSA9IG5vbmNlcy5maW5kKChrdikgPT4gZXF1YWxQdWJsaWNLZXlJZ25vcmVZKGt2LnBhcnRpY2lwYW50UHViS2V5LCBzaWduZXJQdWJLZXkpKTtcbiAgICAgIGlmICghc2lnbmVyTm9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJOb25jZSBpcyBtaXNzaW5nLiByZXRyeSBzaWduaW5nIHByb2Nlc3MnKTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxTaWcgPSBtdXNpZzJQYXJ0aWFsU2lnbihzaWduZXIucHJpdmF0ZUtleSwgc2lnbmVyTm9uY2UucHViTm9uY2UsIHNlc3Npb25LZXksIHRoaXMubm9uY2VTdG9yZSk7XG4gICAgfVxuXG4gICAgaWYgKHNpZ2hhc2hUeXBlICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQpIHtcbiAgICAgIHBhcnRpYWxTaWcgPSBCdWZmZXIuY29uY2F0KFtwYXJ0aWFsU2lnLCBCdWZmZXIub2Yoc2lnaGFzaFR5cGUpXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnID0gZW5jb2RlUHNidE11c2lnMlBhcnRpYWxTaWcoe1xuICAgICAgcGFydGljaXBhbnRQdWJLZXk6IHNpZ25lclB1YktleSxcbiAgICAgIHRhcE91dHB1dEtleSxcbiAgICAgIHBhcnRpYWxTaWc6IHBhcnRpYWxTaWcsXG4gICAgfSk7XG4gICAgdGhpcy5hZGRQcm9wcmlldGFyeUtleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwgc2lnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNpZ25UYXByb290SW5wdXQoXG4gICAgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIHNpZ25lcjogU2Nobm9yclNpZ25lcixcbiAgICBsZWFmSGFzaGVzOiBCdWZmZXJbXSxcbiAgICBzaWdoYXNoVHlwZXM6IG51bWJlcltdID0gW1RyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCwgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdXG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAvLyBGaWd1cmUgb3V0IGlmIHRoaXMgaXMgc2NyaXB0IHBhdGggb3Igbm90LCBpZiBub3QsIHR3ZWFrIHRoZSBwcml2YXRlIGtleVxuICAgIGlmICghaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcExlYWZTY3JpcHQgaXMgcmVxdWlyZWQgZm9yIHAydHIgc2NyaXB0IHBhdGgnKTtcbiAgICB9XG4gICAgY29uc3QgcHVia2V5ID0gdG9YT25seVB1YmxpY0tleShzaWduZXIucHVibGljS2V5KTtcbiAgICBpZiAoaW5wdXQudGFwTGVhZlNjcmlwdC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgbGVhZiBzY3JpcHQgc3VwcG9ydGVkIGZvciBzaWduaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IFt0YXBMZWFmU2NyaXB0XSA9IGlucHV0LnRhcExlYWZTY3JpcHQ7XG5cbiAgICBpZiAodGhpcy5pc011bHRpc2lnVGFwcm9vdFNjcmlwdCh0YXBMZWFmU2NyaXB0LnNjcmlwdCkpIHtcbiAgICAgIGNvbnN0IHB1YktleXMgPSBwYXJzZVB1YlNjcmlwdDJPZjModGFwTGVhZlNjcmlwdC5zY3JpcHQsICd0YXByb290U2NyaXB0UGF0aFNwZW5kJykucHVibGljS2V5cztcbiAgICAgIGFzc2VydChcbiAgICAgICAgcHViS2V5cy5maW5kKChwaykgPT4gcHVia2V5LmVxdWFscyhwaykpLFxuICAgICAgICAncHVibGljIGtleSBub3QgZm91bmQgaW4gdGFwIGxlYWYgc2NyaXB0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRDb250cm9sQmxvY2sgPSB0YXByb290LnBhcnNlQ29udHJvbEJsb2NrKGVjY0xpYiwgdGFwTGVhZlNjcmlwdC5jb250cm9sQmxvY2spO1xuICAgIGNvbnN0IHsgbGVhZlZlcnNpb24gfSA9IHBhcnNlZENvbnRyb2xCbG9jaztcbiAgICBpZiAobGVhZlZlcnNpb24gIT09IHRhcExlYWZTY3JpcHQubGVhZlZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGFwIHNjcmlwdCBsZWFmIHZlcnNpb24gbWlzbWF0Y2ggd2l0aCBjb250cm9sIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlYWZIYXNoID0gdGFwcm9vdC5nZXRUYXBsZWFmSGFzaChlY2NMaWIsIHBhcnNlZENvbnRyb2xCbG9jaywgdGFwTGVhZlNjcmlwdC5zY3JpcHQpO1xuICAgIGlmICghbGVhZkhhc2hlcy5maW5kKChsKSA9PiBsLmVxdWFscyhsZWFmSGFzaCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25lciBjYW5ub3Qgc2lnbiBmb3IgbGVhZiBoYXNoICR7bGVhZkhhc2gudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgIH1cbiAgICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlIH0gPSB0aGlzLmdldFRhcHJvb3RIYXNoRm9yU2lnKGlucHV0SW5kZXgsIHNpZ2hhc2hUeXBlcywgbGVhZkhhc2gpO1xuICAgIGxldCBzaWduYXR1cmUgPSBzaWduZXIuc2lnblNjaG5vcnIoaGFzaCk7XG4gICAgaWYgKHNpZ2hhc2hUeXBlICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQpIHtcbiAgICAgIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW3NpZ25hdHVyZSwgQnVmZmVyLm9mKHNpZ2hhc2hUeXBlKV0pO1xuICAgIH1cbiAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwge1xuICAgICAgdGFwU2NyaXB0U2lnOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgIGxlYWZIYXNoLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VGFwcm9vdE91dHB1dFNjcmlwdChpbnB1dEluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKGlucHV0LnRhcExlYWZTY3JpcHQ/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRhcHJvb3QuY3JlYXRlVGFwcm9vdE91dHB1dFNjcmlwdCh7XG4gICAgICAgIGNvbnRyb2xCbG9jazogaW5wdXQudGFwTGVhZlNjcmlwdFswXS5jb250cm9sQmxvY2ssXG4gICAgICAgIGxlYWZTY3JpcHQ6IGlucHV0LnRhcExlYWZTY3JpcHRbMF0uc2NyaXB0LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC50YXBJbnRlcm5hbEtleSAmJiBpbnB1dC50YXBNZXJrbGVSb290KSB7XG4gICAgICByZXR1cm4gdGFwcm9vdC5jcmVhdGVUYXByb290T3V0cHV0U2NyaXB0KHtcbiAgICAgICAgaW50ZXJuYWxQdWJLZXk6IGlucHV0LnRhcEludGVybmFsS2V5LFxuICAgICAgICB0YXB0cmVlUm9vdDogaW5wdXQudGFwTWVya2xlUm9vdCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHRhcHJvb3QgaW5wdXQnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VGFwcm9vdEhhc2hGb3JTaWcoXG4gICAgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIHNpZ2hhc2hUeXBlcz86IG51bWJlcltdLFxuICAgIGxlYWZIYXNoPzogQnVmZmVyXG4gICk6IHtcbiAgICBoYXNoOiBCdWZmZXI7XG4gICAgc2lnaGFzaFR5cGU6IG51bWJlcjtcbiAgfSB7XG4gICAgaWYgKCF0aGlzLmlzVGFwcm9vdElucHV0KGlucHV0SW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHRhcHJvb3QgaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnaGFzaFR5cGUgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdLnNpZ2hhc2hUeXBlIHx8IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVDtcbiAgICBpZiAoc2lnaGFzaFR5cGVzICYmIHNpZ2hhc2hUeXBlcy5pbmRleE9mKHNpZ2hhc2hUeXBlKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFNpZ2hhc2ggdHlwZSBpcyBub3QgYWxsb3dlZC4gUmV0cnkgdGhlIHNpZ24gbWV0aG9kIHBhc3NpbmcgdGhlIGAgK1xuICAgICAgICAgIGBzaWdoYXNoVHlwZXMgYXJyYXkgb2Ygd2hpdGVsaXN0ZWQgdHlwZXMuIFNpZ2hhc2ggdHlwZTogJHtzaWdoYXNoVHlwZX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0eElucHV0cyA9IHRoaXMudHhJbnB1dHM7IC8vIFRoZXNlIGFyZSBzb21ld2hhdCBjb3N0bHkgdG8gZXh0cmFjdFxuICAgIGNvbnN0IHByZXZvdXRTY3JpcHRzOiBCdWZmZXJbXSA9IFtdO1xuICAgIGNvbnN0IHByZXZvdXRWYWx1ZXM6IGJpZ2ludFtdID0gW107XG5cbiAgICB0aGlzLmRhdGEuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICBsZXQgcHJldm91dDtcbiAgICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNvc3RseSwgZWl0aGVyIGNhY2hlIGl0IGhlcmUsIG9yIGZpbmQgYSB3YXkgdG8gc2hhcmUgd2l0aCBzdXBlclxuICAgICAgICBjb25zdCBub25XaXRuZXNzVXR4b1R4ID0gKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFV0eG9Qc2J0KS50cmFuc2FjdGlvbkZyb21CdWZmZXIoXG4gICAgICAgICAgaW5wdXQubm9uV2l0bmVzc1V0eG8sXG4gICAgICAgICAgdGhpcy50eC5uZXR3b3JrXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcHJldm91dEhhc2ggPSB0eElucHV0c1tpXS5oYXNoO1xuICAgICAgICBjb25zdCB1dHhvSGFzaCA9IG5vbldpdG5lc3NVdHhvVHguZ2V0SGFzaCgpO1xuXG4gICAgICAgIC8vIElmIGEgbm9uLXdpdG5lc3MgVVRYTyBpcyBwcm92aWRlZCwgaXRzIGhhc2ggbXVzdCBtYXRjaCB0aGUgaGFzaCBzcGVjaWZpZWQgaW4gdGhlIHByZXZvdXRcbiAgICAgICAgaWYgKCFwcmV2b3V0SGFzaC5lcXVhbHModXR4b0hhc2gpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24td2l0bmVzcyBVVFhPIGhhc2ggZm9yIGlucHV0ICMke2l9IGRvZXNuJ3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmV2b3V0SW5kZXggPSB0eElucHV0c1tpXS5pbmRleDtcbiAgICAgICAgcHJldm91dCA9IG5vbldpdG5lc3NVdHhvVHgub3V0c1twcmV2b3V0SW5kZXhdO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgICBwcmV2b3V0ID0gaW5wdXQud2l0bmVzc1V0eG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYSBVdHhvIGlucHV0IGl0ZW0gZm9yIHNpZ25pbmcnKTtcbiAgICAgIH1cbiAgICAgIHByZXZvdXRTY3JpcHRzLnB1c2gocHJldm91dC5zY3JpcHQpO1xuICAgICAgcHJldm91dFZhbHVlcy5wdXNoKHByZXZvdXQudmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IG91dHB1dFNjcmlwdCA9IHRoaXMuZ2V0VGFwcm9vdE91dHB1dFNjcmlwdChpbnB1dEluZGV4KTtcbiAgICBpZiAoIW91dHB1dFNjcmlwdC5lcXVhbHMocHJldm91dFNjcmlwdHNbaW5wdXRJbmRleF0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdpdG5lc3Mgc2NyaXB0IGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fSBkb2Vzbid0IG1hdGNoIHRoZSBzY3JpcHRQdWJLZXkgaW4gdGhlIHByZXZvdXRgKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IHRoaXMudHguaGFzaEZvcldpdG5lc3NWMShpbnB1dEluZGV4LCBwcmV2b3V0U2NyaXB0cywgcHJldm91dFZhbHVlcywgc2lnaGFzaFR5cGUsIGxlYWZIYXNoKTtcbiAgICByZXR1cm4geyBoYXNoLCBzaWdoYXNoVHlwZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcHJvcHJpZXRhcnkga2V5IHZhbHVlIHBhaXIgdG8gUFNCVCBpbnB1dC5cbiAgICogRGVmYXVsdCBpZGVudGlmaWVyRW5jb2RpbmcgaXMgdXRmLTggZm9yIGlkZW50aWZpZXIuXG4gICAqL1xuICBhZGRQcm9wcmlldGFyeUtleVZhbFRvSW5wdXQoaW5wdXRJbmRleDogbnVtYmVyLCBrZXlWYWx1ZURhdGE6IFByb3ByaWV0YXJ5S2V5VmFsdWUpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCB7XG4gICAgICBrZXk6IGVuY29kZVByb3ByaWV0YXJ5S2V5KGtleVZhbHVlRGF0YS5rZXkpLFxuICAgICAgdmFsdWU6IGtleVZhbHVlRGF0YS52YWx1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgKGlmIGV4aXN0cykgcHJvcHJpZXRhcnkga2V5IHZhbHVlIHBhaXIgdG8gUFNCVCBpbnB1dC5cbiAgICogRGVmYXVsdCBpZGVudGlmaWVyRW5jb2RpbmcgaXMgdXRmLTggZm9yIGlkZW50aWZpZXIuXG4gICAqL1xuICBhZGRPclVwZGF0ZVByb3ByaWV0YXJ5S2V5VmFsVG9JbnB1dChpbnB1dEluZGV4OiBudW1iZXIsIGtleVZhbHVlRGF0YTogUHJvcHJpZXRhcnlLZXlWYWx1ZSk6IHRoaXMge1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBrZXkgPSBlbmNvZGVQcm9wcmlldGFyeUtleShrZXlWYWx1ZURhdGEua2V5KTtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBrZXlWYWx1ZURhdGE7XG4gICAgaWYgKGlucHV0LnVua25vd25LZXlWYWxzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHVrdkluZGV4ID0gaW5wdXQudW5rbm93bktleVZhbHMuZmluZEluZGV4KCh1a3YpID0+IHVrdi5rZXkuZXF1YWxzKGtleSkpO1xuICAgICAgaWYgKHVrdkluZGV4ID4gLTEpIHtcbiAgICAgICAgaW5wdXQudW5rbm93bktleVZhbHNbdWt2SW5kZXhdID0geyBrZXksIHZhbHVlIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIHNlYXJjaCBhbnkgZGF0YSBmcm9tIHByb3ByaWV0YXJ5IGtleSB2YWx1ZSBhZ2FpbnN0IGtleWRhdGEuXG4gICAqIERlZmF1bHQgaWRlbnRpZmllckVuY29kaW5nIGlzIHV0Zi04IGZvciBpZGVudGlmaWVyLlxuICAgKi9cbiAgZ2V0UHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0SW5kZXg6IG51bWJlciwga2V5U2VhcmNoPzogUHJvcHJpZXRhcnlLZXlTZWFyY2gpOiBQcm9wcmlldGFyeUtleVZhbHVlW10ge1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gZ2V0UHNidElucHV0UHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0LCBrZXlTZWFyY2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIGRlbGV0ZSBhbnkgZGF0YSBmcm9tIHByb3ByaWV0YXJ5IGtleSB2YWx1ZS5cbiAgICogRGVmYXVsdCBpZGVudGlmaWVyRW5jb2RpbmcgaXMgdXRmLTggZm9yIGlkZW50aWZpZXIuXG4gICAqL1xuICBkZWxldGVQcm9wcmlldGFyeUtleVZhbHMoaW5wdXRJbmRleDogbnVtYmVyLCBrZXlzVG9EZWxldGU/OiBQcm9wcmlldGFyeUtleVNlYXJjaCk6IHRoaXMge1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBpZiAoIWlucHV0LnVua25vd25LZXlWYWxzPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoa2V5c1RvRGVsZXRlICYmIGtleXNUb0RlbGV0ZS5zdWJ0eXBlID09PSB1bmRlZmluZWQgJiYgQnVmZmVyLmlzQnVmZmVyKGtleXNUb0RlbGV0ZS5rZXlkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByb3ByaWV0YXJ5IGtleSBzZWFyY2ggZmlsdGVyIGNvbWJpbmF0aW9uLiBzdWJ0eXBlIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlucHV0LnVua25vd25LZXlWYWxzID0gaW5wdXQudW5rbm93bktleVZhbHMuZmlsdGVyKChrZXlWYWx1ZSwgaSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZGVjb2RlUHJvcHJpZXRhcnlLZXkoa2V5VmFsdWUua2V5KTtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICBrZXlzVG9EZWxldGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoa2V5c1RvRGVsZXRlLmlkZW50aWZpZXIgPT09IGtleS5pZGVudGlmaWVyICYmXG4gICAgICAgICAgKGtleXNUb0RlbGV0ZS5zdWJ0eXBlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChrZXlzVG9EZWxldGUuc3VidHlwZSA9PT0ga2V5LnN1YnR5cGUgJiZcbiAgICAgICAgICAgICAgKCFCdWZmZXIuaXNCdWZmZXIoa2V5c1RvRGVsZXRlLmtleWRhdGEpIHx8IGtleXNUb0RlbGV0ZS5rZXlkYXRhLmVxdWFscyhrZXkua2V5ZGF0YSkpKSkpXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVNdXNpZzJOb25jZUZvcklucHV0KFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBrZXlQYWlyOiBCSVAzMkludGVyZmFjZSxcbiAgICBrZXlUeXBlOiAncm9vdCcgfCAnZGVyaXZlZCcsXG4gICAgcGFyYW1zOiB7IHNlc3Npb25JZD86IEJ1ZmZlcjsgZGV0ZXJtaW5pc3RpYz86IGJvb2xlYW4gfSA9IHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UgfVxuICApOiBQc2J0TXVzaWcyUHViTm9uY2Uge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XTtcbiAgICBpZiAoIWlucHV0LnRhcEludGVybmFsS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcEludGVybmFsS2V5IGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBub25jZScpO1xuICAgIH1cbiAgICBpZiAoIWlucHV0LnRhcE1lcmtsZVJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFwTWVya2xlUm9vdCBpcyByZXF1aXJlZCB0byBjcmVhdGUgbm9uY2UnKTtcbiAgICB9XG4gICAgY29uc3QgZ2V0RGVyaXZlZEtleVBhaXIgPSAoKTogQklQMzJJbnRlcmZhY2UgPT4ge1xuICAgICAgaWYgKCFpbnB1dC50YXBCaXAzMkRlcml2YXRpb24/Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcEJpcDMyRGVyaXZhdGlvbiBpcyByZXF1aXJlZCB0byBjcmVhdGUgbm9uY2UnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcml2ZWQgPSBVdHhvUHNidC5kZXJpdmVLZXlQYWlyKGtleVBhaXIsIGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbiwgeyBpZ25vcmVZOiB0cnVlIH0pO1xuICAgICAgaWYgKCFkZXJpdmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYmlwMzJEZXJpdmF0aW9uIG1hc3RlckZpbmdlcnByaW50IG1hdGNoZWQgdGhlIEhEIGtleVBhaXIgZmluZ2VycHJpbnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXJpdmVkO1xuICAgIH07XG4gICAgY29uc3QgZGVyaXZlZEtleVBhaXIgPSBrZXlUeXBlID09PSAncm9vdCcgPyBnZXREZXJpdmVkS2V5UGFpcigpIDoga2V5UGFpcjtcbiAgICBpZiAoIWRlcml2ZWRLZXlQYWlyLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZUtleSBpcyByZXF1aXJlZCB0byBjcmVhdGUgbm9uY2UnKTtcbiAgICB9XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gcGFyc2VQc2J0TXVzaWcyUGFydGljaXBhbnRzKGlucHV0KTtcbiAgICBpZiAoIXBhcnRpY2lwYW50cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCAwIG1hdGNoaW5nIHBhcnRpY2lwYW50IGtleSB2YWx1ZSBpbnN0ZWFkIG9mIDFgKTtcbiAgICB9XG4gICAgYXNzZXJ0UHNidE11c2lnMlBhcnRpY2lwYW50cyhwYXJ0aWNpcGFudHMsIGlucHV0LnRhcEludGVybmFsS2V5LCBpbnB1dC50YXBNZXJrbGVSb290KTtcbiAgICBjb25zdCB7IHRhcE91dHB1dEtleSwgcGFydGljaXBhbnRQdWJLZXlzIH0gPSBwYXJ0aWNpcGFudHM7XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudFB1YktleSA9IHBhcnRpY2lwYW50UHViS2V5cy5maW5kKChwdWJLZXkpID0+XG4gICAgICBlcXVhbFB1YmxpY0tleUlnbm9yZVkocHViS2V5LCBkZXJpdmVkS2V5UGFpci5wdWJsaWNLZXkpXG4gICAgKTtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXJ0aWNpcGFudFB1YktleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGljaXBhbnQgcGxhaW4gcHViIGtleSBzaG91bGQgbWF0Y2ggb25lIGJpcDMyRGVyaXZhdGlvbiBwbGFpbiBwdWIga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBoYXNoIH0gPSB0aGlzLmdldFRhcHJvb3RIYXNoRm9yU2lnKGlucHV0SW5kZXgpO1xuXG4gICAgbGV0IHB1Yk5vbmNlOiBCdWZmZXI7XG4gICAgaWYgKHBhcmFtcy5kZXRlcm1pbmlzdGljKSB7XG4gICAgICBpZiAocGFyYW1zLnNlc3Npb25JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgZXh0cmEgZW50cm9weSB3aGVuIGdlbmVyYXRpbmcgYSBkZXRlcm1pbmlzdGljIG5vbmNlJyk7XG4gICAgICB9XG4gICAgICAvLyBUaGVyZSBtdXN0IGJlIG9ubHkgMiBwYXJ0aWNpcGFudCBwdWJLZXlzIGlmIGl0IGdvdCB0byB0aGlzIHBvaW50XG4gICAgICBpZiAoIWVxdWFsUHVibGljS2V5SWdub3JlWShwYXJ0aWNpcGFudFB1YktleSwgcGFydGljaXBhbnRQdWJLZXlzWzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgdGhlIGNvc2lnbmVyJ3Mgbm9uY2UgY2FuIGJlIHNldCBkZXRlcm1pbmlzdGljYWxseWApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9uY2VzID0gcGFyc2VQc2J0TXVzaWcyTm9uY2VzKGlucHV0KTtcbiAgICAgIGlmICghbm9uY2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbm9uY2VzIGZvdW5kIG9uIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgICB9XG4gICAgICBpZiAobm9uY2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMiBub25jZXNgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpcnN0U2lnbmVyTm9uY2UgPSBub25jZXMuZmluZCgoa3YpID0+IGVxdWFsUHVibGljS2V5SWdub3JlWShrdi5wYXJ0aWNpcGFudFB1YktleSwgcGFydGljaXBhbnRQdWJLZXlzWzBdKSk7XG4gICAgICBpZiAoIWZpcnN0U2lnbmVyTm9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduZXIgbm9uY2UgbXVzdCBiZSBzZXQgaWYgY29zaWduZXIgbm9uY2UgaXMgdG8gYmUgZGVyaXZlZCBkZXRlcm1pbmlzdGljYWxseScpO1xuICAgICAgfVxuXG4gICAgICBwdWJOb25jZSA9IGNyZWF0ZU11c2lnMkRldGVybWluaXN0aWNOb25jZSh7XG4gICAgICAgIHByaXZhdGVLZXk6IGRlcml2ZWRLZXlQYWlyLnByaXZhdGVLZXksXG4gICAgICAgIG90aGVyTm9uY2U6IGZpcnN0U2lnbmVyTm9uY2UucHViTm9uY2UsXG4gICAgICAgIHB1YmxpY0tleXM6IHBhcnRpY2lwYW50UHViS2V5cyxcbiAgICAgICAgaW50ZXJuYWxQdWJLZXk6IGlucHV0LnRhcEludGVybmFsS2V5LFxuICAgICAgICB0YXBUcmVlUm9vdDogaW5wdXQudGFwTWVya2xlUm9vdCxcbiAgICAgICAgaGFzaCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWJOb25jZSA9IEJ1ZmZlci5mcm9tKFxuICAgICAgICB0aGlzLm5vbmNlU3RvcmUuY3JlYXRlTXVzaWcyTm9uY2UoXG4gICAgICAgICAgZGVyaXZlZEtleVBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICBwYXJ0aWNpcGFudFB1YktleSxcbiAgICAgICAgICB0YXBPdXRwdXRLZXksXG4gICAgICAgICAgaGFzaCxcbiAgICAgICAgICBwYXJhbXMuc2Vzc2lvbklkXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdGFwT3V0cHV0S2V5LCBwYXJ0aWNpcGFudFB1YktleSwgcHViTm9uY2UgfTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0TXVzaWcyTm9uY2VzSW5uZXIoXG4gICAga2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gICAga2V5VHlwZTogJ3Jvb3QnIHwgJ2Rlcml2ZWQnLFxuICAgIGlucHV0SW5kZXg/OiBudW1iZXIsXG4gICAgcGFyYW1zOiB7IHNlc3Npb25JZD86IEJ1ZmZlcjsgZGV0ZXJtaW5pc3RpYz86IGJvb2xlYW4gfSA9IHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UgfVxuICApOiB0aGlzIHtcbiAgICBpZiAoa2V5UGFpci5pc05ldXRlcmVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgbm9uY2UnKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXJhbXMuc2Vzc2lvbklkKSAmJiBwYXJhbXMuc2Vzc2lvbklkLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXNzaW9uSWQgc2l6ZSAke3BhcmFtcy5zZXNzaW9uSWQubGVuZ3RofWApO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0SW5kZXhlcyA9IGlucHV0SW5kZXggPT09IHVuZGVmaW5lZCA/IFsuLi5BcnJheSh0aGlzLmlucHV0Q291bnQpLmtleXMoKV0gOiBbaW5wdXRJbmRleF07XG4gICAgaW5wdXRJbmRleGVzLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNUYXByb290S2V5UGF0aElucHV0KGluZGV4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub25jZSA9IHRoaXMuY3JlYXRlTXVzaWcyTm9uY2VGb3JJbnB1dChpbmRleCwga2V5UGFpciwga2V5VHlwZSwgcGFyYW1zKTtcbiAgICAgIHRoaXMuYWRkT3JVcGRhdGVQcm9wcmlldGFyeUtleVZhbFRvSW5wdXQoaW5kZXgsIGVuY29kZVBzYnRNdXNpZzJQdWJOb25jZShub25jZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbmQgc2V0cyBNdVNpZzIgbm9uY2UgdG8gdGFwcm9vdCBrZXkgcGF0aCBpbnB1dCBhdCBpbnB1dEluZGV4LlxuICAgKiBJZiBpbnB1dCBpcyBub3QgYSB0YXByb290IGtleSBwYXRoLCBubyBhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dEluZGV4IGlucHV0IGluZGV4XG4gICAqIEBwYXJhbSBrZXlQYWlyIGRlcml2ZWQga2V5IHBhaXJcbiAgICogQHBhcmFtIHNlc3Npb25JZCBPcHRpb25hbCBleHRyYSBlbnRyb3B5LiBJZiBwcm92aWRlZCBpdCBtdXN0IGVpdGhlciBiZSBhIGNvdW50ZXIgdW5pcXVlIHRvIHRoaXMgc2VjcmV0IGtleSxcbiAgICogKGNvbnZlcnRlZCB0byBhbiBhcnJheSBvZiAzMiBieXRlcyksIG9yIDMyIHVuaWZvcm1seSByYW5kb20gYnl0ZXMuXG4gICAqIEBwYXJhbSBkZXRlcm1pbmlzdGljIElmIHRydWUsIHNldCB0aGUgY29zaWduZXIgbm9uY2UgZGV0ZXJtaW5pc3RpY2FsbHlcbiAgICovXG4gIHNldElucHV0TXVzaWcyTm9uY2UoXG4gICAgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIGRlcml2ZWRLZXlQYWlyOiBCSVAzMkludGVyZmFjZSxcbiAgICBwYXJhbXM6IHsgc2Vzc2lvbklkPzogQnVmZmVyOyBkZXRlcm1pbmlzdGljPzogYm9vbGVhbiB9ID0geyBkZXRlcm1pbmlzdGljOiBmYWxzZSB9XG4gICk6IHRoaXMge1xuICAgIHJldHVybiB0aGlzLnNldE11c2lnMk5vbmNlc0lubmVyKGRlcml2ZWRLZXlQYWlyLCAnZGVyaXZlZCcsIGlucHV0SW5kZXgsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuZCBzZXRzIE11U2lnMiBub25jZSB0byB0YXByb290IGtleSBwYXRoIGlucHV0IGF0IGlucHV0SW5kZXguXG4gICAqIElmIGlucHV0IGlzIG5vdCBhIHRhcHJvb3Qga2V5IHBhdGgsIG5vIGFjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0SW5kZXggaW5wdXQgaW5kZXhcbiAgICogQHBhcmFtIGtleVBhaXIgSEQgcm9vdCBrZXkgcGFpclxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIE9wdGlvbmFsIGV4dHJhIGVudHJvcHkuIElmIHByb3ZpZGVkIGl0IG11c3QgZWl0aGVyIGJlIGEgY291bnRlciB1bmlxdWUgdG8gdGhpcyBzZWNyZXQga2V5LFxuICAgKiAoY29udmVydGVkIHRvIGFuIGFycmF5IG9mIDMyIGJ5dGVzKSwgb3IgMzIgdW5pZm9ybWx5IHJhbmRvbSBieXRlcy5cbiAgICogQHBhcmFtIGRldGVybWluaXN0aWMgSWYgdHJ1ZSwgc2V0IHRoZSBjb3NpZ25lciBub25jZSBkZXRlcm1pbmlzdGljYWxseVxuICAgKi9cbiAgc2V0SW5wdXRNdXNpZzJOb25jZUhEKFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBrZXlQYWlyOiBCSVAzMkludGVyZmFjZSxcbiAgICBwYXJhbXM6IHsgc2Vzc2lvbklkPzogQnVmZmVyOyBkZXRlcm1pbmlzdGljPzogYm9vbGVhbiB9ID0geyBkZXRlcm1pbmlzdGljOiBmYWxzZSB9XG4gICk6IHRoaXMge1xuICAgIGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0TXVzaWcyTm9uY2VzSW5uZXIoa2V5UGFpciwgJ3Jvb3QnLCBpbnB1dEluZGV4LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbmQgc2V0cyBNdVNpZzIgbm9uY2UgdG8gYWxsIHRhcHJvb3Qga2V5IHBhdGggaW5wdXRzLiBPdGhlciBpbnB1dHMgd2lsbCBiZSBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRJbmRleCBpbnB1dCBpbmRleFxuICAgKiBAcGFyYW0ga2V5UGFpciBkZXJpdmVkIGtleSBwYWlyXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgT3B0aW9uYWwgZXh0cmEgZW50cm9weS4gSWYgcHJvdmlkZWQgaXQgbXVzdCBlaXRoZXIgYmUgYSBjb3VudGVyIHVuaXF1ZSB0byB0aGlzIHNlY3JldCBrZXksXG4gICAqIChjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgb2YgMzIgYnl0ZXMpLCBvciAzMiB1bmlmb3JtbHkgcmFuZG9tIGJ5dGVzLlxuICAgKi9cbiAgc2V0QWxsSW5wdXRzTXVzaWcyTm9uY2UoXG4gICAga2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gICAgcGFyYW1zOiB7IHNlc3Npb25JZD86IEJ1ZmZlcjsgZGV0ZXJtaW5pc3RpYz86IGJvb2xlYW4gfSA9IHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UgfVxuICApOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5zZXRNdXNpZzJOb25jZXNJbm5lcihrZXlQYWlyLCAnZGVyaXZlZCcsIHVuZGVmaW5lZCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW5kIHNldHMgTXVTaWcyIG5vbmNlIHRvIGFsbCB0YXByb290IGtleSBwYXRoIGlucHV0cy4gT3RoZXIgaW5wdXRzIHdpbGwgYmUgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0SW5kZXggaW5wdXQgaW5kZXhcbiAgICogQHBhcmFtIGtleVBhaXIgSEQgcm9vdCBrZXkgcGFpclxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIE9wdGlvbmFsIGV4dHJhIGVudHJvcHkuIElmIHByb3ZpZGVkIGl0IG11c3QgZWl0aGVyIGJlIGEgY291bnRlciB1bmlxdWUgdG8gdGhpcyBzZWNyZXQga2V5LFxuICAgKiAoY29udmVydGVkIHRvIGFuIGFycmF5IG9mIDMyIGJ5dGVzKSwgb3IgMzIgdW5pZm9ybWx5IHJhbmRvbSBieXRlcy5cbiAgICovXG4gIHNldEFsbElucHV0c011c2lnMk5vbmNlSEQoXG4gICAga2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gICAgcGFyYW1zOiB7IHNlc3Npb25JZD86IEJ1ZmZlcjsgZGV0ZXJtaW5pc3RpYz86IGJvb2xlYW4gfSA9IHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UgfVxuICApOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5zZXRNdXNpZzJOb25jZXNJbm5lcihrZXlQYWlyLCAncm9vdCcsIHVuZGVmaW5lZCwgcGFyYW1zKTtcbiAgfVxuXG4gIGNsb25lKCk6IHRoaXMge1xuICAgIHJldHVybiBzdXBlci5jbG9uZSgpIGFzIHRoaXM7XG4gIH1cblxuICBleHRyYWN0VHJhbnNhY3Rpb24oZGlzYWJsZUZlZUNoZWNrPzogYm9vbGVhbik6IFV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+IHtcbiAgICBjb25zdCB0eCA9IHN1cGVyLmV4dHJhY3RUcmFuc2FjdGlvbihkaXNhYmxlRmVlQ2hlY2spO1xuICAgIGlmICh0eCBpbnN0YW5jZW9mIFV0eG9UcmFuc2FjdGlvbikge1xuICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dHJhY3RUcmFuc2FjdGlvbiBkaWQgbm90IHJldHVybiBpbnN0YWNlIG9mIFV0eG9UcmFuc2FjdGlvbicpO1xuICB9XG59XG4iXX0=