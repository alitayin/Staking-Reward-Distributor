"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signInput2Of3 = exports.signInputP2shP2pk = exports.getDefaultSigHash = exports.verifySignatureWithPublicKey = exports.verifySignatureWithPublicKeys = exports.getSignaturesWithPublicKeys = exports.verifySignature = exports.getSignatureVerifications = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const UtxoTransaction_1 = require("./UtxoTransaction");
const outputScripts_1 = require("./outputScripts");
const networks_1 = require("../networks");
const noble_ecc_1 = require("../noble_ecc");
const parseInput_1 = require("./parseInput");
const taproot_1 = require("../taproot");
/**
 * @deprecated - use {@see verifySignaturesWithPublicKeys} instead
 * Get signature verifications for multsig transaction
 * @param transaction
 * @param inputIndex
 * @param amount - must be set for segwit transactions and BIP143 transactions
 * @param verificationSettings
 * @param prevOutputs - must be set for p2tr and p2trMusig2 transactions
 * @returns SignatureVerification[] - in order of parsed non-empty signatures
 */
function getSignatureVerifications(transaction, inputIndex, amount, verificationSettings = {}, prevOutputs) {
    /* istanbul ignore next */
    if (!transaction.ins) {
        throw new Error(`invalid transaction`);
    }
    const input = transaction.ins[inputIndex];
    /* istanbul ignore next */
    if (!input) {
        throw new Error(`no input at index ${inputIndex}`);
    }
    if ((!input.script || input.script.length === 0) && input.witness.length === 0) {
        // Unsigned input: no signatures.
        return [];
    }
    const parsedScript = parseInput_1.parseSignatureScript2Of3(input);
    if (parsedScript.scriptType === 'taprootKeyPathSpend' || parsedScript.scriptType === 'taprootScriptPathSpend') {
        if (parsedScript.scriptType === 'taprootKeyPathSpend' &&
            (verificationSettings.signatureIndex || verificationSettings.publicKey)) {
            throw new Error(`signatureIndex and publicKey parameters not supported for taprootKeyPathSpend`);
        }
        if (verificationSettings.signatureIndex !== undefined) {
            throw new Error(`signatureIndex parameter not supported for taprootScriptPathSpend`);
        }
        if (!prevOutputs) {
            throw new Error(`prevOutputs not set`);
        }
        if (prevOutputs.length !== transaction.ins.length) {
            throw new Error(`prevOutputs length ${prevOutputs.length}, expected ${transaction.ins.length}`);
        }
    }
    let publicKeys;
    if (parsedScript.scriptType === 'taprootKeyPathSpend') {
        if (!prevOutputs) {
            throw new Error(`prevOutputs not set`);
        }
        publicKeys = [taproot_1.getTaprootOutputKey(prevOutputs[inputIndex].script)];
    }
    else {
        publicKeys = parsedScript.publicKeys.filter((buf) => verificationSettings.publicKey === undefined ||
            verificationSettings.publicKey.equals(buf) ||
            verificationSettings.publicKey.slice(1).equals(buf));
    }
    const signatures = parsedScript.signatures
        .filter((s) => s && s.length)
        .filter((s, i) => verificationSettings.signatureIndex === undefined || verificationSettings.signatureIndex === i);
    return signatures.map((signatureBuffer) => {
        if (signatureBuffer === 0 || signatureBuffer.length === 0) {
            return { signedBy: undefined, signature: undefined };
        }
        let hashType = bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT;
        if (signatureBuffer.length === 65) {
            hashType = signatureBuffer[signatureBuffer.length - 1];
            signatureBuffer = signatureBuffer.slice(0, -1);
        }
        if (parsedScript.scriptType === 'taprootScriptPathSpend') {
            if (!prevOutputs) {
                throw new Error(`prevOutputs not set`);
            }
            const { controlBlock, pubScript } = parsedScript;
            const leafHash = bitcoinjs_lib_1.taproot.getTapleafHash(noble_ecc_1.ecc, controlBlock, pubScript);
            const signatureHash = transaction.hashForWitnessV1(inputIndex, prevOutputs.map(({ script }) => script), prevOutputs.map(({ value }) => value), hashType, leafHash);
            const signedBy = publicKeys.filter((k) => Buffer.isBuffer(signatureBuffer) && noble_ecc_1.ecc.verifySchnorr(signatureHash, k, signatureBuffer));
            if (signedBy.length === 0) {
                return { signedBy: undefined, signature: undefined };
            }
            if (signedBy.length === 1) {
                return { signedBy: signedBy[0], signature: signatureBuffer };
            }
            throw new Error(`illegal state: signed by multiple public keys`);
        }
        else if (parsedScript.scriptType === 'taprootKeyPathSpend') {
            if (!prevOutputs) {
                throw new Error(`prevOutputs not set`);
            }
            const signatureHash = transaction.hashForWitnessV1(inputIndex, prevOutputs.map(({ script }) => script), prevOutputs.map(({ value }) => value), hashType);
            const result = noble_ecc_1.ecc.verifySchnorr(signatureHash, publicKeys[0], signatureBuffer);
            return result
                ? { signedBy: publicKeys[0], signature: signatureBuffer }
                : { signedBy: undefined, signature: undefined };
        }
        else {
            // slice the last byte from the signature hash input because it's the hash type
            const { signature, hashType } = bitcoinjs_lib_1.ScriptSignature.decode(signatureBuffer);
            const transactionHash = parsedScript.scriptType === 'p2shP2wsh' || parsedScript.scriptType === 'p2wsh'
                ? transaction.hashForWitnessV0(inputIndex, parsedScript.pubScript, amount, hashType)
                : transaction.hashForSignatureByNetwork(inputIndex, parsedScript.pubScript, amount, hashType);
            const signedBy = publicKeys.filter((publicKey) => noble_ecc_1.ecc.verify(transactionHash, publicKey, signature, 
            /*
              Strict verification (require lower-S value), as required by BIP-0146
              https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki
              https://github.com/bitcoin-core/secp256k1/blob/ac83be33/include/secp256k1.h#L478-L508
              https://github.com/bitcoinjs/tiny-secp256k1/blob/v1.1.6/js.js#L231-L233
            */
            true));
            if (signedBy.length === 0) {
                return { signedBy: undefined, signature: undefined };
            }
            if (signedBy.length === 1) {
                return { signedBy: signedBy[0], signature: signatureBuffer };
            }
            throw new Error(`illegal state: signed by multiple public keys`);
        }
    });
}
exports.getSignatureVerifications = getSignatureVerifications;
/**
 * @deprecated use {@see verifySignatureWithPublicKeys} instead
 * @param transaction
 * @param inputIndex
 * @param amount
 * @param verificationSettings - if publicKey is specified, returns true iff any signature is signed by publicKey.
 * @param prevOutputs - must be set for p2tr transactions
 */
function verifySignature(transaction, inputIndex, amount, verificationSettings = {}, prevOutputs) {
    const signatureVerifications = getSignatureVerifications(transaction, inputIndex, amount, verificationSettings, prevOutputs).filter((v) => 
    // If no publicKey is set in verificationSettings, all signatures must be valid.
    // Otherwise, a single valid signature by the specified pubkey is sufficient.
    verificationSettings.publicKey === undefined ||
        (v.signedBy !== undefined &&
            (verificationSettings.publicKey.equals(v.signedBy) ||
                verificationSettings.publicKey.slice(1).equals(v.signedBy))));
    return signatureVerifications.length > 0 && signatureVerifications.every((v) => v.signedBy !== undefined);
}
exports.verifySignature = verifySignature;
/**
 * @param v
 * @param publicKey
 * @return true iff signature is by publicKey (or xonly variant of publicKey)
 */
function isSignatureByPublicKey(v, publicKey) {
    return (!!v.signedBy &&
        (v.signedBy.equals(publicKey) ||
            /* for p2tr signatures, we pass the pubkey in 33-byte format recover it from the signature in 32-byte format */
            (publicKey.length === 33 && isSignatureByPublicKey(v, publicKey.slice(1)))));
}
/**
 * @param transaction
 * @param inputIndex
 * @param prevOutputs
 * @param publicKeys
 * @return array with signature corresponding to n-th key, undefined if no match found
 */
function getSignaturesWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys) {
    if (transaction.ins.length !== prevOutputs.length) {
        throw new Error(`input length must match prevOutputs length`);
    }
    const signatureVerifications = getSignatureVerifications(transaction, inputIndex, prevOutputs[inputIndex].value, {}, prevOutputs);
    return publicKeys.map((publicKey) => {
        const v = signatureVerifications.find((v) => isSignatureByPublicKey(v, publicKey));
        return v ? v.signature : undefined;
    });
}
exports.getSignaturesWithPublicKeys = getSignaturesWithPublicKeys;
/**
 * @param transaction
 * @param inputIndex
 * @param prevOutputs - transaction outputs for inputs
 * @param publicKeys - public keys to check signatures for
 * @return array of booleans indicating a valid signature for every pubkey in _publicKeys_
 */
function verifySignatureWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys) {
    return getSignaturesWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys).map((s) => s !== undefined);
}
exports.verifySignatureWithPublicKeys = verifySignatureWithPublicKeys;
/**
 * Wrapper for {@see verifySignatureWithPublicKeys} for single pubkey
 * @param transaction
 * @param inputIndex
 * @param prevOutputs
 * @param publicKey
 * @return true iff signature is valid
 */
function verifySignatureWithPublicKey(transaction, inputIndex, prevOutputs, publicKey) {
    return verifySignatureWithPublicKeys(transaction, inputIndex, prevOutputs, [publicKey])[0];
}
exports.verifySignatureWithPublicKey = verifySignatureWithPublicKey;
function getDefaultSigHash(network, scriptType) {
    switch (networks_1.getMainnet(network)) {
        case networks_1.networks.bitcoincash:
        case networks_1.networks.bitcoinsv:
        case networks_1.networks.bitcoingold:
        case networks_1.networks.ecash:
            return bitcoinjs_lib_1.Transaction.SIGHASH_ALL | UtxoTransaction_1.UtxoTransaction.SIGHASH_FORKID;
        default:
            switch (scriptType) {
                case 'p2tr':
                case 'p2trMusig2':
                    return bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT;
                default:
                    return bitcoinjs_lib_1.Transaction.SIGHASH_ALL;
            }
    }
}
exports.getDefaultSigHash = getDefaultSigHash;
function signInputP2shP2pk(txBuilder, vin, keyPair) {
    const prevOutScriptType = 'p2sh-p2pk';
    const { redeemScript, witnessScript } = outputScripts_1.createOutputScriptP2shP2pk(keyPair.publicKey);
    keyPair.network = txBuilder.network;
    txBuilder.sign({
        vin,
        prevOutScriptType,
        keyPair,
        hashType: getDefaultSigHash(txBuilder.network),
        redeemScript,
        witnessScript,
        witnessValue: undefined,
    });
}
exports.signInputP2shP2pk = signInputP2shP2pk;
function signInput2Of3(txBuilder, vin, scriptType, pubkeys, keyPair, cosigner, amount) {
    let controlBlock;
    let redeemScript;
    let witnessScript;
    const prevOutScriptType = outputScripts_1.scriptType2Of3AsPrevOutType(scriptType);
    if (scriptType === 'p2tr') {
        ({ witnessScript, controlBlock } = outputScripts_1.createSpendScriptP2tr(pubkeys, [keyPair.publicKey, cosigner]));
    }
    else {
        ({ redeemScript, witnessScript } = outputScripts_1.createOutputScript2of3(pubkeys, scriptType));
    }
    keyPair.network = txBuilder.network;
    txBuilder.sign({
        vin,
        prevOutScriptType,
        keyPair,
        hashType: getDefaultSigHash(txBuilder.network, scriptType),
        redeemScript,
        witnessScript,
        witnessValue: amount,
        controlBlock,
    });
}
exports.signInput2Of3 = signInput2Of3;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmF0dXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2JpdGdvL3NpZ25hdHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxpREFBZ0Y7QUFFaEYsdURBQW9EO0FBRXBELG1EQU95QjtBQUV6QiwwQ0FBNEQ7QUFDNUQsNENBQTZDO0FBQzdDLDZDQUF3RDtBQUN4RCx3Q0FBaUQ7QUE4QmpEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLHlCQUF5QixDQUN2QyxXQUFxQyxFQUNyQyxVQUFrQixFQUNsQixNQUFlLEVBQ2YsdUJBQTZDLEVBQUUsRUFDL0MsV0FBaUM7SUFFakMsMEJBQTBCO0lBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztLQUN4QztJQUVELE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDMUMsMEJBQTBCO0lBQzFCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDVixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixVQUFVLEVBQUUsQ0FBQyxDQUFDO0tBQ3BEO0lBRUQsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDOUUsaUNBQWlDO1FBQ2pDLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLFlBQVksR0FBRyxxQ0FBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVyRCxJQUFJLFlBQVksQ0FBQyxVQUFVLEtBQUsscUJBQXFCLElBQUksWUFBWSxDQUFDLFVBQVUsS0FBSyx3QkFBd0IsRUFBRTtRQUM3RyxJQUNFLFlBQVksQ0FBQyxVQUFVLEtBQUsscUJBQXFCO1lBQ2pELENBQUMs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YUFBYTtRQUNiLFlBQVksRUFBRSxNQUFNO1FBQ3BCLFlBQVk7S0FDYixDQUFDLENBQUM7QUFDTCxDQUFDO0FBaENELHNDQWdDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJJUDMySW50ZXJmYWNlIH0gZnJvbSAnYmlwMzInO1xuXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgdGFwcm9vdCwgVHhPdXRwdXQsIFNjcmlwdFNpZ25hdHVyZSB9IGZyb20gJ2JpdGNvaW5qcy1saWInO1xuXG5pbXBvcnQgeyBVdHhvVHJhbnNhY3Rpb24gfSBmcm9tICcuL1V0eG9UcmFuc2FjdGlvbic7XG5pbXBvcnQgeyBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi9VdHhvVHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7XG4gIGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMsXG4gIGNyZWF0ZU91dHB1dFNjcmlwdFAyc2hQMnBrLFxuICBjcmVhdGVTcGVuZFNjcmlwdFAydHIsXG4gIFNjcmlwdFR5cGUsXG4gIFNjcmlwdFR5cGUyT2YzLFxuICBzY3JpcHRUeXBlMk9mM0FzUHJldk91dFR5cGUsXG59IGZyb20gJy4vb3V0cHV0U2NyaXB0cyc7XG5pbXBvcnQgeyBUcmlwbGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdldE1haW5uZXQsIE5ldHdvcmssIG5ldHdvcmtzIH0gZnJvbSAnLi4vbmV0d29ya3MnO1xuaW1wb3J0IHsgZWNjIGFzIGVjY0xpYiB9IGZyb20gJy4uL25vYmxlX2VjYyc7XG5pbXBvcnQgeyBwYXJzZVNpZ25hdHVyZVNjcmlwdDJPZjMgfSBmcm9tICcuL3BhcnNlSW5wdXQnO1xuaW1wb3J0IHsgZ2V0VGFwcm9vdE91dHB1dEtleSB9IGZyb20gJy4uL3RhcHJvb3QnO1xuXG4vKipcbiAqIENvbnN0cmFpbnRzIGZvciBzaWduYXR1cmUgdmVyaWZpY2F0aW9ucy5cbiAqIFBhcmFtZXRlcnMgYXJlIGNvbmp1bmN0aXZlOiBpZiBtdWx0aXBsZSBwYXJhbWV0ZXJzIGFyZSBzZXQsIGEgdmVyaWZpY2F0aW9uIGZvciBhbiBpbmRpdmlkdWFsXG4gKiBzaWduYXR1cmUgbXVzdCBzYXRpc2Z5IGFsbCBvZiB0aGVtLlxuICovXG5leHBvcnQgdHlwZSBWZXJpZmljYXRpb25TZXR0aW5ncyA9IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeS4gT25seSBpdGVyYXRlcyBvdmVyIG5vbi1lbXB0eSBzaWduYXR1cmVzLlxuICAgKi9cbiAgc2lnbmF0dXJlSW5kZXg/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSB0byB2ZXJpZnkuXG4gICAqL1xuICBwdWJsaWNLZXk/OiBCdWZmZXI7XG59O1xuXG4vKipcbiAqIFJlc3VsdCBmb3IgYSBpbmRpdmlkdWFsIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmF0dXJlVmVyaWZpY2F0aW9uID1cbiAgfCB7XG4gICAgICAvKiogU2V0IHRvIHRoZSBwdWJsaWMga2V5IHRoYXQgc2lnbmVkIGZvciB0aGUgc2lnbmF0dXJlICovXG4gICAgICBzaWduZWRCeTogQnVmZmVyO1xuICAgICAgLyoqIFNldCB0byB0aGUgc2lnbmF0dXJlIGJ1ZmZlciAqL1xuICAgICAgc2lnbmF0dXJlOiBCdWZmZXI7XG4gICAgfVxuICB8IHsgc2lnbmVkQnk6IHVuZGVmaW5lZDsgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCAtIHVzZSB7QHNlZSB2ZXJpZnlTaWduYXR1cmVzV2l0aFB1YmxpY0tleXN9IGluc3RlYWRcbiAqIEdldCBzaWduYXR1cmUgdmVyaWZpY2F0aW9ucyBmb3IgbXVsdHNpZyB0cmFuc2FjdGlvblxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gaW5wdXRJbmRleFxuICogQHBhcmFtIGFtb3VudCAtIG11c3QgYmUgc2V0IGZvciBzZWd3aXQgdHJhbnNhY3Rpb25zIGFuZCBCSVAxNDMgdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3NcbiAqIEBwYXJhbSBwcmV2T3V0cHV0cyAtIG11c3QgYmUgc2V0IGZvciBwMnRyIGFuZCBwMnRyTXVzaWcyIHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgU2lnbmF0dXJlVmVyaWZpY2F0aW9uW10gLSBpbiBvcmRlciBvZiBwYXJzZWQgbm9uLWVtcHR5IHNpZ25hdHVyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZVZlcmlmaWNhdGlvbnM8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHRyYW5zYWN0aW9uOiBVdHhvVHJhbnNhY3Rpb248VE51bWJlcj4sXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgYW1vdW50OiBUTnVtYmVyLFxuICB2ZXJpZmljYXRpb25TZXR0aW5nczogVmVyaWZpY2F0aW9uU2V0dGluZ3MgPSB7fSxcbiAgcHJldk91dHB1dHM/OiBUeE91dHB1dDxUTnVtYmVyPltdXG4pOiBTaWduYXR1cmVWZXJpZmljYXRpb25bXSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghdHJhbnNhY3Rpb24uaW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRyYW5zYWN0aW9uYCk7XG4gIH1cblxuICBjb25zdCBpbnB1dCA9IHRyYW5zYWN0aW9uLmluc1tpbnB1dEluZGV4XTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFpbnB1dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm8gaW5wdXQgYXQgaW5kZXggJHtpbnB1dEluZGV4fWApO1xuICB9XG5cbiAgaWYgKCghaW5wdXQuc2NyaXB0IHx8IGlucHV0LnNjcmlwdC5sZW5ndGggPT09IDApICYmIGlucHV0LndpdG5lc3MubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gVW5zaWduZWQgaW5wdXQ6IG5vIHNpZ25hdHVyZXMuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcGFyc2VkU2NyaXB0ID0gcGFyc2VTaWduYXR1cmVTY3JpcHQyT2YzKGlucHV0KTtcblxuICBpZiAocGFyc2VkU2NyaXB0LnNjcmlwdFR5cGUgPT09ICd0YXByb290S2V5UGF0aFNwZW5kJyB8fCBwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnKSB7XG4gICAgaWYgKFxuICAgICAgcGFyc2VkU2NyaXB0LnNjcmlwdFR5cGUgPT09ICd0YXByb290S2V5UGF0aFNwZW5kJyAmJlxuICAgICAgKHZlcmlmaWNhdGlvblNldHRpbmdzLnNpZ25hdHVyZUluZGV4IHx8IHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlSW5kZXggYW5kIHB1YmxpY0tleSBwYXJhbWV0ZXJzIG5vdCBzdXBwb3J0ZWQgZm9yIHRhcHJvb3RLZXlQYXRoU3BlbmRgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmVJbmRleCBwYXJhbWV0ZXIgbm90IHN1cHBvcnRlZCBmb3IgdGFwcm9vdFNjcmlwdFBhdGhTcGVuZGApO1xuICAgIH1cblxuICAgIGlmICghcHJldk91dHB1dHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJldk91dHB1dHMgbm90IHNldGApO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3V0cHV0cy5sZW5ndGggIT09IHRyYW5zYWN0aW9uLmlucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJldk91dHB1dHMgbGVuZ3RoICR7cHJldk91dHB1dHMubGVuZ3RofSwgZXhwZWN0ZWQgJHt0cmFuc2FjdGlvbi5pbnMubGVuZ3RofWApO1xuICAgIH1cbiAgfVxuXG4gIGxldCBwdWJsaWNLZXlzOiBCdWZmZXJbXTtcbiAgaWYgKHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAndGFwcm9vdEtleVBhdGhTcGVuZCcpIHtcbiAgICBpZiAoIXByZXZPdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZXZPdXRwdXRzIG5vdCBzZXRgKTtcbiAgICB9XG4gICAgcHVibGljS2V5cyA9IFtnZXRUYXByb290T3V0cHV0S2V5KHByZXZPdXRwdXRzW2lucHV0SW5kZXhdLnNjcmlwdCldO1xuICB9IGVsc2Uge1xuICAgIHB1YmxpY0tleXMgPSBwYXJzZWRTY3JpcHQucHVibGljS2V5cy5maWx0ZXIoXG4gICAgICAoYnVmKSA9PlxuICAgICAgICB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkuZXF1YWxzKGJ1ZikgfHxcbiAgICAgICAgdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5LnNsaWNlKDEpLmVxdWFscyhidWYpXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHNpZ25hdHVyZXMgPSBwYXJzZWRTY3JpcHQuc2lnbmF0dXJlc1xuICAgIC5maWx0ZXIoKHMpID0+IHMgJiYgcy5sZW5ndGgpXG4gICAgLmZpbHRlcigocywgaSkgPT4gdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggPT09IHVuZGVmaW5lZCB8fCB2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCA9PT0gaSk7XG5cbiAgcmV0dXJuIHNpZ25hdHVyZXMubWFwKChzaWduYXR1cmVCdWZmZXIpOiBTaWduYXR1cmVWZXJpZmljYXRpb24gPT4ge1xuICAgIGlmIChzaWduYXR1cmVCdWZmZXIgPT09IDAgfHwgc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgc2lnbmVkQnk6IHVuZGVmaW5lZCwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbiAgICB9XG5cbiAgICBsZXQgaGFzaFR5cGUgPSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQ7XG5cbiAgICBpZiAoc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgIGhhc2hUeXBlID0gc2lnbmF0dXJlQnVmZmVyW3NpZ25hdHVyZUJ1ZmZlci5sZW5ndGggLSAxXTtcbiAgICAgIHNpZ25hdHVyZUJ1ZmZlciA9IHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAndGFwcm9vdFNjcmlwdFBhdGhTcGVuZCcpIHtcbiAgICAgIGlmICghcHJldk91dHB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmV2T3V0cHV0cyBub3Qgc2V0YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvbnRyb2xCbG9jaywgcHViU2NyaXB0IH0gPSBwYXJzZWRTY3JpcHQ7XG4gICAgICBjb25zdCBsZWFmSGFzaCA9IHRhcHJvb3QuZ2V0VGFwbGVhZkhhc2goZWNjTGliLCBjb250cm9sQmxvY2ssIHB1YlNjcmlwdCk7XG4gICAgICBjb25zdCBzaWduYXR1cmVIYXNoID0gdHJhbnNhY3Rpb24uaGFzaEZvcldpdG5lc3NWMShcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgcHJldk91dHB1dHMubWFwKCh7IHNjcmlwdCB9KSA9PiBzY3JpcHQpLFxuICAgICAgICBwcmV2T3V0cHV0cy5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpLFxuICAgICAgICBoYXNoVHlwZSxcbiAgICAgICAgbGVhZkhhc2hcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNpZ25lZEJ5ID0gcHVibGljS2V5cy5maWx0ZXIoXG4gICAgICAgIChrKSA9PiBCdWZmZXIuaXNCdWZmZXIoc2lnbmF0dXJlQnVmZmVyKSAmJiBlY2NMaWIudmVyaWZ5U2Nobm9ycihzaWduYXR1cmVIYXNoLCBrLCBzaWduYXR1cmVCdWZmZXIpXG4gICAgICApO1xuXG4gICAgICBpZiAoc2lnbmVkQnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHNpZ25lZEJ5OiB1bmRlZmluZWQsIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmVkQnkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IHNpZ25lZEJ5OiBzaWduZWRCeVswXSwgc2lnbmF0dXJlOiBzaWduYXR1cmVCdWZmZXIgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgaWxsZWdhbCBzdGF0ZTogc2lnbmVkIGJ5IG11bHRpcGxlIHB1YmxpYyBrZXlzYCk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnKSB7XG4gICAgICBpZiAoIXByZXZPdXRwdXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJldk91dHB1dHMgbm90IHNldGApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JXaXRuZXNzVjEoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHByZXZPdXRwdXRzLm1hcCgoeyBzY3JpcHQgfSkgPT4gc2NyaXB0KSxcbiAgICAgICAgcHJldk91dHB1dHMubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKSxcbiAgICAgICAgaGFzaFR5cGVcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHQgPSBlY2NMaWIudmVyaWZ5U2Nobm9ycihzaWduYXR1cmVIYXNoLCBwdWJsaWNLZXlzWzBdLCBzaWduYXR1cmVCdWZmZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICA/IHsgc2lnbmVkQnk6IHB1YmxpY0tleXNbMF0sIHNpZ25hdHVyZTogc2lnbmF0dXJlQnVmZmVyIH1cbiAgICAgICAgOiB7IHNpZ25lZEJ5OiB1bmRlZmluZWQsIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNsaWNlIHRoZSBsYXN0IGJ5dGUgZnJvbSB0aGUgc2lnbmF0dXJlIGhhc2ggaW5wdXQgYmVjYXVzZSBpdCdzIHRoZSBoYXNoIHR5cGVcbiAgICAgIGNvbnN0IHsgc2lnbmF0dXJlLCBoYXNoVHlwZSB9ID0gU2NyaXB0U2lnbmF0dXJlLmRlY29kZShzaWduYXR1cmVCdWZmZXIpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25IYXNoID1cbiAgICAgICAgcGFyc2VkU2NyaXB0LnNjcmlwdFR5cGUgPT09ICdwMnNoUDJ3c2gnIHx8IHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAncDJ3c2gnXG4gICAgICAgICAgPyB0cmFuc2FjdGlvbi5oYXNoRm9yV2l0bmVzc1YwKGlucHV0SW5kZXgsIHBhcnNlZFNjcmlwdC5wdWJTY3JpcHQsIGFtb3VudCwgaGFzaFR5cGUpXG4gICAgICAgICAgOiB0cmFuc2FjdGlvbi5oYXNoRm9yU2lnbmF0dXJlQnlOZXR3b3JrKGlucHV0SW5kZXgsIHBhcnNlZFNjcmlwdC5wdWJTY3JpcHQsIGFtb3VudCwgaGFzaFR5cGUpO1xuICAgICAgY29uc3Qgc2lnbmVkQnkgPSBwdWJsaWNLZXlzLmZpbHRlcigocHVibGljS2V5KSA9PlxuICAgICAgICBlY2NMaWIudmVyaWZ5KFxuICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgIC8qXG4gICAgICAgICAgICBTdHJpY3QgdmVyaWZpY2F0aW9uIChyZXF1aXJlIGxvd2VyLVMgdmFsdWUpLCBhcyByZXF1aXJlZCBieSBCSVAtMDE0NlxuICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0Ni5tZWRpYXdpa2lcbiAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luLWNvcmUvc2VjcDI1NmsxL2Jsb2IvYWM4M2JlMzMvaW5jbHVkZS9zZWNwMjU2azEuaCNMNDc4LUw1MDhcbiAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvdGlueS1zZWNwMjU2azEvYmxvYi92MS4xLjYvanMuanMjTDIzMS1MMjMzXG4gICAgICAgICAgKi9cbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIGlmIChzaWduZWRCeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmVkQnk6IHVuZGVmaW5lZCwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduZWRCeS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmVkQnk6IHNpZ25lZEJ5WzBdLCBzaWduYXR1cmU6IHNpZ25hdHVyZUJ1ZmZlciB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbGxlZ2FsIHN0YXRlOiBzaWduZWQgYnkgbXVsdGlwbGUgcHVibGljIGtleXNgKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSB7QHNlZSB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5c30gaW5zdGVhZFxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gaW5wdXRJbmRleFxuICogQHBhcmFtIGFtb3VudFxuICogQHBhcmFtIHZlcmlmaWNhdGlvblNldHRpbmdzIC0gaWYgcHVibGljS2V5IGlzIHNwZWNpZmllZCwgcmV0dXJucyB0cnVlIGlmZiBhbnkgc2lnbmF0dXJlIGlzIHNpZ25lZCBieSBwdWJsaWNLZXkuXG4gKiBAcGFyYW0gcHJldk91dHB1dHMgLSBtdXN0IGJlIHNldCBmb3IgcDJ0ciB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZTxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHJhbnNhY3Rpb246IFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgaW5wdXRJbmRleDogbnVtYmVyLFxuICBhbW91bnQ6IFROdW1iZXIsXG4gIHZlcmlmaWNhdGlvblNldHRpbmdzOiBWZXJpZmljYXRpb25TZXR0aW5ncyA9IHt9LFxuICBwcmV2T3V0cHV0cz86IFR4T3V0cHV0PFROdW1iZXI+W11cbik6IGJvb2xlYW4ge1xuICBjb25zdCBzaWduYXR1cmVWZXJpZmljYXRpb25zID0gZ2V0U2lnbmF0dXJlVmVyaWZpY2F0aW9ucyhcbiAgICB0cmFuc2FjdGlvbixcbiAgICBpbnB1dEluZGV4LFxuICAgIGFtb3VudCxcbiAgICB2ZXJpZmljYXRpb25TZXR0aW5ncyxcbiAgICBwcmV2T3V0cHV0c1xuICApLmZpbHRlcihcbiAgICAodikgPT5cbiAgICAgIC8vIElmIG5vIHB1YmxpY0tleSBpcyBzZXQgaW4gdmVyaWZpY2F0aW9uU2V0dGluZ3MsIGFsbCBzaWduYXR1cmVzIG11c3QgYmUgdmFsaWQuXG4gICAgICAvLyBPdGhlcndpc2UsIGEgc2luZ2xlIHZhbGlkIHNpZ25hdHVyZSBieSB0aGUgc3BlY2lmaWVkIHB1YmtleSBpcyBzdWZmaWNpZW50LlxuICAgICAgdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICh2LnNpZ25lZEJ5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleS5lcXVhbHModi5zaWduZWRCeSkgfHxcbiAgICAgICAgICB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkuc2xpY2UoMSkuZXF1YWxzKHYuc2lnbmVkQnkpKSlcbiAgKTtcblxuICByZXR1cm4gc2lnbmF0dXJlVmVyaWZpY2F0aW9ucy5sZW5ndGggPiAwICYmIHNpZ25hdHVyZVZlcmlmaWNhdGlvbnMuZXZlcnkoKHYpID0+IHYuc2lnbmVkQnkgIT09IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHZcbiAqIEBwYXJhbSBwdWJsaWNLZXlcbiAqIEByZXR1cm4gdHJ1ZSBpZmYgc2lnbmF0dXJlIGlzIGJ5IHB1YmxpY0tleSAob3IgeG9ubHkgdmFyaWFudCBvZiBwdWJsaWNLZXkpXG4gKi9cbmZ1bmN0aW9uIGlzU2lnbmF0dXJlQnlQdWJsaWNLZXkodjogU2lnbmF0dXJlVmVyaWZpY2F0aW9uLCBwdWJsaWNLZXk6IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgICEhdi5zaWduZWRCeSAmJlxuICAgICh2LnNpZ25lZEJ5LmVxdWFscyhwdWJsaWNLZXkpIHx8XG4gICAgICAvKiBmb3IgcDJ0ciBzaWduYXR1cmVzLCB3ZSBwYXNzIHRoZSBwdWJrZXkgaW4gMzMtYnl0ZSBmb3JtYXQgcmVjb3ZlciBpdCBmcm9tIHRoZSBzaWduYXR1cmUgaW4gMzItYnl0ZSBmb3JtYXQgKi9cbiAgICAgIChwdWJsaWNLZXkubGVuZ3RoID09PSAzMyAmJiBpc1NpZ25hdHVyZUJ5UHVibGljS2V5KHYsIHB1YmxpY0tleS5zbGljZSgxKSkpKVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGlucHV0SW5kZXhcbiAqIEBwYXJhbSBwcmV2T3V0cHV0c1xuICogQHBhcmFtIHB1YmxpY0tleXNcbiAqIEByZXR1cm4gYXJyYXkgd2l0aCBzaWduYXR1cmUgY29ycmVzcG9uZGluZyB0byBuLXRoIGtleSwgdW5kZWZpbmVkIGlmIG5vIG1hdGNoIGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduYXR1cmVzV2l0aFB1YmxpY0tleXM8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHRyYW5zYWN0aW9uOiBVdHhvVHJhbnNhY3Rpb248VE51bWJlcj4sXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgcHJldk91dHB1dHM6IFR4T3V0cHV0PFROdW1iZXI+W10sXG4gIHB1YmxpY0tleXM6IEJ1ZmZlcltdXG4pOiBBcnJheTxCdWZmZXIgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHByZXZPdXRwdXRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgbGVuZ3RoIG11c3QgbWF0Y2ggcHJldk91dHB1dHMgbGVuZ3RoYCk7XG4gIH1cblxuICBjb25zdCBzaWduYXR1cmVWZXJpZmljYXRpb25zID0gZ2V0U2lnbmF0dXJlVmVyaWZpY2F0aW9ucyhcbiAgICB0cmFuc2FjdGlvbixcbiAgICBpbnB1dEluZGV4LFxuICAgIHByZXZPdXRwdXRzW2lucHV0SW5kZXhdLnZhbHVlLFxuICAgIHt9LFxuICAgIHByZXZPdXRwdXRzXG4gICk7XG5cbiAgcmV0dXJuIHB1YmxpY0tleXMubWFwKChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCB2ID0gc2lnbmF0dXJlVmVyaWZpY2F0aW9ucy5maW5kKCh2KSA9PiBpc1NpZ25hdHVyZUJ5UHVibGljS2V5KHYsIHB1YmxpY0tleSkpO1xuICAgIHJldHVybiB2ID8gdi5zaWduYXR1cmUgOiB1bmRlZmluZWQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGlucHV0SW5kZXhcbiAqIEBwYXJhbSBwcmV2T3V0cHV0cyAtIHRyYW5zYWN0aW9uIG91dHB1dHMgZm9yIGlucHV0c1xuICogQHBhcmFtIHB1YmxpY0tleXMgLSBwdWJsaWMga2V5cyB0byBjaGVjayBzaWduYXR1cmVzIGZvclxuICogQHJldHVybiBhcnJheSBvZiBib29sZWFucyBpbmRpY2F0aW5nIGEgdmFsaWQgc2lnbmF0dXJlIGZvciBldmVyeSBwdWJrZXkgaW4gX3B1YmxpY0tleXNfXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5czxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHJhbnNhY3Rpb246IFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgaW5wdXRJbmRleDogbnVtYmVyLFxuICBwcmV2T3V0cHV0czogVHhPdXRwdXQ8VE51bWJlcj5bXSxcbiAgcHVibGljS2V5czogQnVmZmVyW11cbik6IGJvb2xlYW5bXSB7XG4gIHJldHVybiBnZXRTaWduYXR1cmVzV2l0aFB1YmxpY0tleXModHJhbnNhY3Rpb24sIGlucHV0SW5kZXgsIHByZXZPdXRwdXRzLCBwdWJsaWNLZXlzKS5tYXAoKHMpID0+IHMgIT09IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogV3JhcHBlciBmb3Ige0BzZWUgdmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleXN9IGZvciBzaW5nbGUgcHVia2V5XG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gcHJldk91dHB1dHNcbiAqIEBwYXJhbSBwdWJsaWNLZXlcbiAqIEByZXR1cm4gdHJ1ZSBpZmYgc2lnbmF0dXJlIGlzIHZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0cmFuc2FjdGlvbjogVXR4b1RyYW5zYWN0aW9uPFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHByZXZPdXRwdXRzOiBUeE91dHB1dDxUTnVtYmVyPltdLFxuICBwdWJsaWNLZXk6IEJ1ZmZlclxuKTogYm9vbGVhbiB7XG4gIHJldHVybiB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5cyh0cmFuc2FjdGlvbiwgaW5wdXRJbmRleCwgcHJldk91dHB1dHMsIFtwdWJsaWNLZXldKVswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRTaWdIYXNoKG5ldHdvcms6IE5ldHdvcmssIHNjcmlwdFR5cGU/OiBTY3JpcHRUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoIChnZXRNYWlubmV0KG5ldHdvcmspKSB7XG4gICAgY2FzZSBuZXR3b3Jrcy5iaXRjb2luY2FzaDpcbiAgICBjYXNlIG5ldHdvcmtzLmJpdGNvaW5zdjpcbiAgICBjYXNlIG5ldHdvcmtzLmJpdGNvaW5nb2xkOlxuICAgIGNhc2UgbmV0d29ya3MuZWNhc2g6XG4gICAgICByZXR1cm4gVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwgfCBVdHhvVHJhbnNhY3Rpb24uU0lHSEFTSF9GT1JLSUQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAoc2NyaXB0VHlwZSkge1xuICAgICAgICBjYXNlICdwMnRyJzpcbiAgICAgICAgY2FzZSAncDJ0ck11c2lnMic6XG4gICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gICAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25JbnB1dFAyc2hQMnBrPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0eEJ1aWxkZXI6IFV0eG9UcmFuc2FjdGlvbkJ1aWxkZXI8VE51bWJlcj4sXG4gIHZpbjogbnVtYmVyLFxuICBrZXlQYWlyOiBCSVAzMkludGVyZmFjZVxuKTogdm9pZCB7XG4gIGNvbnN0IHByZXZPdXRTY3JpcHRUeXBlID0gJ3Ayc2gtcDJwayc7XG4gIGNvbnN0IHsgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0IH0gPSBjcmVhdGVPdXRwdXRTY3JpcHRQMnNoUDJwayhrZXlQYWlyLnB1YmxpY0tleSk7XG4gIGtleVBhaXIubmV0d29yayA9IHR4QnVpbGRlci5uZXR3b3JrO1xuXG4gIHR4QnVpbGRlci5zaWduKHtcbiAgICB2aW4sXG4gICAgcHJldk91dFNjcmlwdFR5cGUsXG4gICAga2V5UGFpcixcbiAgICBoYXNoVHlwZTogZ2V0RGVmYXVsdFNpZ0hhc2godHhCdWlsZGVyLm5ldHdvcmsgYXMgTmV0d29yayksXG4gICAgcmVkZWVtU2NyaXB0LFxuICAgIHdpdG5lc3NTY3JpcHQsXG4gICAgd2l0bmVzc1ZhbHVlOiB1bmRlZmluZWQsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbklucHV0Mk9mMzxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHhCdWlsZGVyOiBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyPFROdW1iZXI+LFxuICB2aW46IG51bWJlcixcbiAgc2NyaXB0VHlwZTogU2NyaXB0VHlwZTJPZjMsXG4gIHB1YmtleXM6IFRyaXBsZTxCdWZmZXI+LFxuICBrZXlQYWlyOiBCSVAzMkludGVyZmFjZSxcbiAgY29zaWduZXI6IEJ1ZmZlcixcbiAgYW1vdW50OiBUTnVtYmVyXG4pOiB2b2lkIHtcbiAgbGV0IGNvbnRyb2xCbG9jaztcbiAgbGV0IHJlZGVlbVNjcmlwdDtcbiAgbGV0IHdpdG5lc3NTY3JpcHQ7XG5cbiAgY29uc3QgcHJldk91dFNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlMk9mM0FzUHJldk91dFR5cGUoc2NyaXB0VHlwZSk7XG4gIGlmIChzY3JpcHRUeXBlID09PSAncDJ0cicpIHtcbiAgICAoeyB3aXRuZXNzU2NyaXB0LCBjb250cm9sQmxvY2sgfSA9IGNyZWF0ZVNwZW5kU2NyaXB0UDJ0cihwdWJrZXlzLCBba2V5UGFpci5wdWJsaWNLZXksIGNvc2lnbmVyXSkpO1xuICB9IGVsc2Uge1xuICAgICh7IHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdCB9ID0gY3JlYXRlT3V0cHV0U2NyaXB0Mm9mMyhwdWJrZXlzLCBzY3JpcHRUeXBlKSk7XG4gIH1cblxuICBrZXlQYWlyLm5ldHdvcmsgPSB0eEJ1aWxkZXIubmV0d29yaztcblxuICB0eEJ1aWxkZXIuc2lnbih7XG4gICAgdmluLFxuICAgIHByZXZPdXRTY3JpcHRUeXBlLFxuICAgIGtleVBhaXIsXG4gICAgaGFzaFR5cGU6IGdldERlZmF1bHRTaWdIYXNoKHR4QnVpbGRlci5uZXR3b3JrIGFzIE5ldHdvcmssIHNjcmlwdFR5cGUpLFxuICAgIHJlZGVlbVNjcmlwdCxcbiAgICB3aXRuZXNzU2NyaXB0LFxuICAgIHdpdG5lc3NWYWx1ZTogYW1vdW50LFxuICAgIGNvbnRyb2xCbG9jayxcbiAgfSk7XG59XG4iXX0=