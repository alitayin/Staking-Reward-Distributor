"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultWalletKeys = exports.getDefaultCosigner = exports.getKeyName = exports.getUncompressedKeyTriple = exports.getKeyTriple = exports.getKey = void 0;
const bip32_1 = require("bip32");
const crypto = require("crypto");
const bitgo_1 = require("../bitgo");
const noble_ecc_1 = require("../noble_ecc");
const networks_1 = require("../networks");
const bip32 = bip32_1.BIP32Factory(noble_ecc_1.ecc);
function getKey(seed) {
    return bip32.fromSeed(crypto.createHash('sha256').update(seed).digest());
}
exports.getKey = getKey;
function getKeyTriple(seed) {
    return [getKey(seed + '.0'), getKey(seed + '.1'), getKey(seed + '.2')];
}
exports.getKeyTriple = getKeyTriple;
function getUncompressedKey(input) {
    // Using input for deterministic randomness
    return noble_ecc_1.ECPair.makeRandom({
        compressed: false,
        network: networks_1.networks.testnet,
        rng: () => {
            return Buffer.alloc(32, input);
        },
    });
}
function getUncompressedKeyTriple(inputs) {
    return [getUncompressedKey(inputs[0]), getUncompressedKey(inputs[1]), getUncompressedKey(inputs[2])];
}
exports.getUncompressedKeyTriple = getUncompressedKeyTriple;
function getKeyName(triple, k) {
    return ['user', 'backup', 'bitgo'][triple.indexOf(k)];
}
exports.getKeyName = getKeyName;
function getDefaultCosigner(keyset, signer) {
    const eq = (a, b) => a === b || (Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.equals(b));
    const [user, backup, bitgo] = keyset;
    if (eq(signer, user)) {
        return bitgo;
    }
    if (eq(signer, backup)) {
        return bitgo;
    }
    if (eq(signer, bitgo)) {
        return user;
    }
    throw new Error(`signer not in pubkeys`);
}
exports.getDefaultCosigner = getDefaultCosigner;
function getDefaultWalletKeys() {
    return new bitgo_1.RootWalletKeys(getKeyTriple('default'));
}
exports.getDefaultWalletKeys = getDefaultWalletKeys;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90ZXN0dXRpbC9rZXlzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUErRDtBQUMvRCxpQ0FBaUM7QUFHakMsb0NBQTBDO0FBQzFDLDRDQUE0RDtBQUM1RCwwQ0FBdUM7QUFFdkMsTUFBTSxLQUFLLEdBQWEsb0JBQVksQ0FBQyxlQUFHLENBQUMsQ0FBQztBQUsxQyxTQUFnQixNQUFNLENBQUMsSUFBWTtJQUNqQyxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUMzRSxDQUFDO0FBRkQsd0JBRUM7QUFFRCxTQUFnQixZQUFZLENBQUMsSUFBWTtJQUN2QyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN6RSxDQUFDO0FBRkQsb0NBRUM7QUFFRCxTQUFTLGtCQUFrQixDQUFDLEtBQUs7SUFDL0IsMkNBQTJDO0lBQzNDLE9BQU8sa0JBQU0sQ0FBQyxVQUFVLENBQUM7UUFDdkIsVUFBVSxFQUFFLEtBQUs7UUFDakIsT0FBTyxFQUFFLG1CQUFRLENBQUMsT0FBTztRQUN6QixHQUFHLEVBQUUsR0FBVyxFQUFFO1lBQ2hCLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDakMsQ0FBQztLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFnQix3QkFBd0IsQ0FBQyxNQUFzQjtJQUM3RCxPQUFPLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RyxDQUFDO0FBRkQsNERBRUM7QUFFRCxTQUFnQixVQUFVLENBQUMsTUFBOEIsRUFBRSxDQUFpQjtJQUMxRSxPQUFPLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUZELGdDQUVDO0FBRUQsU0FBZ0Isa0JBQWtCLENBQUksTUFBaUIsRUFBRSxNQUFTO0lBQ2hFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBSSxFQUFFLENBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEcsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDO0lBQ3JDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRTtRQUNwQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBYkQsZ0RBYUM7QUFFRCxTQUFnQixvQkFBb0I7SUFDbEMsT0FBTyxJQUFJLHNCQUFjLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDckQsQ0FBQztBQUZELG9EQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQklQMzJBUEksIEJJUDMyRmFjdG9yeSwgQklQMzJJbnRlcmZhY2UgfSBmcm9tICdiaXAzMic7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuaW1wb3J0IHsgVHJpcGxlIH0gZnJvbSAnLi4vYml0Z28nO1xuaW1wb3J0IHsgUm9vdFdhbGxldEtleXMgfSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgeyBlY2MsIEVDUGFpciwgRUNQYWlySW50ZXJmYWNlIH0gZnJvbSAnLi4vbm9ibGVfZWNjJztcbmltcG9ydCB7IG5ldHdvcmtzIH0gZnJvbSAnLi4vbmV0d29ya3MnO1xuXG5jb25zdCBiaXAzMjogQklQMzJBUEkgPSBCSVAzMkZhY3RvcnkoZWNjKTtcblxuZXhwb3J0IHR5cGUgS2V5VHJpcGxlID0gVHJpcGxlPEJJUDMySW50ZXJmYWNlPjtcbmV4cG9ydCB0eXBlIFVuY29tcHJlc3NlZEtleVRyaXBsZSA9IFRyaXBsZTxFQ1BhaXJJbnRlcmZhY2U+O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5KHNlZWQ6IHN0cmluZyk6IEJJUDMySW50ZXJmYWNlIHtcbiAgcmV0dXJuIGJpcDMyLmZyb21TZWVkKGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2VlZCkuZGlnZXN0KCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5VHJpcGxlKHNlZWQ6IHN0cmluZyk6IEtleVRyaXBsZSB7XG4gIHJldHVybiBbZ2V0S2V5KHNlZWQgKyAnLjAnKSwgZ2V0S2V5KHNlZWQgKyAnLjEnKSwgZ2V0S2V5KHNlZWQgKyAnLjInKV07XG59XG5cbmZ1bmN0aW9uIGdldFVuY29tcHJlc3NlZEtleShpbnB1dCkge1xuICAvLyBVc2luZyBpbnB1dCBmb3IgZGV0ZXJtaW5pc3RpYyByYW5kb21uZXNzXG4gIHJldHVybiBFQ1BhaXIubWFrZVJhbmRvbSh7XG4gICAgY29tcHJlc3NlZDogZmFsc2UsXG4gICAgbmV0d29yazogbmV0d29ya3MudGVzdG5ldCxcbiAgICBybmc6ICgpOiBCdWZmZXIgPT4ge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygzMiwgaW5wdXQpO1xuICAgIH0sXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5jb21wcmVzc2VkS2V5VHJpcGxlKGlucHV0czogVHJpcGxlPG51bWJlcj4pOiBVbmNvbXByZXNzZWRLZXlUcmlwbGUge1xuICByZXR1cm4gW2dldFVuY29tcHJlc3NlZEtleShpbnB1dHNbMF0pLCBnZXRVbmNvbXByZXNzZWRLZXkoaW5wdXRzWzFdKSwgZ2V0VW5jb21wcmVzc2VkS2V5KGlucHV0c1syXSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5TmFtZSh0cmlwbGU6IFRyaXBsZTxCSVAzMkludGVyZmFjZT4sIGs6IEJJUDMySW50ZXJmYWNlKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIFsndXNlcicsICdiYWNrdXAnLCAnYml0Z28nXVt0cmlwbGUuaW5kZXhPZihrKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q29zaWduZXI8VD4oa2V5c2V0OiBUcmlwbGU8VD4sIHNpZ25lcjogVCk6IFQge1xuICBjb25zdCBlcSA9IChhOiBULCBiOiBUKSA9PiBhID09PSBiIHx8IChCdWZmZXIuaXNCdWZmZXIoYSkgJiYgQnVmZmVyLmlzQnVmZmVyKGIpICYmIGEuZXF1YWxzKGIpKTtcbiAgY29uc3QgW3VzZXIsIGJhY2t1cCwgYml0Z29dID0ga2V5c2V0O1xuICBpZiAoZXEoc2lnbmVyLCB1c2VyKSkge1xuICAgIHJldHVybiBiaXRnbztcbiAgfVxuICBpZiAoZXEoc2lnbmVyLCBiYWNrdXApKSB7XG4gICAgcmV0dXJuIGJpdGdvO1xuICB9XG4gIGlmIChlcShzaWduZXIsIGJpdGdvKSkge1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgc2lnbmVyIG5vdCBpbiBwdWJrZXlzYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0V2FsbGV0S2V5cygpOiBSb290V2FsbGV0S2V5cyB7XG4gIHJldHVybiBuZXcgUm9vdFdhbGxldEtleXMoZ2V0S2V5VHJpcGxlKCdkZWZhdWx0JykpO1xufVxuIl19