"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructTxnBuilder = exports.signAllTxnInputs = exports.signTxnInput = exports.getTxnSigners = exports.toTxnUnspent = exports.txnOutputScriptTypes = exports.txnInputScriptTypes = void 0;
const assert = require("assert");
const outputScripts_1 = require("../bitgo/outputScripts");
const bitgo_1 = require("../bitgo");
const mock_1 = require("./mock");
/**
 * array of supported input script types.
 */
exports.txnInputScriptTypes = ['p2sh', 'p2shP2wsh', 'p2wsh', 'p2tr', outputScripts_1.scriptTypeP2shP2pk];
/**
 * array of supported output script types.
 */
exports.txnOutputScriptTypes = outputScripts_1.scriptTypes2Of3;
/**
 * create unspent object from input script type, index, network and root wallet key.
 */
function toTxnUnspent(input, index, network, rootWalletKeys) {
    if (input.scriptType === 'p2shP2pk') {
        return mock_1.mockReplayProtectionUnspent(network, input.value, { key: rootWalletKeys['user'], vout: index });
    }
    else {
        return mock_1.mockWalletUnspent(network, input.value, {
            chain: bitgo_1.getInternalChainCode(input.scriptType),
            vout: index,
            keys: rootWalletKeys,
            index,
        });
    }
}
exports.toTxnUnspent = toTxnUnspent;
/**
 * returns signer and cosigner names for TxnInputScriptType.
 * user and undefined as signer and cosigner respectively for p2shP2pk.
 * user and bitgo as signer and cosigner respectively for other input script types.
 */
function getTxnSigners(inputType) {
    return {
        signerName: 'user',
        cosignerName: inputType === 'p2shP2pk' ? undefined : 'bitgo',
    };
}
exports.getTxnSigners = getTxnSigners;
/**
 * signs with first or second signature for single input.
 * p2shP2pk is signed only with first sign.
 */
function signTxnInput(txb, input, inputIndex, rootWalletKeys, sign, signers) {
    const { signerName, cosignerName } = signers ? signers : getTxnSigners(input.scriptType);
    const unspent = toTxnUnspent(input, inputIndex, txb.network, rootWalletKeys);
    if (sign === 'halfsigned') {
        if (input.scriptType === 'p2shP2pk') {
            bitgo_1.signInputP2shP2pk(txb, inputIndex, rootWalletKeys[signerName]);
        }
        else if (bitgo_1.isWalletUnspent(unspent) && cosignerName) {
            bitgo_1.signInputWithUnspent(txb, inputIndex, unspent, bitgo_1.WalletUnspentSigner.from(rootWalletKeys, rootWalletKeys[signerName], rootWalletKeys[cosignerName]));
        }
    }
    if (bitgo_1.isWalletUnspent(unspent) && sign === 'fullsigned' && cosignerName) {
        bitgo_1.signInputWithUnspent(txb, inputIndex, unspent, bitgo_1.WalletUnspentSigner.from(rootWalletKeys, rootWalletKeys[cosignerName], rootWalletKeys[signerName]));
    }
}
exports.signTxnInput = signTxnInput;
/**
 * signs with first or second signature for all inputs.
 * p2shP2pk is signed only with first sign.
 */
function signAllTxnInputs(txb, inputs, rootWalletKeys, sign, signers) {
    inputs.forEach((input, index) => {
        signTxnInput(txb, input, index, rootWalletKeys, sign, signers);
    });
}
exports.signAllTxnInputs = signAllTxnInputs;
/**
 * construct transaction for given inputs, outputs, network and root wallet keys.
 */
function constructTxnBuilder(inputs, outputs, network, rootWalletKeys, sign, signers) {
    const totalInputAmount = inputs.reduce((sum, input) => sum + BigInt(input.value), BigInt(0));
    const outputInputAmount = outputs.reduce((sum, output) => sum + BigInt(output.value), BigInt(0));
    assert(totalInputAmount >= outputInputAmount, 'total output can not exceed total input');
    assert(!outputs.some((o) => (o.scriptType && o.address) || (!o.scriptType && !o.address)), 'only either output script type or address should be provided');
    const txb = bitgo_1.createTransactionBuilderForNetwork(network);
    const unspents = inputs.map((input, i) => toTxnUnspent(input, i, network, rootWalletKeys));
    unspents.forEach((u, i) => {
        bitgo_1.addToTransactionBuilder(txb, u);
    });
    outputs.forEach((output, i) => {
        const address = output.scriptType
            ? bitgo_1.getWalletAddress(rootWalletKeys, output.isInternalAddress ? bitgo_1.getInternalChainCode(output.scriptType) : bitgo_1.getExternalChainCode(output.scriptType), i, network)
            : output.address;
        if (!address) {
            throw new Error('address is missing');
        }
        txb.addOutput(address, output.value);
    });
    if (sign === 'unsigned') {
        return txb;
    }
    signAllTxnInputs(txb, inputs, rootWalletKeys, 'halfsigned', signers);
    if (sign === 'fullsigned') {
        signAllTxnInputs(txb, inputs, rootWalletKeys, sign, signers);
    }
    return txb;
}
exports.constructTxnBuilder = constructTxnBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdGVzdHV0aWwvdHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBRWpDLDBEQUF5RztBQUN6RyxvQ0Fja0I7QUFFbEIsaUNBQXdFO0FBMkJ4RTs7R0FFRztBQUNVLFFBQUEsbUJBQW1CLEdBQUcsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsa0NBQWtCLENBQVUsQ0FBQztBQUV2Rzs7R0FFRztBQUNVLFFBQUEsb0JBQW9CLEdBQUcsK0JBQWUsQ0FBQztBQUVwRDs7R0FFRztBQUNILFNBQWdCLFlBQVksQ0FDMUIsS0FBd0IsRUFDeEIsS0FBYSxFQUNiLE9BQWdCLEVBQ2hCLGNBQThCO0lBRTlCLElBQUksS0FBSyxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7UUFDbkMsT0FBTyxrQ0FBMkIsQ0FBVSxPQUFPLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEdBQUcsRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDakg7U0FBTTtRQUNMLE9BQU8sd0JBQWlCLENBQVUsT0FBTyxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUU7WUFDdEQsS0FBSyxFQUFFLDRCQUFvQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7WUFDN0MsSUFBSSxFQUFFLEtBQUs7WUFDWCxJQUFJLEVBQUUsY0FBYztZQUNwQixLQUFLO1NBQ04sQ0FBQyxDQUFDO0tBQ0o7QUFDSCxDQUFDO0FBaEJELG9DQWdCQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixhQUFhLENBQUMsU0FBNkI7SUFDekQsT0FBTztRQUNMLFVBQVUsRUFBRSxNQUFNO1FBQ2xCLFlBQVksRUFBRSxTQUFTLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxD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QU0sRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXJFLElBQUksSUFBSSxLQUFLLFlBQVksRUFBRTtRQUN6QixnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDOUQ7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFsREQsa0RBa0RDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7IFNjcmlwdFR5cGUsIFNjcmlwdFR5cGUyT2YzLCBzY3JpcHRUeXBlUDJzaFAycGssIHNjcmlwdFR5cGVzMk9mMyB9IGZyb20gJy4uL2JpdGdvL291dHB1dFNjcmlwdHMnO1xuaW1wb3J0IHtcbiAgZ2V0RXh0ZXJuYWxDaGFpbkNvZGUsXG4gIGlzV2FsbGV0VW5zcGVudCxcbiAgS2V5TmFtZSxcbiAgZ2V0SW50ZXJuYWxDaGFpbkNvZGUsXG4gIFJvb3RXYWxsZXRLZXlzLFxuICBVbnNwZW50LFxuICBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyLFxuICBjcmVhdGVUcmFuc2FjdGlvbkJ1aWxkZXJGb3JOZXR3b3JrLFxuICBhZGRUb1RyYW5zYWN0aW9uQnVpbGRlcixcbiAgZ2V0V2FsbGV0QWRkcmVzcyxcbiAgc2lnbklucHV0UDJzaFAycGssXG4gIHNpZ25JbnB1dFdpdGhVbnNwZW50LFxuICBXYWxsZXRVbnNwZW50U2lnbmVyLFxufSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSAnLi4vbmV0d29ya3MnO1xuaW1wb3J0IHsgbW9ja1JlcGxheVByb3RlY3Rpb25VbnNwZW50LCBtb2NrV2FsbGV0VW5zcGVudCB9IGZyb20gJy4vbW9jayc7XG5cbi8qKlxuICogaW5wdXQgc2NyaXB0IHR5cGUgYW5kIHZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBUeG5JbnB1dFNjcmlwdFR5cGUgPSBFeGNsdWRlPFNjcmlwdFR5cGUsICdwMnRyTXVzaWcyJz47XG5leHBvcnQgdHlwZSBUeG5PdXRwdXRTY3JpcHRUeXBlID0gU2NyaXB0VHlwZTJPZjM7XG5cbi8qKlxuICogb3V0cHV0IHNjcmlwdCB0eXBlIGFuZCB2YWx1ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFR4bklucHV0PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+IHtcbiAgc2NyaXB0VHlwZTogVHhuSW5wdXRTY3JpcHRUeXBlO1xuICB2YWx1ZTogVE51bWJlcjtcbn1cblxuLyoqXG4gKiBzaG91bGQgc2V0IGVpdGhlciBhZGRyZXNzIG9yIHNjcmlwdFR5cGUsIG5ldmVyIGJvdGguXG4gKiBzZXQgaXNJbnRlcm5hbEFkZHJlc3M9dHJ1ZSBmb3IgaW50ZXJuYWwgb3V0cHV0IGFkZHJlc3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeG5PdXRwdXQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4ge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBzY3JpcHRUeXBlPzogVHhuT3V0cHV0U2NyaXB0VHlwZTtcbiAgdmFsdWU6IFROdW1iZXI7XG4gIGlzSW50ZXJuYWxBZGRyZXNzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBhcnJheSBvZiBzdXBwb3J0ZWQgaW5wdXQgc2NyaXB0IHR5cGVzLlxuICovXG5leHBvcnQgY29uc3QgdHhuSW5wdXRTY3JpcHRUeXBlcyA9IFsncDJzaCcsICdwMnNoUDJ3c2gnLCAncDJ3c2gnLCAncDJ0cicsIHNjcmlwdFR5cGVQMnNoUDJwa10gYXMgY29uc3Q7XG5cbi8qKlxuICogYXJyYXkgb2Ygc3VwcG9ydGVkIG91dHB1dCBzY3JpcHQgdHlwZXMuXG4gKi9cbmV4cG9ydCBjb25zdCB0eG5PdXRwdXRTY3JpcHRUeXBlcyA9IHNjcmlwdFR5cGVzMk9mMztcblxuLyoqXG4gKiBjcmVhdGUgdW5zcGVudCBvYmplY3QgZnJvbSBpbnB1dCBzY3JpcHQgdHlwZSwgaW5kZXgsIG5ldHdvcmsgYW5kIHJvb3Qgd2FsbGV0IGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHhuVW5zcGVudDxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgaW5wdXQ6IFR4bklucHV0PFROdW1iZXI+LFxuICBpbmRleDogbnVtYmVyLFxuICBuZXR3b3JrOiBOZXR3b3JrLFxuICByb290V2FsbGV0S2V5czogUm9vdFdhbGxldEtleXNcbik6IFVuc3BlbnQ8VE51bWJlcj4ge1xuICBpZiAoaW5wdXQuc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMnBrJykge1xuICAgIHJldHVybiBtb2NrUmVwbGF5UHJvdGVjdGlvblVuc3BlbnQ8VE51bWJlcj4obmV0d29yaywgaW5wdXQudmFsdWUsIHsga2V5OiByb290V2FsbGV0S2V5c1sndXNlciddLCB2b3V0OiBpbmRleCB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbW9ja1dhbGxldFVuc3BlbnQ8VE51bWJlcj4obmV0d29yaywgaW5wdXQudmFsdWUsIHtcbiAgICAgIGNoYWluOiBnZXRJbnRlcm5hbENoYWluQ29kZShpbnB1dC5zY3JpcHRUeXBlKSxcbiAgICAgIHZvdXQ6IGluZGV4LFxuICAgICAga2V5czogcm9vdFdhbGxldEtleXMsXG4gICAgICBpbmRleCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgc2lnbmVyIGFuZCBjb3NpZ25lciBuYW1lcyBmb3IgVHhuSW5wdXRTY3JpcHRUeXBlLlxuICogdXNlciBhbmQgdW5kZWZpbmVkIGFzIHNpZ25lciBhbmQgY29zaWduZXIgcmVzcGVjdGl2ZWx5IGZvciBwMnNoUDJway5cbiAqIHVzZXIgYW5kIGJpdGdvIGFzIHNpZ25lciBhbmQgY29zaWduZXIgcmVzcGVjdGl2ZWx5IGZvciBvdGhlciBpbnB1dCBzY3JpcHQgdHlwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeG5TaWduZXJzKGlucHV0VHlwZTogVHhuSW5wdXRTY3JpcHRUeXBlKTogeyBzaWduZXJOYW1lOiBLZXlOYW1lOyBjb3NpZ25lck5hbWU/OiBLZXlOYW1lIH0ge1xuICByZXR1cm4ge1xuICAgIHNpZ25lck5hbWU6ICd1c2VyJyxcbiAgICBjb3NpZ25lck5hbWU6IGlucHV0VHlwZSA9PT0gJ3Ayc2hQMnBrJyA/IHVuZGVmaW5lZCA6ICdiaXRnbycsXG4gIH07XG59XG5cbi8qKlxuICogc2lnbnMgd2l0aCBmaXJzdCBvciBzZWNvbmQgc2lnbmF0dXJlIGZvciBzaW5nbGUgaW5wdXQuXG4gKiBwMnNoUDJwayBpcyBzaWduZWQgb25seSB3aXRoIGZpcnN0IHNpZ24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduVHhuSW5wdXQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHR4YjogVXR4b1RyYW5zYWN0aW9uQnVpbGRlcjxUTnVtYmVyPixcbiAgaW5wdXQ6IFR4bklucHV0PFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHJvb3RXYWxsZXRLZXlzOiBSb290V2FsbGV0S2V5cyxcbiAgc2lnbjogJ2hhbGZzaWduZWQnIHwgJ2Z1bGxzaWduZWQnLFxuICBzaWduZXJzPzogeyBzaWduZXJOYW1lOiBLZXlOYW1lOyBjb3NpZ25lck5hbWU/OiBLZXlOYW1lIH1cbik6IHZvaWQge1xuICBjb25zdCB7IHNpZ25lck5hbWUsIGNvc2lnbmVyTmFtZSB9ID0gc2lnbmVycyA/IHNpZ25lcnMgOiBnZXRUeG5TaWduZXJzKGlucHV0LnNjcmlwdFR5cGUpO1xuICBjb25zdCB1bnNwZW50ID0gdG9UeG5VbnNwZW50KGlucHV0LCBpbnB1dEluZGV4LCB0eGIubmV0d29yaywgcm9vdFdhbGxldEtleXMpO1xuICBpZiAoc2lnbiA9PT0gJ2hhbGZzaWduZWQnKSB7XG4gICAgaWYgKGlucHV0LnNjcmlwdFR5cGUgPT09ICdwMnNoUDJwaycpIHtcbiAgICAgIHNpZ25JbnB1dFAyc2hQMnBrKHR4YiwgaW5wdXRJbmRleCwgcm9vdFdhbGxldEtleXNbc2lnbmVyTmFtZV0pO1xuICAgIH0gZWxzZSBpZiAoaXNXYWxsZXRVbnNwZW50KHVuc3BlbnQpICYmIGNvc2lnbmVyTmFtZSkge1xuICAgICAgc2lnbklucHV0V2l0aFVuc3BlbnQoXG4gICAgICAgIHR4YixcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgdW5zcGVudCxcbiAgICAgICAgV2FsbGV0VW5zcGVudFNpZ25lci5mcm9tKHJvb3RXYWxsZXRLZXlzLCByb290V2FsbGV0S2V5c1tzaWduZXJOYW1lXSwgcm9vdFdhbGxldEtleXNbY29zaWduZXJOYW1lXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChpc1dhbGxldFVuc3BlbnQodW5zcGVudCkgJiYgc2lnbiA9PT0gJ2Z1bGxzaWduZWQnICYmIGNvc2lnbmVyTmFtZSkge1xuICAgIHNpZ25JbnB1dFdpdGhVbnNwZW50KFxuICAgICAgdHhiLFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIHVuc3BlbnQsXG4gICAgICBXYWxsZXRVbnNwZW50U2lnbmVyLmZyb20ocm9vdFdhbGxldEtleXMsIHJvb3RXYWxsZXRLZXlzW2Nvc2lnbmVyTmFtZV0sIHJvb3RXYWxsZXRLZXlzW3NpZ25lck5hbWVdKVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBzaWducyB3aXRoIGZpcnN0IG9yIHNlY29uZCBzaWduYXR1cmUgZm9yIGFsbCBpbnB1dHMuXG4gKiBwMnNoUDJwayBpcyBzaWduZWQgb25seSB3aXRoIGZpcnN0IHNpZ24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduQWxsVHhuSW5wdXRzPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0eGI6IFV0eG9UcmFuc2FjdGlvbkJ1aWxkZXI8VE51bWJlcj4sXG4gIGlucHV0czogVHhuSW5wdXQ8VE51bWJlcj5bXSxcbiAgcm9vdFdhbGxldEtleXM6IFJvb3RXYWxsZXRLZXlzLFxuICBzaWduOiAnaGFsZnNpZ25lZCcgfCAnZnVsbHNpZ25lZCcsXG4gIHNpZ25lcnM/OiB7IHNpZ25lck5hbWU6IEtleU5hbWU7IGNvc2lnbmVyTmFtZT86IEtleU5hbWUgfVxuKTogdm9pZCB7XG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICBzaWduVHhuSW5wdXQodHhiLCBpbnB1dCwgaW5kZXgsIHJvb3RXYWxsZXRLZXlzLCBzaWduLCBzaWduZXJzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogY29uc3RydWN0IHRyYW5zYWN0aW9uIGZvciBnaXZlbiBpbnB1dHMsIG91dHB1dHMsIG5ldHdvcmsgYW5kIHJvb3Qgd2FsbGV0IGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RUeG5CdWlsZGVyPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICBpbnB1dHM6IFR4bklucHV0PFROdW1iZXI+W10sXG4gIG91dHB1dHM6IFR4bk91dHB1dDxUTnVtYmVyPltdLFxuICBuZXR3b3JrOiBOZXR3b3JrLFxuICByb290V2FsbGV0S2V5czogUm9vdFdhbGxldEtleXMsXG4gIHNpZ246ICd1bnNpZ25lZCcgfCAnaGFsZnNpZ25lZCcgfCAnZnVsbHNpZ25lZCcsXG4gIHNpZ25lcnM/OiB7IHNpZ25lck5hbWU6IEtleU5hbWU7IGNvc2lnbmVyTmFtZT86IEtleU5hbWUgfVxuKTogVXR4b1RyYW5zYWN0aW9uQnVpbGRlcjxUTnVtYmVyPiB7XG4gIGNvbnN0IHRvdGFsSW5wdXRBbW91bnQgPSBpbnB1dHMucmVkdWNlKChzdW0sIGlucHV0KSA9PiBzdW0gKyBCaWdJbnQoaW5wdXQudmFsdWUpLCBCaWdJbnQoMCkpO1xuICBjb25zdCBvdXRwdXRJbnB1dEFtb3VudCA9IG91dHB1dHMucmVkdWNlKChzdW0sIG91dHB1dCkgPT4gc3VtICsgQmlnSW50KG91dHB1dC52YWx1ZSksIEJpZ0ludCgwKSk7XG4gIGFzc2VydCh0b3RhbElucHV0QW1vdW50ID49IG91dHB1dElucHV0QW1vdW50LCAndG90YWwgb3V0cHV0IGNhbiBub3QgZXhjZWVkIHRvdGFsIGlucHV0Jyk7XG4gIGFzc2VydChcbiAgICAhb3V0cHV0cy5zb21lKChvKSA9PiAoby5zY3JpcHRUeXBlICYmIG8uYWRkcmVzcykgfHwgKCFvLnNjcmlwdFR5cGUgJiYgIW8uYWRkcmVzcykpLFxuICAgICdvbmx5IGVpdGhlciBvdXRwdXQgc2NyaXB0IHR5cGUgb3IgYWRkcmVzcyBzaG91bGQgYmUgcHJvdmlkZWQnXG4gICk7XG5cbiAgY29uc3QgdHhiID0gY3JlYXRlVHJhbnNhY3Rpb25CdWlsZGVyRm9yTmV0d29yazxUTnVtYmVyPihuZXR3b3JrKTtcblxuICBjb25zdCB1bnNwZW50cyA9IGlucHV0cy5tYXAoKGlucHV0LCBpKSA9PiB0b1R4blVuc3BlbnQoaW5wdXQsIGksIG5ldHdvcmssIHJvb3RXYWxsZXRLZXlzKSk7XG5cbiAgdW5zcGVudHMuZm9yRWFjaCgodSwgaSkgPT4ge1xuICAgIGFkZFRvVHJhbnNhY3Rpb25CdWlsZGVyKHR4YiwgdSk7XG4gIH0pO1xuXG4gIG91dHB1dHMuZm9yRWFjaCgob3V0cHV0LCBpKSA9PiB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG91dHB1dC5zY3JpcHRUeXBlXG4gICAgICA/IGdldFdhbGxldEFkZHJlc3MoXG4gICAgICAgICAgcm9vdFdhbGxldEtleXMsXG4gICAgICAgICAgb3V0cHV0LmlzSW50ZXJuYWxBZGRyZXNzID8gZ2V0SW50ZXJuYWxDaGFpbkNvZGUob3V0cHV0LnNjcmlwdFR5cGUpIDogZ2V0RXh0ZXJuYWxDaGFpbkNvZGUob3V0cHV0LnNjcmlwdFR5cGUpLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbmV0d29ya1xuICAgICAgICApXG4gICAgICA6IG91dHB1dC5hZGRyZXNzO1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyZXNzIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgdHhiLmFkZE91dHB1dChhZGRyZXNzLCBvdXRwdXQudmFsdWUpO1xuICB9KTtcblxuICBpZiAoc2lnbiA9PT0gJ3Vuc2lnbmVkJykge1xuICAgIHJldHVybiB0eGI7XG4gIH1cblxuICBzaWduQWxsVHhuSW5wdXRzKHR4YiwgaW5wdXRzLCByb290V2FsbGV0S2V5cywgJ2hhbGZzaWduZWQnLCBzaWduZXJzKTtcblxuICBpZiAoc2lnbiA9PT0gJ2Z1bGxzaWduZWQnKSB7XG4gICAgc2lnbkFsbFR4bklucHV0cyh0eGIsIGlucHV0cywgcm9vdFdhbGxldEtleXMsIHNpZ24sIHNpZ25lcnMpO1xuICB9XG5cbiAgcmV0dXJuIHR4Yjtcbn1cbiJdfQ==