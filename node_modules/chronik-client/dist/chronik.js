"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgBlockConnected = exports.MsgReorg = exports.MsgConfirmed = exports.MsgRemovedFromMempool = exports.MsgAddedToMempool = exports.SubscribeMsg = exports.SubscriptionNode = exports.Subscription = exports.UtxoState = exports.SlpGenesisInfo = exports.SlpBurn = exports.SlpToken = exports.OutPoint = exports.BlockMetadata = exports.TxOutput = exports.TxInput = exports.TokenStats = exports.SlpMeta = exports.SlpTxData = exports.Blocks = exports.Utxos = exports.TxHistoryPage = exports.ScriptUtxos = exports.Block = exports.BlockDetails = exports.BlockInfo = exports.Token = exports.Utxo = exports.Tx = exports.BlockchainInfo = exports.BroadcastTxsResponse = exports.BroadcastTxsRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.ValidateUtxoResponse = exports.ValidateUtxoRequest = exports.SubscriptionObject = exports.utxoStateVariantToJSON = exports.utxoStateVariantFromJSON = exports.UtxoStateVariant = exports.networkToJSON = exports.networkFromJSON = exports.Network = exports.slpTxTypeToJSON = exports.slpTxTypeFromJSON = exports.SlpTxType = exports.slpTokenTypeToJSON = exports.slpTokenTypeFromJSON = exports.SlpTokenType = exports.protobufPackage = void 0;
exports.Error = exports.MsgBlockDisconnected = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = 'chronik';
var SlpTokenType;
(function (SlpTokenType) {
    SlpTokenType[SlpTokenType["FUNGIBLE"] = 0] = "FUNGIBLE";
    SlpTokenType[SlpTokenType["NFT1_GROUP"] = 1] = "NFT1_GROUP";
    SlpTokenType[SlpTokenType["NFT1_CHILD"] = 2] = "NFT1_CHILD";
    SlpTokenType[SlpTokenType["UNKNOWN_TOKEN_TYPE"] = 3] = "UNKNOWN_TOKEN_TYPE";
    SlpTokenType[SlpTokenType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SlpTokenType = exports.SlpTokenType || (exports.SlpTokenType = {}));
function slpTokenTypeFromJSON(object) {
    switch (object) {
        case 0:
        case 'FUNGIBLE':
            return SlpTokenType.FUNGIBLE;
        case 1:
        case 'NFT1_GROUP':
            return SlpTokenType.NFT1_GROUP;
        case 2:
        case 'NFT1_CHILD':
            return SlpTokenType.NFT1_CHILD;
        case 3:
        case 'UNKNOWN_TOKEN_TYPE':
            return SlpTokenType.UNKNOWN_TOKEN_TYPE;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return SlpTokenType.UNRECOGNIZED;
    }
}
exports.slpTokenTypeFromJSON = slpTokenTypeFromJSON;
function slpTokenTypeToJSON(object) {
    switch (object) {
        case SlpTokenType.FUNGIBLE:
            return 'FUNGIBLE';
        case SlpTokenType.NFT1_GROUP:
            return 'NFT1_GROUP';
        case SlpTokenType.NFT1_CHILD:
            return 'NFT1_CHILD';
        case SlpTokenType.UNKNOWN_TOKEN_TYPE:
            return 'UNKNOWN_TOKEN_TYPE';
        default:
            return 'UNKNOWN';
    }
}
exports.slpTokenTypeToJSON = slpTokenTypeToJSON;
var SlpTxType;
(function (SlpTxType) {
    SlpTxType[SlpTxType["GENESIS"] = 0] = "GENESIS";
    SlpTxType[SlpTxType["SEND"] = 1] = "SEND";
    SlpTxType[SlpTxType["MINT"] = 2] = "MINT";
    SlpTxType[SlpTxType["BURN"] = 4] = "BURN";
    SlpTxType[SlpTxType["UNKNOWN_TX_TYPE"] = 3] = "UNKNOWN_TX_TYPE";
    SlpTxType[SlpTxType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SlpTxType = exports.SlpTxType || (exports.SlpTxType = {}));
function slpTxTypeFromJSON(object) {
    switch (object) {
        case 0:
        case 'GENESIS':
            return SlpTxType.GENESIS;
        case 1:
        case 'SEND':
            return SlpTxType.SEND;
        case 2:
        case 'MINT':
            return SlpTxType.MINT;
        case 4:
        case 'BURN':
            return SlpTxType.BURN;
        case 3:
        case 'UNKNOWN_TX_TYPE':
            return SlpTxType.UNKNOWN_TX_TYPE;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return SlpTxType.UNRECOGNIZED;
    }
}
exports.slpTxTypeFromJSON = slpTxTypeFromJSON;
function slpTxTypeToJSON(object) {
    switch (object) {
        case SlpTxType.GENESIS:
            return 'GENESIS';
        case SlpTxType.SEND:
            return 'SEND';
        case SlpTxType.MINT:
            return 'MINT';
        case SlpTxType.BURN:
            return 'BURN';
        case SlpTxType.UNKNOWN_TX_TYPE:
            return 'UNKNOWN_TX_TYPE';
        default:
            return 'UNKNOWN';
    }
}
exports.slpTxTypeToJSON = slpTxTypeToJSON;
var Network;
(function (Network) {
    Network[Network["BCH"] = 0] = "BCH";
    Network[Network["XEC"] = 1] = "XEC";
    Network[Network["XPI"] = 2] = "XPI";
    Network[Network["XRG"] = 3] = "XRG";
    Network[Network["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Network = exports.Network || (exports.Network = {}));
function networkFromJSON(object) {
    switch (object) {
        case 0:
        case 'BCH':
            return Network.BCH;
        case 1:
        case 'XEC':
            return Network.XEC;
        case 2:
        case 'XPI':
            return Network.XPI;
        case 3:
        case 'XRG':
            return Network.XRG;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return Network.UNRECOGNIZED;
    }
}
exports.networkFromJSON = networkFromJSON;
function networkToJSON(object) {
    switch (object) {
        case Network.BCH:
            return 'BCH';
        case Network.XEC:
            return 'XEC';
        case Network.XPI:
            return 'XPI';
        case Network.XRG:
            return 'XRG';
        default:
            return 'UNKNOWN';
    }
}
exports.networkToJSON = networkToJSON;
var UtxoStateVariant;
(function (UtxoStateVariant) {
    UtxoStateVariant[UtxoStateVariant["UNSPENT"] = 0] = "UNSPENT";
    UtxoStateVariant[UtxoStateVariant["SPENT"] = 1] = "SPENT";
    UtxoStateVariant[UtxoStateVariant["NO_SUCH_TX"] = 2] = "NO_SUCH_TX";
    UtxoStateVariant[UtxoStateVariant["NO_SUCH_OUTPUT"] = 3] = "NO_SUCH_OUTPUT";
    UtxoStateVariant[UtxoStateVariant["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(UtxoStateVariant = exports.UtxoStateVariant || (exports.UtxoStateVariant = {}));
function utxoStateVariantFromJSON(object) {
    switch (object) {
        case 0:
        case 'UNSPENT':
            return UtxoStateVariant.UNSPENT;
        case 1:
        case 'SPENT':
            return UtxoStateVariant.SPENT;
        case 2:
        case 'NO_SUCH_TX':
            return UtxoStateVariant.NO_SUCH_TX;
        case 3:
        case 'NO_SUCH_OUTPUT':
            return UtxoStateVariant.NO_SUCH_OUTPUT;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return UtxoStateVariant.UNRECOGNIZED;
    }
}
exports.utxoStateVariantFromJSON = utxoStateVariantFromJSON;
function utxoStateVariantToJSON(object) {
    switch (object) {
        case UtxoStateVariant.UNSPENT:
            return 'UNSPENT';
        case UtxoStateVariant.SPENT:
            return 'SPENT';
        case UtxoStateVariant.NO_SUCH_TX:
            return 'NO_SUCH_TX';
        case UtxoStateVariant.NO_SUCH_OUTPUT:
            return 'NO_SUCH_OUTPUT';
        default:
            return 'UNKNOWN';
    }
}
exports.utxoStateVariantToJSON = utxoStateVariantToJSON;
// TODO encode and decode methods for subscription object
function createBaseSubscriptionObject() {
    return {};
}
exports.SubscriptionObject = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.scriptType !== undefined) {
            writer.uint32(10).string(message.scriptType);
        }
        if (message.payload !== undefined) {
            writer.uint32(20).bytes(message.payload);
        }
        return writer;
    },
    // TODO I don't think this is correct, not sure how to handle this
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscriptionObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.scriptType = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            scriptType: isSet(object.scriptType)
                ? String(object.scriptType)
                : undefined,
            payload: isSet(object.payload)
                ? bytesFromBase64(object.payload)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.scriptType !== undefined &&
            (obj.scriptType = message.scriptType);
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSubscriptionObject();
        message.scriptType = (_a = object.scriptType) !== null && _a !== void 0 ? _a : '';
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseValidateUtxoRequest() {
    return { outpoints: [] };
}
exports.ValidateUtxoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.outpoints) {
            exports.OutPoint.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateUtxoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outpoints.push(exports.OutPoint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            outpoints: Array.isArray(object === null || object === void 0 ? void 0 : object.outpoints)
                ? object.outpoints.map((e) => exports.OutPoint.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.outpoints) {
            obj.outpoints = message.outpoints.map(e => e ? exports.OutPoint.toJSON(e) : undefined);
        }
        else {
            obj.outpoints = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseValidateUtxoRequest();
        message.outpoints =
            ((_a = object.outpoints) === null || _a === void 0 ? void 0 : _a.map(e => exports.OutPoint.fromPartial(e))) || [];
        return message;
    },
};
function createBaseValidateUtxoResponse() {
    return { utxoStates: [] };
}
exports.ValidateUtxoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.utxoStates) {
            exports.UtxoState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateUtxoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.utxoStates.push(exports.UtxoState.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            utxoStates: Array.isArray(object === null || object === void 0 ? void 0 : object.utxoStates)
                ? object.utxoStates.map((e) => exports.UtxoState.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.utxoStates) {
            obj.utxoStates = message.utxoStates.map(e => e ? exports.UtxoState.toJSON(e) : undefined);
        }
        else {
            obj.utxoStates = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseValidateUtxoResponse();
        message.utxoStates =
            ((_a = object.utxoStates) === null || _a === void 0 ? void 0 : _a.map(e => exports.UtxoState.fromPartial(e))) || [];
        return message;
    },
};
function createBaseBroadcastTxRequest() {
    return { rawTx: new Uint8Array(), skipSlpCheck: false };
}
exports.BroadcastTxRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.rawTx.length !== 0) {
            writer.uint32(10).bytes(message.rawTx);
        }
        if (message.skipSlpCheck === true) {
            writer.uint32(16).bool(message.skipSlpCheck);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rawTx = reader.bytes();
                    break;
                case 2:
                    message.skipSlpCheck = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            rawTx: isSet(object.rawTx)
                ? bytesFromBase64(object.rawTx)
                : new Uint8Array(),
            skipSlpCheck: isSet(object.skipSlpCheck)
                ? Boolean(object.skipSlpCheck)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.rawTx !== undefined &&
            (obj.rawTx = base64FromBytes(message.rawTx !== undefined ? message.rawTx : new Uint8Array()));
        message.skipSlpCheck !== undefined &&
            (obj.skipSlpCheck = message.skipSlpCheck);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBroadcastTxRequest();
        message.rawTx = (_a = object.rawTx) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.skipSlpCheck = (_b = object.skipSlpCheck) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseBroadcastTxResponse() {
    return { txid: new Uint8Array() };
}
exports.BroadcastTxResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBroadcastTxResponse();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseBroadcastTxsRequest() {
    return { rawTxs: [], skipSlpCheck: false };
}
exports.BroadcastTxsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rawTxs) {
            writer.uint32(10).bytes(v);
        }
        if (message.skipSlpCheck === true) {
            writer.uint32(16).bool(message.skipSlpCheck);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rawTxs.push(reader.bytes());
                    break;
                case 2:
                    message.skipSlpCheck = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            rawTxs: Array.isArray(object === null || object === void 0 ? void 0 : object.rawTxs)
                ? object.rawTxs.map((e) => bytesFromBase64(e))
                : [],
            skipSlpCheck: isSet(object.skipSlpCheck)
                ? Boolean(object.skipSlpCheck)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rawTxs) {
            obj.rawTxs = message.rawTxs.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.rawTxs = [];
        }
        message.skipSlpCheck !== undefined &&
            (obj.skipSlpCheck = message.skipSlpCheck);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBroadcastTxsRequest();
        message.rawTxs = ((_a = object.rawTxs) === null || _a === void 0 ? void 0 : _a.map(e => e)) || [];
        message.skipSlpCheck = (_b = object.skipSlpCheck) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseBroadcastTxsResponse() {
    return { txids: [] };
}
exports.BroadcastTxsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.txids) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txids.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txids: Array.isArray(object === null || object === void 0 ? void 0 : object.txids)
                ? object.txids.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txids) {
            obj.txids = message.txids.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.txids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBroadcastTxsResponse();
        message.txids = ((_a = object.txids) === null || _a === void 0 ? void 0 : _a.map(e => e)) || [];
        return message;
    },
};
function createBaseBlockchainInfo() {
    return { tipHash: new Uint8Array(), tipHeight: 0 };
}
exports.BlockchainInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.tipHash.length !== 0) {
            writer.uint32(10).bytes(message.tipHash);
        }
        if (message.tipHeight !== 0) {
            writer.uint32(16).int32(message.tipHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockchainInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tipHash = reader.bytes();
                    break;
                case 2:
                    message.tipHeight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            tipHash: isSet(object.tipHash)
                ? bytesFromBase64(object.tipHash)
                : new Uint8Array(),
            tipHeight: isSet(object.tipHeight) ? Number(object.tipHeight) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.tipHash !== undefined &&
            (obj.tipHash = base64FromBytes(message.tipHash !== undefined
                ? message.tipHash
                : new Uint8Array()));
        message.tipHeight !== undefined &&
            (obj.tipHeight = Math.round(message.tipHeight));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBlockchainInfo();
        message.tipHash = (_a = object.tipHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.tipHeight = (_b = object.tipHeight) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseTx() {
    return {
        txid: new Uint8Array(),
        version: 0,
        inputs: [],
        outputs: [],
        lockTime: 0,
        slpTxData: undefined,
        slpErrorMsg: '',
        block: undefined,
        timeFirstSeen: '0',
        size: 0,
        isCoinbase: false,
    };
}
exports.Tx = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        if (message.version !== 0) {
            writer.uint32(16).int32(message.version);
        }
        for (const v of message.inputs) {
            exports.TxInput.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.outputs) {
            exports.TxOutput.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.lockTime !== 0) {
            writer.uint32(40).uint32(message.lockTime);
        }
        if (message.slpTxData !== undefined) {
            exports.SlpTxData.encode(message.slpTxData, writer.uint32(50).fork()).ldelim();
        }
        if (message.slpErrorMsg !== '') {
            writer.uint32(58).string(message.slpErrorMsg);
        }
        if (message.block !== undefined) {
            exports.BlockMetadata.encode(message.block, writer.uint32(66).fork()).ldelim();
        }
        if (message.timeFirstSeen !== '0') {
            writer.uint32(72).int64(message.timeFirstSeen);
        }
        if (message.size !== 0) {
            writer.uint32(88).uint32(message.size);
        }
        if (message.isCoinbase === true) {
            writer.uint32(96).bool(message.isCoinbase);
        }
        if (message.network !== undefined) {
            writer.uint32(80).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                case 3:
                    message.inputs.push(exports.TxInput.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.outputs.push(exports.TxOutput.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.lockTime = reader.uint32();
                    break;
                case 6:
                    message.slpTxData = exports.SlpTxData.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.slpErrorMsg = reader.string();
                    break;
                case 8:
                    message.block = exports.BlockMetadata.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.timeFirstSeen = longToString(reader.int64());
                    break;
                case 11:
                    message.size = reader.uint32();
                    break;
                case 12:
                    message.isCoinbase = reader.bool();
                    break;
                case 10:
                    message.network = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
            version: isSet(object.version) ? Number(object.version) : 0,
            inputs: Array.isArray(object === null || object === void 0 ? void 0 : object.inputs)
                ? object.inputs.map((e) => exports.TxInput.fromJSON(e))
                : [],
            outputs: Array.isArray(object === null || object === void 0 ? void 0 : object.outputs)
                ? object.outputs.map((e) => exports.TxOutput.fromJSON(e))
                : [],
            lockTime: isSet(object.lockTime) ? Number(object.lockTime) : 0,
            slpTxData: isSet(object.slpTxData)
                ? exports.SlpTxData.fromJSON(object.slpTxData)
                : undefined,
            slpErrorMsg: isSet(object.slpErrorMsg)
                ? String(object.slpErrorMsg)
                : '',
            block: isSet(object.block)
                ? exports.BlockMetadata.fromJSON(object.block)
                : undefined,
            timeFirstSeen: isSet(object.timeFirstSeen)
                ? String(object.timeFirstSeen)
                : '0',
            size: isSet(object.size) ? Number(object.size) : 0,
            isCoinbase: isSet(object.isCoinbase)
                ? Boolean(object.isCoinbase)
                : false,
            network: isSet(object.network)
                ? networkFromJSON(object.network)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        message.version !== undefined &&
            (obj.version = Math.round(message.version));
        if (message.inputs) {
            obj.inputs = message.inputs.map(e => e ? exports.TxInput.toJSON(e) : undefined);
        }
        else {
            obj.inputs = [];
        }
        if (message.outputs) {
            obj.outputs = message.outputs.map(e => e ? exports.TxOutput.toJSON(e) : undefined);
        }
        else {
            obj.outputs = [];
        }
        message.lockTime !== undefined &&
            (obj.lockTime = Math.round(message.lockTime));
        message.slpTxData !== undefined &&
            (obj.slpTxData = message.slpTxData
                ? exports.SlpTxData.toJSON(message.slpTxData)
                : undefined);
        message.slpErrorMsg !== undefined &&
            (obj.slpErrorMsg = message.slpErrorMsg);
        message.block !== undefined &&
            (obj.block = message.block
                ? exports.BlockMetadata.toJSON(message.block)
                : undefined);
        message.timeFirstSeen !== undefined &&
            (obj.timeFirstSeen = message.timeFirstSeen);
        message.size !== undefined && (obj.size = Math.round(message.size));
        message.isCoinbase !== undefined &&
            (obj.isCoinbase = message.isCoinbase);
        message.network !== undefined &&
            (obj.network = networkToJSON(message.network));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseTx();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : 0;
        message.inputs = ((_c = object.inputs) === null || _c === void 0 ? void 0 : _c.map(e => exports.TxInput.fromPartial(e))) || [];
        message.outputs =
            ((_d = object.outputs) === null || _d === void 0 ? void 0 : _d.map(e => exports.TxOutput.fromPartial(e))) || [];
        message.lockTime = (_e = object.lockTime) !== null && _e !== void 0 ? _e : 0;
        message.slpTxData =
            object.slpTxData !== undefined && object.slpTxData !== null
                ? exports.SlpTxData.fromPartial(object.slpTxData)
                : undefined;
        message.slpErrorMsg = (_f = object.slpErrorMsg) !== null && _f !== void 0 ? _f : '';
        message.block =
            object.block !== undefined && object.block !== null
                ? exports.BlockMetadata.fromPartial(object.block)
                : undefined;
        message.timeFirstSeen = (_g = object.timeFirstSeen) !== null && _g !== void 0 ? _g : '0';
        message.size = (_h = object.size) !== null && _h !== void 0 ? _h : 0;
        message.isCoinbase = (_j = object.isCoinbase) !== null && _j !== void 0 ? _j : false;
        message.network = (_k = object.network) !== null && _k !== void 0 ? _k : undefined;
        return message;
    },
};
function createBaseUtxo() {
    return {
        outpoint: undefined,
        blockHeight: 0,
        isCoinbase: false,
        value: '0',
        slpMeta: undefined,
        slpToken: undefined,
    };
}
exports.Utxo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.outpoint !== undefined) {
            exports.OutPoint.encode(message.outpoint, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockHeight !== 0) {
            writer.uint32(16).int32(message.blockHeight);
        }
        if (message.isCoinbase === true) {
            writer.uint32(24).bool(message.isCoinbase);
        }
        if (message.value !== '0') {
            writer.uint32(40).int64(message.value);
        }
        if (message.slpMeta !== undefined) {
            exports.SlpMeta.encode(message.slpMeta, writer.uint32(50).fork()).ldelim();
        }
        if (message.slpToken !== undefined) {
            exports.SlpToken.encode(message.slpToken, writer.uint32(58).fork()).ldelim();
        }
        if (message.network !== undefined) {
            writer.uint32(72).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUtxo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outpoint = exports.OutPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.blockHeight = reader.int32();
                    break;
                case 3:
                    message.isCoinbase = reader.bool();
                    break;
                case 5:
                    message.value = longToString(reader.int64());
                    break;
                case 6:
                    message.slpMeta = exports.SlpMeta.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.slpToken = exports.SlpToken.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.network = reader.int32();
                    break;
                case 10:
                    message.isFinal = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            outpoint: isSet(object.outpoint)
                ? exports.OutPoint.fromJSON(object.outpoint)
                : undefined,
            blockHeight: isSet(object.blockHeight)
                ? Number(object.blockHeight)
                : 0,
            isCoinbase: isSet(object.isCoinbase)
                ? Boolean(object.isCoinbase)
                : false,
            value: isSet(object.value) ? String(object.value) : '0',
            slpMeta: isSet(object.slpMeta)
                ? exports.SlpMeta.fromJSON(object.slpMeta)
                : undefined,
            slpToken: isSet(object.slpToken)
                ? exports.SlpToken.fromJSON(object.slpToken)
                : undefined,
            network: isSet(object.network)
                ? networkFromJSON(object.network)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.outpoint !== undefined &&
            (obj.outpoint = message.outpoint
                ? exports.OutPoint.toJSON(message.outpoint)
                : undefined);
        message.blockHeight !== undefined &&
            (obj.blockHeight = Math.round(message.blockHeight));
        message.isCoinbase !== undefined &&
            (obj.isCoinbase = message.isCoinbase);
        message.value !== undefined && (obj.value = message.value);
        message.slpMeta !== undefined &&
            (obj.slpMeta = message.slpMeta
                ? exports.SlpMeta.toJSON(message.slpMeta)
                : undefined);
        message.slpToken !== undefined &&
            (obj.slpToken = message.slpToken
                ? exports.SlpToken.toJSON(message.slpToken)
                : undefined);
        message.network !== undefined &&
            (obj.network = networkToJSON(message.network));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseUtxo();
        message.outpoint =
            object.outpoint !== undefined && object.outpoint !== null
                ? exports.OutPoint.fromPartial(object.outpoint)
                : undefined;
        message.blockHeight = (_a = object.blockHeight) !== null && _a !== void 0 ? _a : 0;
        message.isCoinbase = (_b = object.isCoinbase) !== null && _b !== void 0 ? _b : false;
        message.value = (_c = object.value) !== null && _c !== void 0 ? _c : '0';
        message.slpMeta =
            object.slpMeta !== undefined && object.slpMeta !== null
                ? exports.SlpMeta.fromPartial(object.slpMeta)
                : undefined;
        message.slpToken =
            object.slpToken !== undefined && object.slpToken !== null
                ? exports.SlpToken.fromPartial(object.slpToken)
                : undefined;
        message.network = (_d = object.network) !== null && _d !== void 0 ? _d : undefined;
        return message;
    },
};
function createBaseToken() {
    return {
        slpTxData: undefined,
        tokenStats: undefined,
        block: undefined,
        timeFirstSeen: '0',
        initialTokenQuantity: '0',
        containsBaton: false,
        network: 0,
    };
}
exports.Token = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.slpTxData !== undefined) {
            exports.SlpTxData.encode(message.slpTxData, writer.uint32(10).fork()).ldelim();
        }
        if (message.tokenStats !== undefined) {
            exports.TokenStats.encode(message.tokenStats, writer.uint32(18).fork()).ldelim();
        }
        if (message.block !== undefined) {
            exports.BlockMetadata.encode(message.block, writer.uint32(26).fork()).ldelim();
        }
        if (message.timeFirstSeen !== '0') {
            writer.uint32(32).int64(message.timeFirstSeen);
        }
        if (message.initialTokenQuantity !== '0') {
            writer.uint32(40).uint64(message.initialTokenQuantity);
        }
        if (message.containsBaton === true) {
            writer.uint32(48).bool(message.containsBaton);
        }
        if (message.network !== 0) {
            writer.uint32(56).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slpTxData = exports.SlpTxData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tokenStats = exports.TokenStats.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.block = exports.BlockMetadata.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.timeFirstSeen = longToString(reader.int64());
                    break;
                case 5:
                    message.initialTokenQuantity = longToString(reader.uint64());
                    break;
                case 6:
                    message.containsBaton = reader.bool();
                    break;
                case 7:
                    message.network = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slpTxData: isSet(object.slpTxData)
                ? exports.SlpTxData.fromJSON(object.slpTxData)
                : undefined,
            tokenStats: isSet(object.tokenStats)
                ? exports.TokenStats.fromJSON(object.tokenStats)
                : undefined,
            block: isSet(object.block)
                ? exports.BlockMetadata.fromJSON(object.block)
                : undefined,
            timeFirstSeen: isSet(object.timeFirstSeen)
                ? String(object.timeFirstSeen)
                : '0',
            initialTokenQuantity: isSet(object.initialTokenQuantity)
                ? String(object.initialTokenQuantity)
                : '0',
            containsBaton: isSet(object.containsBaton)
                ? Boolean(object.containsBaton)
                : false,
            network: isSet(object.network)
                ? networkFromJSON(object.network)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.slpTxData !== undefined &&
            (obj.slpTxData = message.slpTxData
                ? exports.SlpTxData.toJSON(message.slpTxData)
                : undefined);
        message.tokenStats !== undefined &&
            (obj.tokenStats = message.tokenStats
                ? exports.TokenStats.toJSON(message.tokenStats)
                : undefined);
        message.block !== undefined &&
            (obj.block = message.block
                ? exports.BlockMetadata.toJSON(message.block)
                : undefined);
        message.timeFirstSeen !== undefined &&
            (obj.timeFirstSeen = message.timeFirstSeen);
        message.initialTokenQuantity !== undefined &&
            (obj.initialTokenQuantity = message.initialTokenQuantity);
        message.containsBaton !== undefined &&
            (obj.containsBaton = message.containsBaton);
        message.network !== undefined &&
            (obj.network = networkToJSON(message.network));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseToken();
        message.slpTxData =
            object.slpTxData !== undefined && object.slpTxData !== null
                ? exports.SlpTxData.fromPartial(object.slpTxData)
                : undefined;
        message.tokenStats =
            object.tokenStats !== undefined && object.tokenStats !== null
                ? exports.TokenStats.fromPartial(object.tokenStats)
                : undefined;
        message.block =
            object.block !== undefined && object.block !== null
                ? exports.BlockMetadata.fromPartial(object.block)
                : undefined;
        message.timeFirstSeen = (_a = object.timeFirstSeen) !== null && _a !== void 0 ? _a : '0';
        message.initialTokenQuantity = (_b = object.initialTokenQuantity) !== null && _b !== void 0 ? _b : '0';
        message.containsBaton = (_c = object.containsBaton) !== null && _c !== void 0 ? _c : false;
        message.network = (_d = object.network) !== null && _d !== void 0 ? _d : 0;
        return message;
    },
};
function createBaseBlockInfo() {
    return {
        hash: new Uint8Array(),
        prevHash: new Uint8Array(),
        height: 0,
        nBits: 0,
        timestamp: '0',
        blockSize: '0',
        numTxs: '0',
        numInputs: '0',
        numOutputs: '0',
        sumInputSats: '0',
        sumCoinbaseOutputSats: '0',
        sumNormalOutputSats: '0',
        sumBurnedSats: '0',
    };
}
exports.BlockInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.hash.length !== 0) {
            writer.uint32(10).bytes(message.hash);
        }
        if (message.prevHash.length !== 0) {
            writer.uint32(18).bytes(message.prevHash);
        }
        if (message.height !== 0) {
            writer.uint32(24).int32(message.height);
        }
        if (message.nBits !== 0) {
            writer.uint32(32).uint32(message.nBits);
        }
        if (message.timestamp !== '0') {
            writer.uint32(40).int64(message.timestamp);
        }
        if (message.blockSize !== '0') {
            writer.uint32(48).uint64(message.blockSize);
        }
        if (message.numTxs !== '0') {
            writer.uint32(56).uint64(message.numTxs);
        }
        if (message.numInputs !== '0') {
            writer.uint32(64).uint64(message.numInputs);
        }
        if (message.numOutputs !== '0') {
            writer.uint32(72).uint64(message.numOutputs);
        }
        if (message.sumInputSats !== '0') {
            writer.uint32(80).int64(message.sumInputSats);
        }
        if (message.sumCoinbaseOutputSats !== '0') {
            writer.uint32(88).int64(message.sumCoinbaseOutputSats);
        }
        if (message.sumNormalOutputSats !== '0') {
            writer.uint32(96).int64(message.sumNormalOutputSats);
        }
        if (message.sumBurnedSats !== '0') {
            writer.uint32(104).int64(message.sumBurnedSats);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.prevHash = reader.bytes();
                    break;
                case 3:
                    message.height = reader.int32();
                    break;
                case 4:
                    message.nBits = reader.uint32();
                    break;
                case 5:
                    message.timestamp = longToString(reader.int64());
                    break;
                case 6:
                    message.blockSize = longToString(reader.uint64());
                    break;
                case 7:
                    message.numTxs = longToString(reader.uint64());
                    break;
                case 8:
                    message.numInputs = longToString(reader.uint64());
                    break;
                case 9:
                    message.numOutputs = longToString(reader.uint64());
                    break;
                case 10:
                    message.sumInputSats = longToString(reader.int64());
                    break;
                case 11:
                    message.sumCoinbaseOutputSats = longToString(reader.int64());
                    break;
                case 12:
                    message.sumNormalOutputSats = longToString(reader.int64());
                    break;
                case 13:
                    message.sumBurnedSats = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            hash: isSet(object.hash)
                ? bytesFromBase64(object.hash)
                : new Uint8Array(),
            prevHash: isSet(object.prevHash)
                ? bytesFromBase64(object.prevHash)
                : new Uint8Array(),
            height: isSet(object.height) ? Number(object.height) : 0,
            nBits: isSet(object.nBits) ? Number(object.nBits) : 0,
            timestamp: isSet(object.timestamp) ? String(object.timestamp) : '0',
            blockSize: isSet(object.blockSize) ? String(object.blockSize) : '0',
            numTxs: isSet(object.numTxs) ? String(object.numTxs) : '0',
            numInputs: isSet(object.numInputs) ? String(object.numInputs) : '0',
            numOutputs: isSet(object.numOutputs)
                ? String(object.numOutputs)
                : '0',
            sumInputSats: isSet(object.sumInputSats)
                ? String(object.sumInputSats)
                : '0',
            sumCoinbaseOutputSats: isSet(object.sumCoinbaseOutputSats)
                ? String(object.sumCoinbaseOutputSats)
                : '0',
            sumNormalOutputSats: isSet(object.sumNormalOutputSats)
                ? String(object.sumNormalOutputSats)
                : '0',
            sumBurnedSats: isSet(object.sumBurnedSats)
                ? String(object.sumBurnedSats)
                : '0',
        };
    },
    toJSON(message) {
        const obj = {};
        message.hash !== undefined &&
            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.prevHash !== undefined &&
            (obj.prevHash = base64FromBytes(message.prevHash !== undefined
                ? message.prevHash
                : new Uint8Array()));
        message.height !== undefined &&
            (obj.height = Math.round(message.height));
        message.nBits !== undefined && (obj.nBits = Math.round(message.nBits));
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        message.blockSize !== undefined && (obj.blockSize = message.blockSize);
        message.numTxs !== undefined && (obj.numTxs = message.numTxs);
        message.numInputs !== undefined && (obj.numInputs = message.numInputs);
        message.numOutputs !== undefined &&
            (obj.numOutputs = message.numOutputs);
        message.sumInputSats !== undefined &&
            (obj.sumInputSats = message.sumInputSats);
        message.sumCoinbaseOutputSats !== undefined &&
            (obj.sumCoinbaseOutputSats = message.sumCoinbaseOutputSats);
        message.sumNormalOutputSats !== undefined &&
            (obj.sumNormalOutputSats = message.sumNormalOutputSats);
        message.sumBurnedSats !== undefined &&
            (obj.sumBurnedSats = message.sumBurnedSats);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const message = createBaseBlockInfo();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.prevHash = (_b = object.prevHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
        message.nBits = (_d = object.nBits) !== null && _d !== void 0 ? _d : 0;
        message.timestamp = (_e = object.timestamp) !== null && _e !== void 0 ? _e : '0';
        message.blockSize = (_f = object.blockSize) !== null && _f !== void 0 ? _f : '0';
        message.numTxs = (_g = object.numTxs) !== null && _g !== void 0 ? _g : '0';
        message.numInputs = (_h = object.numInputs) !== null && _h !== void 0 ? _h : '0';
        message.numOutputs = (_j = object.numOutputs) !== null && _j !== void 0 ? _j : '0';
        message.sumInputSats = (_k = object.sumInputSats) !== null && _k !== void 0 ? _k : '0';
        message.sumCoinbaseOutputSats = (_l = object.sumCoinbaseOutputSats) !== null && _l !== void 0 ? _l : '0';
        message.sumNormalOutputSats = (_m = object.sumNormalOutputSats) !== null && _m !== void 0 ? _m : '0';
        message.sumBurnedSats = (_o = object.sumBurnedSats) !== null && _o !== void 0 ? _o : '0';
        return message;
    },
};
function createBaseBlockDetails() {
    return {
        version: 0,
        merkleRoot: new Uint8Array(),
        nonce: '0',
        medianTimestamp: '0',
    };
}
exports.BlockDetails = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.version !== 0) {
            writer.uint32(8).int32(message.version);
        }
        if (message.merkleRoot.length !== 0) {
            writer.uint32(18).bytes(message.merkleRoot);
        }
        if (message.nonce !== '0') {
            writer.uint32(24).uint64(message.nonce);
        }
        if (message.medianTimestamp !== '0') {
            writer.uint32(32).int64(message.medianTimestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 2:
                    message.merkleRoot = reader.bytes();
                    break;
                case 3:
                    message.nonce = longToString(reader.uint64());
                    break;
                case 4:
                    message.medianTimestamp = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            version: isSet(object.version) ? Number(object.version) : 0,
            merkleRoot: isSet(object.merkleRoot)
                ? bytesFromBase64(object.merkleRoot)
                : new Uint8Array(),
            nonce: isSet(object.nonce) ? String(object.nonce) : '0',
            medianTimestamp: isSet(object.medianTimestamp)
                ? String(object.medianTimestamp)
                : '0',
        };
    },
    toJSON(message) {
        const obj = {};
        message.version !== undefined &&
            (obj.version = Math.round(message.version));
        message.merkleRoot !== undefined &&
            (obj.merkleRoot = base64FromBytes(message.merkleRoot !== undefined
                ? message.merkleRoot
                : new Uint8Array()));
        message.nonce !== undefined && (obj.nonce = message.nonce);
        message.medianTimestamp !== undefined &&
            (obj.medianTimestamp = message.medianTimestamp);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseBlockDetails();
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : 0;
        message.merkleRoot = (_b = object.merkleRoot) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.nonce = (_c = object.nonce) !== null && _c !== void 0 ? _c : '0';
        message.medianTimestamp = (_d = object.medianTimestamp) !== null && _d !== void 0 ? _d : '0';
        return message;
    },
};
function createBaseBlock() {
    return {
        blockInfo: undefined,
        blockDetails: undefined,
        rawHeader: new Uint8Array(),
        txs: [],
    };
}
exports.Block = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.blockInfo !== undefined) {
            exports.BlockInfo.encode(message.blockInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockDetails !== undefined) {
            exports.BlockDetails.encode(message.blockDetails, writer.uint32(26).fork()).ldelim();
        }
        if (message.rawHeader.length !== 0) {
            writer.uint32(34).bytes(message.rawHeader);
        }
        for (const v of message.txs) {
            exports.Tx.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockInfo = exports.BlockInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.blockDetails = exports.BlockDetails.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.rawHeader = reader.bytes();
                    break;
                case 2:
                    message.txs.push(exports.Tx.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockInfo: isSet(object.blockInfo)
                ? exports.BlockInfo.fromJSON(object.blockInfo)
                : undefined,
            blockDetails: isSet(object.blockDetails)
                ? exports.BlockDetails.fromJSON(object.blockDetails)
                : undefined,
            rawHeader: isSet(object.rawHeader)
                ? bytesFromBase64(object.rawHeader)
                : new Uint8Array(),
            txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs)
                ? object.txs.map((e) => exports.Tx.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.blockInfo !== undefined &&
            (obj.blockInfo = message.blockInfo
                ? exports.BlockInfo.toJSON(message.blockInfo)
                : undefined);
        message.blockDetails !== undefined &&
            (obj.blockDetails = message.blockDetails
                ? exports.BlockDetails.toJSON(message.blockDetails)
                : undefined);
        message.rawHeader !== undefined &&
            (obj.rawHeader = base64FromBytes(message.rawHeader !== undefined
                ? message.rawHeader
                : new Uint8Array()));
        if (message.txs) {
            obj.txs = message.txs.map(e => (e ? exports.Tx.toJSON(e) : undefined));
        }
        else {
            obj.txs = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBlock();
        message.blockInfo =
            object.blockInfo !== undefined && object.blockInfo !== null
                ? exports.BlockInfo.fromPartial(object.blockInfo)
                : undefined;
        message.blockDetails =
            object.blockDetails !== undefined && object.blockDetails !== null
                ? exports.BlockDetails.fromPartial(object.blockDetails)
                : undefined;
        message.rawHeader = (_a = object.rawHeader) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.txs = ((_b = object.txs) === null || _b === void 0 ? void 0 : _b.map(e => exports.Tx.fromPartial(e))) || [];
        return message;
    },
};
function createBaseScriptUtxos() {
    return { outputScript: new Uint8Array(), utxos: [] };
}
exports.ScriptUtxos = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.outputScript.length !== 0) {
            writer.uint32(10).bytes(message.outputScript);
        }
        for (const v of message.utxos) {
            exports.Utxo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScriptUtxos();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outputScript = reader.bytes();
                    break;
                case 2:
                    message.utxos.push(exports.Utxo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            outputScript: isSet(object.outputScript)
                ? bytesFromBase64(object.outputScript)
                : new Uint8Array(),
            utxos: Array.isArray(object === null || object === void 0 ? void 0 : object.utxos)
                ? object.utxos.map((e) => exports.Utxo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.outputScript !== undefined &&
            (obj.outputScript = base64FromBytes(message.outputScript !== undefined
                ? message.outputScript
                : new Uint8Array()));
        if (message.utxos) {
            obj.utxos = message.utxos.map(e => e ? exports.Utxo.toJSON(e) : undefined);
        }
        else {
            obj.utxos = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseScriptUtxos();
        message.outputScript = (_a = object.outputScript) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.utxos = ((_b = object.utxos) === null || _b === void 0 ? void 0 : _b.map(e => exports.Utxo.fromPartial(e))) || [];
        return message;
    },
};
function createBaseTxHistoryPage() {
    return { txs: [], numPages: 0 };
}
exports.TxHistoryPage = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.txs) {
            exports.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.numPages !== 0) {
            writer.uint32(16).uint32(message.numPages);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxHistoryPage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txs.push(exports.Tx.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.numPages = reader.uint32();
                    break;
                case 3:
                    message.numTxs = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs)
                ? object.txs.map((e) => exports.Tx.fromJSON(e))
                : [],
            numPages: isSet(object.numPages) ? Number(object.numPages) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txs) {
            obj.txs = message.txs.map(e => (e ? exports.Tx.toJSON(e) : undefined));
        }
        else {
            obj.txs = [];
        }
        message.numPages !== undefined &&
            (obj.numPages = Math.round(message.numPages));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTxHistoryPage();
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map(e => exports.Tx.fromPartial(e))) || [];
        message.numPages = (_b = object.numPages) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseUtxos() {
    return { scriptUtxos: [] };
}
exports.Utxos = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.scriptUtxos) {
            exports.ScriptUtxos.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUtxos();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.scriptUtxos.push(exports.ScriptUtxos.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            scriptUtxos: Array.isArray(object === null || object === void 0 ? void 0 : object.scriptUtxos)
                ? object.scriptUtxos.map((e) => exports.ScriptUtxos.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.scriptUtxos) {
            obj.scriptUtxos = message.scriptUtxos.map(e => e ? exports.ScriptUtxos.toJSON(e) : undefined);
        }
        else {
            obj.scriptUtxos = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUtxos();
        message.scriptUtxos =
            ((_a = object.scriptUtxos) === null || _a === void 0 ? void 0 : _a.map(e => exports.ScriptUtxos.fromPartial(e))) || [];
        return message;
    },
};
function createBaseBlocks() {
    return { blocks: [] };
}
exports.Blocks = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.blocks) {
            exports.BlockInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlocks();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blocks.push(exports.BlockInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            blocks: Array.isArray(object === null || object === void 0 ? void 0 : object.blocks)
                ? object.blocks.map((e) => exports.BlockInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.blocks) {
            obj.blocks = message.blocks.map(e => e ? exports.BlockInfo.toJSON(e) : undefined);
        }
        else {
            obj.blocks = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBlocks();
        message.blocks =
            ((_a = object.blocks) === null || _a === void 0 ? void 0 : _a.map(e => exports.BlockInfo.fromPartial(e))) || [];
        return message;
    },
};
function createBaseSlpTxData() {
    return { slpMeta: undefined, genesisInfo: undefined };
}
exports.SlpTxData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.slpMeta !== undefined) {
            exports.SlpMeta.encode(message.slpMeta, writer.uint32(10).fork()).ldelim();
        }
        if (message.genesisInfo !== undefined) {
            exports.SlpGenesisInfo.encode(message.genesisInfo, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSlpTxData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slpMeta = exports.SlpMeta.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.genesisInfo = exports.SlpGenesisInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slpMeta: isSet(object.slpMeta)
                ? exports.SlpMeta.fromJSON(object.slpMeta)
                : undefined,
            genesisInfo: isSet(object.genesisInfo)
                ? exports.SlpGenesisInfo.fromJSON(object.genesisInfo)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.slpMeta !== undefined &&
            (obj.slpMeta = message.slpMeta
                ? exports.SlpMeta.toJSON(message.slpMeta)
                : undefined);
        message.genesisInfo !== undefined &&
            (obj.genesisInfo = message.genesisInfo
                ? exports.SlpGenesisInfo.toJSON(message.genesisInfo)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSlpTxData();
        message.slpMeta =
            object.slpMeta !== undefined && object.slpMeta !== null
                ? exports.SlpMeta.fromPartial(object.slpMeta)
                : undefined;
        message.genesisInfo =
            object.genesisInfo !== undefined && object.genesisInfo !== null
                ? exports.SlpGenesisInfo.fromPartial(object.genesisInfo)
                : undefined;
        return message;
    },
};
function createBaseSlpMeta() {
    return {
        tokenType: 0,
        txType: 0,
        tokenId: new Uint8Array(),
        groupTokenId: new Uint8Array(),
    };
}
exports.SlpMeta = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.tokenType !== 0) {
            writer.uint32(8).int32(message.tokenType);
        }
        if (message.txType !== 0) {
            writer.uint32(16).int32(message.txType);
        }
        if (message.tokenId.length !== 0) {
            writer.uint32(26).bytes(message.tokenId);
        }
        if (message.groupTokenId.length !== 0) {
            writer.uint32(34).bytes(message.groupTokenId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSlpMeta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tokenType = reader.int32();
                    break;
                case 2:
                    message.txType = reader.int32();
                    break;
                case 3:
                    message.tokenId = reader.bytes();
                    break;
                case 4:
                    message.groupTokenId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenType: isSet(object.tokenType)
                ? slpTokenTypeFromJSON(object.tokenType)
                : 0,
            txType: isSet(object.txType) ? slpTxTypeFromJSON(object.txType) : 0,
            tokenId: isSet(object.tokenId)
                ? bytesFromBase64(object.tokenId)
                : new Uint8Array(),
            groupTokenId: isSet(object.groupTokenId)
                ? bytesFromBase64(object.groupTokenId)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.tokenType !== undefined &&
            (obj.tokenType = slpTokenTypeToJSON(message.tokenType));
        message.txType !== undefined &&
            (obj.txType = slpTxTypeToJSON(message.txType));
        message.tokenId !== undefined &&
            (obj.tokenId = base64FromBytes(message.tokenId !== undefined
                ? message.tokenId
                : new Uint8Array()));
        message.groupTokenId !== undefined &&
            (obj.groupTokenId = base64FromBytes(message.groupTokenId !== undefined
                ? message.groupTokenId
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSlpMeta();
        message.tokenType = (_a = object.tokenType) !== null && _a !== void 0 ? _a : 0;
        message.txType = (_b = object.txType) !== null && _b !== void 0 ? _b : 0;
        message.tokenId = (_c = object.tokenId) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.groupTokenId = (_d = object.groupTokenId) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    },
};
function createBaseTokenStats() {
    return { totalMinted: '', totalBurned: '' };
}
exports.TokenStats = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.totalMinted !== '') {
            writer.uint32(10).string(message.totalMinted);
        }
        if (message.totalBurned !== '') {
            writer.uint32(18).string(message.totalBurned);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.totalMinted = reader.string();
                    break;
                case 2:
                    message.totalBurned = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            totalMinted: isSet(object.totalMinted)
                ? String(object.totalMinted)
                : '',
            totalBurned: isSet(object.totalBurned)
                ? String(object.totalBurned)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.totalMinted !== undefined &&
            (obj.totalMinted = message.totalMinted);
        message.totalBurned !== undefined &&
            (obj.totalBurned = message.totalBurned);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTokenStats();
        message.totalMinted = (_a = object.totalMinted) !== null && _a !== void 0 ? _a : '';
        message.totalBurned = (_b = object.totalBurned) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseTxInput() {
    return {
        prevOut: undefined,
        inputScript: new Uint8Array(),
        outputScript: new Uint8Array(),
        value: '0',
        sequenceNo: 0,
        slpBurn: undefined,
        slpToken: undefined,
    };
}
exports.TxInput = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.prevOut !== undefined) {
            exports.OutPoint.encode(message.prevOut, writer.uint32(10).fork()).ldelim();
        }
        if (message.inputScript.length !== 0) {
            writer.uint32(18).bytes(message.inputScript);
        }
        if (message.outputScript.length !== 0) {
            writer.uint32(26).bytes(message.outputScript);
        }
        if (message.value !== '0') {
            writer.uint32(32).int64(message.value);
        }
        if (message.sequenceNo !== 0) {
            writer.uint32(40).uint32(message.sequenceNo);
        }
        if (message.slpBurn !== undefined) {
            exports.SlpBurn.encode(message.slpBurn, writer.uint32(50).fork()).ldelim();
        }
        if (message.slpToken !== undefined) {
            exports.SlpToken.encode(message.slpToken, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.prevOut = exports.OutPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.inputScript = reader.bytes();
                    break;
                case 3:
                    message.outputScript = reader.bytes();
                    break;
                case 4:
                    message.value = longToString(reader.int64());
                    break;
                case 5:
                    message.sequenceNo = reader.uint32();
                    break;
                case 6:
                    message.slpBurn = exports.SlpBurn.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.slpToken = exports.SlpToken.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            prevOut: isSet(object.prevOut)
                ? exports.OutPoint.fromJSON(object.prevOut)
                : undefined,
            inputScript: isSet(object.inputScript)
                ? bytesFromBase64(object.inputScript)
                : new Uint8Array(),
            outputScript: isSet(object.outputScript)
                ? bytesFromBase64(object.outputScript)
                : new Uint8Array(),
            value: isSet(object.value) ? String(object.value) : '0',
            sequenceNo: isSet(object.sequenceNo)
                ? Number(object.sequenceNo)
                : 0,
            slpBurn: isSet(object.slpBurn)
                ? exports.SlpBurn.fromJSON(object.slpBurn)
                : undefined,
            slpToken: isSet(object.slpToken)
                ? exports.SlpToken.fromJSON(object.slpToken)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.prevOut !== undefined &&
            (obj.prevOut = message.prevOut
                ? exports.OutPoint.toJSON(message.prevOut)
                : undefined);
        message.inputScript !== undefined &&
            (obj.inputScript = base64FromBytes(message.inputScript !== undefined
                ? message.inputScript
                : new Uint8Array()));
        message.outputScript !== undefined &&
            (obj.outputScript = base64FromBytes(message.outputScript !== undefined
                ? message.outputScript
                : new Uint8Array()));
        message.value !== undefined && (obj.value = message.value);
        message.sequenceNo !== undefined &&
            (obj.sequenceNo = Math.round(message.sequenceNo));
        message.slpBurn !== undefined &&
            (obj.slpBurn = message.slpBurn
                ? exports.SlpBurn.toJSON(message.slpBurn)
                : undefined);
        message.slpToken !== undefined &&
            (obj.slpToken = message.slpToken
                ? exports.SlpToken.toJSON(message.slpToken)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTxInput();
        message.prevOut =
            object.prevOut !== undefined && object.prevOut !== null
                ? exports.OutPoint.fromPartial(object.prevOut)
                : undefined;
        message.inputScript = (_a = object.inputScript) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.outputScript = (_b = object.outputScript) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.value = (_c = object.value) !== null && _c !== void 0 ? _c : '0';
        message.sequenceNo = (_d = object.sequenceNo) !== null && _d !== void 0 ? _d : 0;
        message.slpBurn =
            object.slpBurn !== undefined && object.slpBurn !== null
                ? exports.SlpBurn.fromPartial(object.slpBurn)
                : undefined;
        message.slpToken =
            object.slpToken !== undefined && object.slpToken !== null
                ? exports.SlpToken.fromPartial(object.slpToken)
                : undefined;
        return message;
    },
};
function createBaseTxOutput() {
    return {
        value: '0',
        outputScript: new Uint8Array(),
        slpToken: undefined,
        spentBy: undefined,
    };
}
exports.TxOutput = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== '0') {
            writer.uint32(8).int64(message.value);
        }
        if (message.outputScript.length !== 0) {
            writer.uint32(18).bytes(message.outputScript);
        }
        if (message.slpToken !== undefined) {
            exports.SlpToken.encode(message.slpToken, writer.uint32(26).fork()).ldelim();
        }
        if (message.spentBy !== undefined) {
            exports.OutPoint.encode(message.spentBy, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = longToString(reader.int64());
                    break;
                case 2:
                    message.outputScript = reader.bytes();
                    break;
                case 3:
                    message.slpToken = exports.SlpToken.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.spentBy = exports.OutPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? String(object.value) : '0',
            outputScript: isSet(object.outputScript)
                ? bytesFromBase64(object.outputScript)
                : new Uint8Array(),
            slpToken: isSet(object.slpToken)
                ? exports.SlpToken.fromJSON(object.slpToken)
                : undefined,
            spentBy: isSet(object.spentBy)
                ? exports.OutPoint.fromJSON(object.spentBy)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.value !== undefined && (obj.value = message.value);
        message.outputScript !== undefined &&
            (obj.outputScript = base64FromBytes(message.outputScript !== undefined
                ? message.outputScript
                : new Uint8Array()));
        message.slpToken !== undefined &&
            (obj.slpToken = message.slpToken
                ? exports.SlpToken.toJSON(message.slpToken)
                : undefined);
        message.spentBy !== undefined &&
            (obj.spentBy = message.spentBy
                ? exports.OutPoint.toJSON(message.spentBy)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTxOutput();
        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : '0';
        message.outputScript = (_b = object.outputScript) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.slpToken =
            object.slpToken !== undefined && object.slpToken !== null
                ? exports.SlpToken.fromPartial(object.slpToken)
                : undefined;
        message.spentBy =
            object.spentBy !== undefined && object.spentBy !== null
                ? exports.OutPoint.fromPartial(object.spentBy)
                : undefined;
        return message;
    },
};
function createBaseBlockMetadata() {
    return { height: 0, hash: new Uint8Array(), timestamp: '0' };
}
exports.BlockMetadata = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).int32(message.height);
        }
        if (message.hash.length !== 0) {
            writer.uint32(18).bytes(message.hash);
        }
        if (message.timestamp !== '0') {
            writer.uint32(24).int64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.height = reader.int32();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                case 3:
                    message.timestamp = longToString(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? Number(object.height) : 0,
            hash: isSet(object.hash)
                ? bytesFromBase64(object.hash)
                : new Uint8Array(),
            timestamp: isSet(object.timestamp) ? String(object.timestamp) : '0',
        };
    },
    toJSON(message) {
        const obj = {};
        message.height !== undefined &&
            (obj.height = Math.round(message.height));
        message.hash !== undefined &&
            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseBlockMetadata();
        message.height = (_a = object.height) !== null && _a !== void 0 ? _a : 0;
        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.timestamp = (_c = object.timestamp) !== null && _c !== void 0 ? _c : '0';
        return message;
    },
};
function createBaseOutPoint() {
    return { txid: new Uint8Array(), outIdx: 0 };
}
exports.OutPoint = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        if (message.outIdx !== 0) {
            writer.uint32(16).uint32(message.outIdx);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutPoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                case 2:
                    message.outIdx = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
            outIdx: isSet(object.outIdx) ? Number(object.outIdx) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        message.outIdx !== undefined &&
            (obj.outIdx = Math.round(message.outIdx));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseOutPoint();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.outIdx = (_b = object.outIdx) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseSlpToken() {
    return { amount: '0', isMintBaton: false };
}
exports.SlpToken = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.amount !== '0') {
            writer.uint32(8).uint64(message.amount);
        }
        if (message.isMintBaton === true) {
            writer.uint32(16).bool(message.isMintBaton);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSlpToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount = longToString(reader.uint64());
                    break;
                case 2:
                    message.isMintBaton = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            amount: isSet(object.amount) ? String(object.amount) : '0',
            isMintBaton: isSet(object.isMintBaton)
                ? Boolean(object.isMintBaton)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.amount !== undefined && (obj.amount = message.amount);
        message.isMintBaton !== undefined &&
            (obj.isMintBaton = message.isMintBaton);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSlpToken();
        message.amount = (_a = object.amount) !== null && _a !== void 0 ? _a : '0';
        message.isMintBaton = (_b = object.isMintBaton) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseSlpBurn() {
    return { token: undefined, tokenId: new Uint8Array() };
}
exports.SlpBurn = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.token !== undefined) {
            exports.SlpToken.encode(message.token, writer.uint32(10).fork()).ldelim();
        }
        if (message.tokenId.length !== 0) {
            writer.uint32(18).bytes(message.tokenId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSlpBurn();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = exports.SlpToken.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tokenId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            token: isSet(object.token)
                ? exports.SlpToken.fromJSON(object.token)
                : undefined,
            tokenId: isSet(object.tokenId)
                ? bytesFromBase64(object.tokenId)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.token !== undefined &&
            (obj.token = message.token
                ? exports.SlpToken.toJSON(message.token)
                : undefined);
        message.tokenId !== undefined &&
            (obj.tokenId = base64FromBytes(message.tokenId !== undefined
                ? message.tokenId
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSlpBurn();
        message.token =
            object.token !== undefined && object.token !== null
                ? exports.SlpToken.fromPartial(object.token)
                : undefined;
        message.tokenId = (_a = object.tokenId) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseSlpGenesisInfo() {
    return {
        tokenTicker: new Uint8Array(),
        tokenName: new Uint8Array(),
        tokenDocumentUrl: new Uint8Array(),
        tokenDocumentHash: new Uint8Array(),
        decimals: 0,
    };
}
exports.SlpGenesisInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.tokenTicker.length !== 0) {
            writer.uint32(10).bytes(message.tokenTicker);
        }
        if (message.tokenName.length !== 0) {
            writer.uint32(18).bytes(message.tokenName);
        }
        if (message.tokenDocumentUrl.length !== 0) {
            writer.uint32(26).bytes(message.tokenDocumentUrl);
        }
        if (message.tokenDocumentHash.length !== 0) {
            writer.uint32(34).bytes(message.tokenDocumentHash);
        }
        if (message.decimals !== 0) {
            writer.uint32(40).uint32(message.decimals);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSlpGenesisInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tokenTicker = reader.bytes();
                    break;
                case 2:
                    message.tokenName = reader.bytes();
                    break;
                case 3:
                    message.tokenDocumentUrl = reader.bytes();
                    break;
                case 4:
                    message.tokenDocumentHash = reader.bytes();
                    break;
                case 5:
                    message.decimals = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenTicker: isSet(object.tokenTicker)
                ? bytesFromBase64(object.tokenTicker)
                : new Uint8Array(),
            tokenName: isSet(object.tokenName)
                ? bytesFromBase64(object.tokenName)
                : new Uint8Array(),
            tokenDocumentUrl: isSet(object.tokenDocumentUrl)
                ? bytesFromBase64(object.tokenDocumentUrl)
                : new Uint8Array(),
            tokenDocumentHash: isSet(object.tokenDocumentHash)
                ? bytesFromBase64(object.tokenDocumentHash)
                : new Uint8Array(),
            decimals: isSet(object.decimals) ? Number(object.decimals) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.tokenTicker !== undefined &&
            (obj.tokenTicker = base64FromBytes(message.tokenTicker !== undefined
                ? message.tokenTicker
                : new Uint8Array()));
        message.tokenName !== undefined &&
            (obj.tokenName = base64FromBytes(message.tokenName !== undefined
                ? message.tokenName
                : new Uint8Array()));
        message.tokenDocumentUrl !== undefined &&
            (obj.tokenDocumentUrl = base64FromBytes(message.tokenDocumentUrl !== undefined
                ? message.tokenDocumentUrl
                : new Uint8Array()));
        message.tokenDocumentHash !== undefined &&
            (obj.tokenDocumentHash = base64FromBytes(message.tokenDocumentHash !== undefined
                ? message.tokenDocumentHash
                : new Uint8Array()));
        message.decimals !== undefined &&
            (obj.decimals = Math.round(message.decimals));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseSlpGenesisInfo();
        message.tokenTicker = (_a = object.tokenTicker) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.tokenName = (_b = object.tokenName) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.tokenDocumentUrl = (_c = object.tokenDocumentUrl) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.tokenDocumentHash =
            (_d = object.tokenDocumentHash) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.decimals = (_e = object.decimals) !== null && _e !== void 0 ? _e : 0;
        return message;
    },
};
function createBaseUtxoState() {
    return { height: 0, isConfirmed: false, state: 0 };
}
exports.UtxoState = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).int32(message.height);
        }
        if (message.isConfirmed === true) {
            writer.uint32(16).bool(message.isConfirmed);
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUtxoState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.height = reader.int32();
                    break;
                case 2:
                    message.isConfirmed = reader.bool();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? Number(object.height) : 0,
            isConfirmed: isSet(object.isConfirmed)
                ? Boolean(object.isConfirmed)
                : false,
            state: isSet(object.state)
                ? utxoStateVariantFromJSON(object.state)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.height !== undefined &&
            (obj.height = Math.round(message.height));
        message.isConfirmed !== undefined &&
            (obj.isConfirmed = message.isConfirmed);
        message.state !== undefined &&
            (obj.state = utxoStateVariantToJSON(message.state));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUtxoState();
        message.height = (_a = object.height) !== null && _a !== void 0 ? _a : 0;
        message.isConfirmed = (_b = object.isConfirmed) !== null && _b !== void 0 ? _b : false;
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseSubscription() {
    return { scriptType: '', payload: new Uint8Array(), isSubscribe: false };
}
exports.Subscription = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.scriptType !== '') {
            writer.uint32(10).string(message.scriptType);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        if (message.isSubscribe === true) {
            writer.uint32(24).bool(message.isSubscribe);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.scriptType = reader.string();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.isSubscribe = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            scriptType: isSet(object.scriptType)
                ? String(object.scriptType)
                : '',
            payload: isSet(object.payload)
                ? bytesFromBase64(object.payload)
                : new Uint8Array(),
            isSubscribe: isSet(object.isSubscribe)
                ? Boolean(object.isSubscribe)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.scriptType !== undefined &&
            (obj.scriptType = message.scriptType);
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined
                ? message.payload
                : new Uint8Array()));
        message.isSubscribe !== undefined &&
            (obj.isSubscribe = message.isSubscribe);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSubscription();
        message.scriptType = (_a = object.scriptType) !== null && _a !== void 0 ? _a : '';
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.isSubscribe = (_c = object.isSubscribe) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
function createBaseSubscriptionNode() {
    return { isUnsubscribe: false, subscriptionObject: {} };
}
exports.SubscriptionNode = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.isUnsubscribe === true) {
            writer.uint32(10).bool(message.isUnsubscribe);
        }
        if (message.subscriptionObject !== undefined) {
            exports.SubscriptionObject.encode(message.subscriptionObject, writer.uint32(20).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscriptionNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isUnsubscribe = reader.bool();
                    break;
                case 2:
                    // Subscription to blocks
                    message.subscriptionObject = {};
                    break;
                case 3:
                    message.subscriptionObject = exports.SubscriptionObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isUnsubscribe: isSet(object.isUnsubscribe)
                ? Boolean(object.isUnsubscribe)
                : false,
            subscriptionObject: isSet(object.subscriptionObject)
                ? exports.SubscriptionObject.fromJSON(object.subscriptionObject)
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.isUnsubscribe !== undefined &&
            (obj.isUnsubscribe = message.isUnsubscribe);
        message.subscriptionObject !== undefined &&
            (obj.subscriptionObject = message.subscriptionObject
                ? exports.SubscriptionObject.toJSON(message.subscriptionObject)
                : {});
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSubscriptionNode();
        message.isUnsubscribe = (_a = object.isUnsubscribe) !== null && _a !== void 0 ? _a : false;
        message.subscriptionObject = (_b = object.subscriptionObject) !== null && _b !== void 0 ? _b : {};
        return message;
    },
};
function createBaseSubscribeMsg() {
    return {
        error: undefined,
        AddedToMempool: undefined,
        RemovedFromMempool: undefined,
        Confirmed: undefined,
        Reorg: undefined,
        BlockConnected: undefined,
        BlockDisconnected: undefined,
    };
}
exports.SubscribeMsg = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== undefined) {
            exports.Error.encode(message.error, writer.uint32(10).fork()).ldelim();
        }
        if (message.AddedToMempool !== undefined) {
            exports.MsgAddedToMempool.encode(message.AddedToMempool, writer.uint32(18).fork()).ldelim();
        }
        if (message.RemovedFromMempool !== undefined) {
            exports.MsgRemovedFromMempool.encode(message.RemovedFromMempool, writer.uint32(26).fork()).ldelim();
        }
        if (message.Confirmed !== undefined) {
            exports.MsgConfirmed.encode(message.Confirmed, writer.uint32(34).fork()).ldelim();
        }
        if (message.Reorg !== undefined) {
            exports.MsgReorg.encode(message.Reorg, writer.uint32(42).fork()).ldelim();
        }
        if (message.BlockConnected !== undefined) {
            exports.MsgBlockConnected.encode(message.BlockConnected, writer.uint32(50).fork()).ldelim();
        }
        if (message.BlockDisconnected !== undefined) {
            exports.MsgBlockDisconnected.encode(message.BlockDisconnected, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeMsg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.error = exports.Error.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.AddedToMempool = exports.MsgAddedToMempool.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.RemovedFromMempool = exports.MsgRemovedFromMempool.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.Confirmed = exports.MsgConfirmed.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.Reorg = exports.MsgReorg.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.BlockConnected = exports.MsgBlockConnected.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.BlockDisconnected = exports.MsgBlockDisconnected.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            error: isSet(object.error)
                ? exports.Error.fromJSON(object.error)
                : undefined,
            AddedToMempool: isSet(object.AddedToMempool)
                ? exports.MsgAddedToMempool.fromJSON(object.AddedToMempool)
                : undefined,
            RemovedFromMempool: isSet(object.RemovedFromMempool)
                ? exports.MsgRemovedFromMempool.fromJSON(object.RemovedFromMempool)
                : undefined,
            Confirmed: isSet(object.Confirmed)
                ? exports.MsgConfirmed.fromJSON(object.Confirmed)
                : undefined,
            Reorg: isSet(object.Reorg)
                ? exports.MsgReorg.fromJSON(object.Reorg)
                : undefined,
            BlockConnected: isSet(object.BlockConnected)
                ? exports.MsgBlockConnected.fromJSON(object.BlockConnected)
                : undefined,
            BlockDisconnected: isSet(object.BlockDisconnected)
                ? exports.MsgBlockDisconnected.fromJSON(object.BlockDisconnected)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.error !== undefined &&
            (obj.error = message.error
                ? exports.Error.toJSON(message.error)
                : undefined);
        message.AddedToMempool !== undefined &&
            (obj.AddedToMempool = message.AddedToMempool
                ? exports.MsgAddedToMempool.toJSON(message.AddedToMempool)
                : undefined);
        message.RemovedFromMempool !== undefined &&
            (obj.RemovedFromMempool = message.RemovedFromMempool
                ? exports.MsgRemovedFromMempool.toJSON(message.RemovedFromMempool)
                : undefined);
        message.Confirmed !== undefined &&
            (obj.Confirmed = message.Confirmed
                ? exports.MsgConfirmed.toJSON(message.Confirmed)
                : undefined);
        message.Reorg !== undefined &&
            (obj.Reorg = message.Reorg
                ? exports.MsgReorg.toJSON(message.Reorg)
                : undefined);
        message.BlockConnected !== undefined &&
            (obj.BlockConnected = message.BlockConnected
                ? exports.MsgBlockConnected.toJSON(message.BlockConnected)
                : undefined);
        message.BlockDisconnected !== undefined &&
            (obj.BlockDisconnected = message.BlockDisconnected
                ? exports.MsgBlockDisconnected.toJSON(message.BlockDisconnected)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseSubscribeMsg();
        message.error =
            object.error !== undefined && object.error !== null
                ? exports.Error.fromPartial(object.error)
                : undefined;
        message.AddedToMempool =
            object.AddedToMempool !== undefined &&
                object.AddedToMempool !== null
                ? exports.MsgAddedToMempool.fromPartial(object.AddedToMempool)
                : undefined;
        message.RemovedFromMempool =
            object.RemovedFromMempool !== undefined &&
                object.RemovedFromMempool !== null
                ? exports.MsgRemovedFromMempool.fromPartial(object.RemovedFromMempool)
                : undefined;
        message.Confirmed =
            object.Confirmed !== undefined && object.Confirmed !== null
                ? exports.MsgConfirmed.fromPartial(object.Confirmed)
                : undefined;
        message.Reorg =
            object.Reorg !== undefined && object.Reorg !== null
                ? exports.MsgReorg.fromPartial(object.Reorg)
                : undefined;
        message.BlockConnected =
            object.BlockConnected !== undefined &&
                object.BlockConnected !== null
                ? exports.MsgBlockConnected.fromPartial(object.BlockConnected)
                : undefined;
        message.BlockDisconnected =
            object.BlockDisconnected !== undefined &&
                object.BlockDisconnected !== null
                ? exports.MsgBlockDisconnected.fromPartial(object.BlockDisconnected)
                : undefined;
        return message;
    },
};
function createBaseMsgAddedToMempool() {
    return { txid: new Uint8Array() };
}
exports.MsgAddedToMempool = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddedToMempool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgAddedToMempool();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseMsgRemovedFromMempool() {
    return { txid: new Uint8Array() };
}
exports.MsgRemovedFromMempool = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemovedFromMempool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgRemovedFromMempool();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseMsgConfirmed() {
    return { txid: new Uint8Array() };
}
exports.MsgConfirmed = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgConfirmed();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseMsgReorg() {
    return { txid: new Uint8Array() };
}
exports.MsgReorg = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgReorg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid)
                ? bytesFromBase64(object.txid)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.txid !== undefined &&
            (obj.txid = base64FromBytes(message.txid !== undefined ? message.txid : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgReorg();
        message.txid = (_a = object.txid) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseMsgBlockConnected() {
    return { blockHash: new Uint8Array() };
}
exports.MsgBlockConnected = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.blockHash.length !== 0) {
            writer.uint32(10).bytes(message.blockHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBlockConnected();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockHash: isSet(object.blockHash)
                ? bytesFromBase64(object.blockHash)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.blockHash !== undefined &&
            (obj.blockHash = base64FromBytes(message.blockHash !== undefined
                ? message.blockHash
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgBlockConnected();
        message.blockHash = (_a = object.blockHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseMsgBlockDisconnected() {
    return { blockHash: new Uint8Array() };
}
exports.MsgBlockDisconnected = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.blockHash.length !== 0) {
            writer.uint32(10).bytes(message.blockHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBlockDisconnected();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockHash: isSet(object.blockHash)
                ? bytesFromBase64(object.blockHash)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.blockHash !== undefined &&
            (obj.blockHash = base64FromBytes(message.blockHash !== undefined
                ? message.blockHash
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgBlockDisconnected();
        message.blockHash = (_a = object.blockHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseError() {
    return { errorCode: '', msg: '', isUserError: false };
}
exports.Error = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.errorCode !== '') {
            writer.uint32(10).string(message.errorCode);
        }
        if (message.msg !== '') {
            writer.uint32(18).string(message.msg);
        }
        if (message.isUserError === true) {
            writer.uint32(24).bool(message.isUserError);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.errorCode = reader.string();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                case 3:
                    message.isUserError = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            errorCode: isSet(object.errorCode) ? String(object.errorCode) : '',
            msg: isSet(object.msg) ? String(object.msg) : '',
            isUserError: isSet(object.isUserError)
                ? Boolean(object.isUserError)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.errorCode !== undefined && (obj.errorCode = message.errorCode);
        message.msg !== undefined && (obj.msg = message.msg);
        message.isUserError !== undefined &&
            (obj.isUserError = message.isUserError);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseError();
        message.errorCode = (_a = object.errorCode) !== null && _a !== void 0 ? _a : '';
        message.msg = (_b = object.msg) !== null && _b !== void 0 ? _b : '';
        message.isUserError = (_c = object.isUserError) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof global !== 'undefined')
        return global;
    throw 'Unable to locate global object';
})();
const atob = globalThis.atob ||
    (b64 => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    (bin => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach(byte => {
        bin.push(String.fromCharCode(byte));
    });
    return btoa(bin.join(''));
}
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=chronik.js.map