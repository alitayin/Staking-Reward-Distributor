"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsEndpoint = exports.ScriptEndpoint = exports.ChronikClient = void 0;
const axios_1 = __importDefault(require("axios"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const proto = __importStar(require("./chronik"));
const hex_1 = require("./hex");
/** Client to access an NNG Chronik or in-node instance. Plain object, without any
 * connections. */
class ChronikClient {
    /**
     * Create a new client. This just creates an object, without any connections.
     *
     * @param url Url of a Chronik instance, with schema and without trailing
     *            slash. E.g. https://chronik.be.cash/xec.
     */
    constructor(url) {
        this._url = url;
        if (url.endsWith('/')) {
            throw new Error("`url` cannot end with '/', got: " + url);
        }
        if (url.startsWith('https://')) {
            this._wsUrl = 'wss://' + url.substring('https://'.length);
        }
        else if (url.startsWith('http://')) {
            this._wsUrl = 'ws://' + url.substring('http://'.length);
        }
        else {
            throw new Error("`url` must start with 'https://' or 'http://', got: " + url);
        }
    }
    /** Broadcasts the `rawTx` on the network.
     * If `skipSlpCheck` is false, it will be checked that the tx doesn't burn
     * any SLP tokens before broadcasting.
     */
    broadcastTx(rawTx, skipSlpCheck = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = proto.BroadcastTxRequest.encode({
                rawTx: typeof rawTx === 'string' ? (0, hex_1.fromHex)(rawTx) : rawTx,
                skipSlpCheck,
            }).finish();
            const data = yield _post(this._url, '/broadcast-tx', request);
            const broadcastResponse = proto.BroadcastTxResponse.decode(data);
            return {
                txid: (0, hex_1.toHexRev)(broadcastResponse.txid),
            };
        });
    }
    /** Broadcasts the `rawTxs` on the network, only if all of them are valid.
     * If `skipSlpCheck` is false, it will be checked that the txs don't burn
     * any SLP tokens before broadcasting.
     */
    broadcastTxs(rawTxs, skipSlpCheck = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = proto.BroadcastTxsRequest.encode({
                rawTxs: rawTxs.map(rawTx => typeof rawTx === 'string' ? (0, hex_1.fromHex)(rawTx) : rawTx),
                skipSlpCheck,
            }).finish();
            const data = yield _post(this._url, '/broadcast-txs', request);
            const broadcastResponse = proto.BroadcastTxsResponse.decode(data);
            return {
                txids: broadcastResponse.txids.map(hex_1.toHexRev),
            };
        });
    }
    /** Fetch current info of the blockchain, such as tip hash and height. */
    blockchainInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield _get(this._url, `/blockchain-info`);
            const blockchainInfo = proto.BlockchainInfo.decode(data);
            return convertToBlockchainInfo(blockchainInfo);
        });
    }
    /** Fetch the block given hash or height. */
    block(hashOrHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield _get(this._url, `/block/${hashOrHeight}`);
            const block = proto.Block.decode(data);
            return convertToBlock(block);
        });
    }
    /** Fetch block info of a range of blocks. `startHeight` and `endHeight` are
     * inclusive ranges. */
    blocks(startHeight, endHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield _get(this._url, `/blocks/${startHeight}/${endHeight}`);
            const blocks = proto.Blocks.decode(data);
            return blocks.blocks.map(convertToBlockInfo);
        });
    }
    /** Fetch tx details given the txid. */
    tx(txid) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield _get(this._url, `/tx/${txid}`);
            const tx = proto.Tx.decode(data);
            return convertToTx(tx);
        });
    }
    /** Fetch token info and stats given the tokenId. */
    token(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield _get(this._url, `/token/${tokenId}`);
            const token = proto.Token.decode(data);
            return convertToToken(token);
        });
    }
    /** Validate the given outpoints: whether they are unspent, spent or
     * never existed. */
    validateUtxos(outpoints) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = proto.ValidateUtxoRequest.encode({
                outpoints: outpoints.map(outpoint => ({
                    txid: (0, hex_1.fromHexRev)(outpoint.txid),
                    outIdx: outpoint.outIdx,
                })),
            }).finish();
            const data = yield _post(this._url, '/validate-utxos', request);
            const validationStates = proto.ValidateUtxoResponse.decode(data);
            return validationStates.utxoStates.map(state => ({
                height: state.height,
                isConfirmed: state.isConfirmed,
                state: convertToUtxoStateVariant(state.state),
            }));
        });
    }
    /** Create object that allows fetching script history or UTXOs. */
    script(scriptType, scriptPayload) {
        return new ScriptEndpoint(this._url, scriptType, scriptPayload);
    }
    /** Open a WebSocket connection to listen for updates. */
    ws(config) {
        return new WsEndpoint(`${this._wsUrl}/ws`, config);
    }
}
exports.ChronikClient = ChronikClient;
/** Allows fetching script history and UTXOs. */
class ScriptEndpoint {
    constructor(url, scriptType, scriptPayload) {
        this._url = url;
        this._scriptType = scriptType;
        this._scriptPayload = scriptPayload;
    }
    /** Fetches the tx history of this script, in anti-chronological order.
     * This means it's ordered by first-seen first. If the tx hasn't been seen
     * by the indexer before, it's ordered by the block timestamp.
     * @param page Page index of the tx history.
     * @param pageSize Number of txs per page.
     */
    history(page, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = page !== undefined && pageSize !== undefined
                ? `?page=${page}&page_size=${pageSize}`
                : page !== undefined
                    ? `?page=${page}`
                    : pageSize !== undefined
                        ? `?page_size=${pageSize}`
                        : '';
            const data = yield _get(this._url, `/script/${this._scriptType}/${this._scriptPayload}/history${query}`);
            const historyPage = proto.TxHistoryPage.decode(data);
            if (typeof historyPage.numTxs !== 'undefined') {
                return {
                    txs: historyPage.txs.map(convertToTx),
                    numPages: historyPage.numPages,
                    numTxs: historyPage.numTxs,
                };
            }
            return {
                txs: historyPage.txs.map(convertToTx),
                numPages: historyPage.numPages,
            };
        });
    }
    /** Fetches the current UTXO set for this script.
     * It is grouped by output script, in case a script type can match multiple
     * different output scripts (e.g. Taproot on Lotus). */
    utxos() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield _get(this._url, `/script/${this._scriptType}/${this._scriptPayload}/utxos`);
            /**
             * nng chronik returns an object with array at scriptUtxos key
             * For XEC, desired utxos are always at Utxos.scriptUtxos[0].utxos
             * interface Utxos {
                   scriptUtxos: ScriptUtxos[];
                }
    
                in-node chronik returns an object ScriptUtxos
                interface ScriptUtxos {
                    // The serialized script of the UTXOs
                    bytes script = 1;
                    
                    // UTXOs of the script.
                    repeated ScriptUtxo utxos = 2;
                }
             */
            let utxos;
            try {
                // Try nng parsing first
                utxos = proto.Utxos.decode(data);
                return utxos.scriptUtxos.map(scriptUtxos => ({
                    outputScript: (0, hex_1.toHex)(scriptUtxos.outputScript),
                    utxos: scriptUtxos.utxos.map(convertToUtxo),
                }));
            }
            catch (err) {
                // in-node processing
                utxos = proto.ScriptUtxos.decode(data);
                // Return as array so that compatibility is preserved for both NNG and in-node
                return [
                    {
                        outputScript: (0, hex_1.toHex)(utxos.outputScript),
                        utxos: utxos.utxos.map(convertToUtxo),
                    },
                ];
            }
        });
    }
}
exports.ScriptEndpoint = ScriptEndpoint;
/** WebSocket connection to Chronik. */
class WsEndpoint {
    constructor(wsUrl, config) {
        this.onMessage = config.onMessage;
        this.onConnect = config.onConnect;
        this.onReconnect = config.onReconnect;
        this.onEnd = config.onEnd;
        this.autoReconnect =
            config.autoReconnect !== undefined ? config.autoReconnect : true;
        this._manuallyClosed = false;
        this._subs = [];
        this._subsNode = [];
        this._wsUrl = wsUrl;
        this._connect();
    }
    /** Wait for the WebSocket to be connected. */
    waitForOpen() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._connected;
        });
    }
    /** Subscribe to the given script type and payload.
     * For "p2pkh", `scriptPayload` is the 20 byte public key hash. */
    subscribe(scriptType, scriptPayload) {
        var _a;
        this._subs.push({ scriptType, scriptPayload });
        if (((_a = this._ws) === null || _a === void 0 ? void 0 : _a.readyState) === isomorphic_ws_1.default.OPEN) {
            this._subUnsub(true, scriptType, scriptPayload);
        }
    }
    subscribeNode(subscriptionObject) {
        var _a;
        this._subsNode.push(subscriptionObject);
        if (((_a = this._ws) === null || _a === void 0 ? void 0 : _a.readyState) === isomorphic_ws_1.default.OPEN) {
            this._subUnsubNode(true, subscriptionObject);
        }
    }
    /** Unsubscribe from the given script type and payload. */
    unsubscribe(scriptType, scriptPayload) {
        var _a;
        this._subs = this._subs.filter(sub => sub.scriptType !== scriptType ||
            sub.scriptPayload !== scriptPayload);
        if (((_a = this._ws) === null || _a === void 0 ? void 0 : _a.readyState) === isomorphic_ws_1.default.OPEN) {
            this._subUnsub(false, scriptType, scriptPayload);
        }
    }
    unsubscribeNode(subscriptionObject) {
        var _a;
        // TODO remove blocks sub if that's what you have
        const { scriptType, scriptPayload } = subscriptionObject;
        this._subsNode = this._subsNode.filter(sub => sub.scriptType !== scriptType ||
            sub.scriptPayload !== scriptPayload);
        if (((_a = this._ws) === null || _a === void 0 ? void 0 : _a.readyState) === isomorphic_ws_1.default.OPEN) {
            this._subUnsubNode(false, subscriptionObject);
        }
    }
    /** Close the WebSocket connection and prevent future any reconnection
     * attempts. */
    close() {
        var _a;
        this._manuallyClosed = true;
        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.close();
    }
    _connect() {
        const ws = new isomorphic_ws_1.default(this._wsUrl);
        this._ws = ws;
        this._connected = new Promise(resolved => {
            ws.onopen = msg => {
                this._subs.forEach(sub => this._subUnsub(true, sub.scriptType, sub.scriptPayload));
                this._subsNode.forEach(subNode => {
                    this._subUnsubNode(true, subNode);
                });
                resolved(msg);
                if (this.onConnect !== undefined) {
                    this.onConnect(msg);
                }
            };
        });
        ws.onmessage = e => this._handleMsg(e);
        ws.onerror = e => this.onError !== undefined && this.onError(e);
        ws.onclose = e => {
            // End if manually closed or no auto-reconnect
            if (this._manuallyClosed || !this.autoReconnect) {
                if (this.onEnd !== undefined) {
                    this.onEnd(e);
                }
                return;
            }
            if (this.onReconnect !== undefined) {
                this.onReconnect(e);
            }
            this._connect();
        };
    }
    _subUnsub(isSubscribe, scriptType, scriptPayload) {
        const encodedSubscription = proto.Subscription.encode({
            isSubscribe,
            scriptType,
            payload: (0, hex_1.fromHex)(scriptPayload),
        }).finish();
        if (this._ws === undefined)
            throw new Error('Invalid state; _ws is undefined');
        this._ws.send(encodedSubscription);
    }
    _subUnsubNode(isSubscribe, subscriptionObject) {
        const preparedSubscriptionObject = {};
        const { scriptType, scriptPayload } = subscriptionObject;
        if (typeof scriptType !== 'undefined' &&
            typeof scriptPayload !== 'undefined') {
            preparedSubscriptionObject.scriptType = scriptType;
            preparedSubscriptionObject.payload = (0, hex_1.fromHex)(scriptPayload);
        }
        const encodedSubscription = proto.SubscriptionNode.encode({
            isUnsubscribe: !isSubscribe,
            subscriptionObject: preparedSubscriptionObject,
        }).finish();
        if (this._ws === undefined)
            throw new Error('Invalid state; _ws is undefined');
        this._ws.send(encodedSubscription);
    }
    _handleMsg(wsMsg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.onMessage === undefined) {
                return;
            }
            const data = wsMsg.data instanceof Buffer
                ? wsMsg.data
                : new Uint8Array(yield wsMsg.data.arrayBuffer());
            const msg = proto.SubscribeMsg.decode(data);
            if (msg.error) {
                this.onMessage(Object.assign({ type: 'Error' }, msg.error));
            }
            else if (msg.AddedToMempool) {
                this.onMessage({
                    type: 'AddedToMempool',
                    txid: (0, hex_1.toHexRev)(msg.AddedToMempool.txid),
                });
            }
            else if (msg.RemovedFromMempool) {
                this.onMessage({
                    type: 'RemovedFromMempool',
                    txid: (0, hex_1.toHexRev)(msg.RemovedFromMempool.txid),
                });
            }
            else if (msg.Confirmed) {
                this.onMessage({
                    type: 'Confirmed',
                    txid: (0, hex_1.toHexRev)(msg.Confirmed.txid),
                });
            }
            else if (msg.Reorg) {
                this.onMessage({
                    type: 'Reorg',
                    txid: (0, hex_1.toHexRev)(msg.Reorg.txid),
                });
            }
            else if (msg.BlockConnected) {
                this.onMessage({
                    type: 'BlockConnected',
                    blockHash: (0, hex_1.toHexRev)(msg.BlockConnected.blockHash),
                });
            }
            else if (msg.BlockDisconnected) {
                this.onMessage({
                    type: 'BlockDisconnected',
                    blockHash: (0, hex_1.toHexRev)(msg.BlockDisconnected.blockHash),
                });
            }
            else {
                console.log('Silently ignored unknown Chronik message:', msg);
            }
        });
    }
}
exports.WsEndpoint = WsEndpoint;
function _get(url, path) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield axios_1.default.get(`${url}${path}`, {
            responseType: 'arraybuffer',
            validateStatus: undefined,
        });
        ensureResponseErrorThrown(response, path);
        return new Uint8Array(response.data);
    });
}
function _post(url, path, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield axios_1.default.post(`${url}${path}`, data, {
            responseType: 'arraybuffer',
            validateStatus: undefined,
            // Prevents Axios encoding the Uint8Array as JSON or something
            transformRequest: x => x,
            headers: {
                'Content-Type': 'application/x-protobuf',
            },
        });
        ensureResponseErrorThrown(response, path);
        return new Uint8Array(response.data);
    });
}
function ensureResponseErrorThrown(response, path) {
    if (response.status != 200) {
        const error = proto.Error.decode(new Uint8Array(response.data));
        throw new Error(`Failed getting ${path} (${error.errorCode}): ${error.msg}`);
    }
}
function convertToBlockchainInfo(blockchainInfo) {
    return {
        tipHash: (0, hex_1.toHexRev)(blockchainInfo.tipHash),
        tipHeight: blockchainInfo.tipHeight,
    };
}
function convertToBlock(block) {
    if (block.blockInfo === undefined) {
        throw new Error('Block has no blockInfo');
    }
    if (block.blockDetails === undefined) {
        // TODO support blockDetails with in-node chronik
        return { blockInfo: convertToBlockInfo(block.blockInfo) };
    }
    else {
        return {
            blockInfo: convertToBlockInfo(block.blockInfo),
            blockDetails: convertToBlockDetails(block.blockDetails),
            rawHeader: (0, hex_1.toHex)(block.rawHeader),
            txs: block.txs.map(convertToTx),
        };
    }
}
function convertToTx(tx) {
    const convertedTx = {
        txid: (0, hex_1.toHexRev)(tx.txid),
        version: tx.version,
        inputs: tx.inputs.map(convertToTxInput),
        outputs: tx.outputs.map(convertToTxOutput),
        lockTime: tx.lockTime,
        slpTxData: tx.slpTxData ? convertToSlpTxData(tx.slpTxData) : undefined,
        slpErrorMsg: tx.slpErrorMsg.length !== 0 ? tx.slpErrorMsg : undefined,
        block: tx.block !== undefined ? convertToBlockMeta(tx.block) : undefined,
        timeFirstSeen: tx.timeFirstSeen,
        size: tx.size,
        isCoinbase: tx.isCoinbase,
    };
    if (tx.network !== undefined) {
        convertedTx.network = convertToNetwork(tx.network);
    }
    return convertedTx;
}
function convertToUtxo(utxo) {
    if (utxo.outpoint === undefined) {
        throw new Error('UTXO outpoint is undefined');
    }
    const convertedUtxo = {
        outpoint: {
            txid: (0, hex_1.toHexRev)(utxo.outpoint.txid),
            outIdx: utxo.outpoint.outIdx,
        },
        blockHeight: utxo.blockHeight,
        isCoinbase: utxo.isCoinbase,
        value: utxo.value,
        slpMeta: utxo.slpMeta !== undefined
            ? convertToSlpMeta(utxo.slpMeta)
            : undefined,
        slpToken: utxo.slpToken !== undefined
            ? convertToSlpToken(utxo.slpToken)
            : undefined,
    };
    if (typeof utxo.isFinal !== 'undefined') {
        // If this is an in-node utxo
        convertedUtxo.isFinal = utxo.isFinal;
    }
    else {
        // If this is an nng utxo
        convertedUtxo.network =
            typeof utxo.network !== 'undefined'
                ? convertToNetwork(utxo.network)
                : undefined;
    }
    return convertedUtxo;
}
function convertToToken(token) {
    if (token.slpTxData === undefined) {
        throw new Error('Invalid proto, no slpTxData');
    }
    if (token.tokenStats === undefined) {
        throw new Error('Invalid proto, no tokenStats');
    }
    return {
        slpTxData: convertToSlpTokenTxData(token.slpTxData),
        tokenStats: token.tokenStats,
        block: token.block !== undefined
            ? convertToBlockMeta(token.block)
            : undefined,
        timeFirstSeen: token.timeFirstSeen,
        initialTokenQuantity: token.initialTokenQuantity,
        containsBaton: token.containsBaton,
        network: convertToNetwork(token.network),
    };
}
function convertToTxInput(input) {
    if (input.prevOut === undefined) {
        throw new Error('Invalid proto, no prevOut');
    }
    return {
        prevOut: {
            txid: (0, hex_1.toHexRev)(input.prevOut.txid),
            outIdx: input.prevOut.outIdx,
        },
        inputScript: (0, hex_1.toHex)(input.inputScript),
        outputScript: input.outputScript.length > 0
            ? (0, hex_1.toHex)(input.outputScript)
            : undefined,
        value: input.value,
        sequenceNo: input.sequenceNo,
        slpBurn: input.slpBurn !== undefined
            ? convertToSlpBurn(input.slpBurn)
            : undefined,
        slpToken: input.slpToken !== undefined
            ? convertToSlpToken(input.slpToken)
            : undefined,
    };
}
function convertToTxOutput(output) {
    return {
        value: output.value,
        outputScript: (0, hex_1.toHex)(output.outputScript),
        slpToken: output.slpToken !== undefined
            ? convertToSlpToken(output.slpToken)
            : undefined,
        spentBy: output.spentBy !== undefined
            ? {
                txid: (0, hex_1.toHexRev)(output.spentBy.txid),
                outIdx: output.spentBy.outIdx,
            }
            : undefined,
    };
}
function convertToSlpTxData(slpTxData) {
    if (slpTxData.slpMeta === undefined) {
        throw new Error('Invalid slpTxData: slpMeta is undefined');
    }
    return {
        slpMeta: convertToSlpMeta(slpTxData.slpMeta),
        genesisInfo: slpTxData.genesisInfo !== undefined
            ? convertToSlpGenesisInfo(slpTxData.genesisInfo)
            : undefined,
    };
}
function convertToSlpTokenTxData(slpTxData) {
    if (slpTxData.slpMeta === undefined) {
        throw new Error('Invalid slpTxData: slpMeta is undefined');
    }
    if (slpTxData.genesisInfo === undefined) {
        throw new Error('Invalid slpTxData: genesisInfo is undefined');
    }
    return {
        slpMeta: convertToSlpMeta(slpTxData.slpMeta),
        genesisInfo: convertToSlpGenesisInfo(slpTxData.genesisInfo),
    };
}
function convertToSlpMeta(slpMeta) {
    let tokenType;
    switch (slpMeta.tokenType) {
        case proto.SlpTokenType.FUNGIBLE:
            tokenType = 'FUNGIBLE';
            break;
        case proto.SlpTokenType.NFT1_GROUP:
            tokenType = 'NFT1_GROUP';
            break;
        case proto.SlpTokenType.NFT1_CHILD:
            tokenType = 'NFT1_CHILD';
            break;
        case proto.SlpTokenType.UNKNOWN_TOKEN_TYPE:
            tokenType = 'UNKNOWN_TOKEN_TYPE';
            break;
        default:
            throw new Error(`Invalid token type: ${slpMeta.tokenType}`);
    }
    let txType;
    switch (slpMeta.txType) {
        case proto.SlpTxType.GENESIS:
            txType = 'GENESIS';
            break;
        case proto.SlpTxType.SEND:
            txType = 'SEND';
            break;
        case proto.SlpTxType.MINT:
            txType = 'MINT';
            break;
        case proto.SlpTxType.BURN:
            txType = 'BURN';
            break;
        case proto.SlpTxType.UNKNOWN_TX_TYPE:
            txType = 'UNKNOWN_TX_TYPE';
            break;
        default:
            throw new Error(`Invalid slp tx type: ${slpMeta.txType}`);
    }
    return {
        tokenType,
        txType,
        tokenId: (0, hex_1.toHex)(slpMeta.tokenId),
        groupTokenId: slpMeta.groupTokenId.length == 32
            ? (0, hex_1.toHex)(slpMeta.groupTokenId)
            : undefined,
    };
}
function convertToSlpGenesisInfo(info) {
    const decoder = new TextDecoder();
    return {
        tokenTicker: decoder.decode(info.tokenTicker),
        tokenName: decoder.decode(info.tokenName),
        tokenDocumentUrl: decoder.decode(info.tokenDocumentUrl),
        tokenDocumentHash: (0, hex_1.toHex)(info.tokenDocumentHash),
        decimals: info.decimals,
    };
}
function convertToBlockMeta(block) {
    return {
        height: block.height,
        hash: (0, hex_1.toHexRev)(block.hash),
        timestamp: block.timestamp,
    };
}
function convertToBlockInfo(block) {
    return Object.assign(Object.assign({}, block), { hash: (0, hex_1.toHexRev)(block.hash), prevHash: (0, hex_1.toHexRev)(block.prevHash) });
}
function convertToBlockDetails(blockDetails) {
    return Object.assign(Object.assign({}, blockDetails), { merkleRoot: (0, hex_1.toHexRev)(blockDetails.merkleRoot) });
}
function convertToSlpBurn(burn) {
    if (burn.token === undefined) {
        throw new Error('Invalid burn: token is undefined');
    }
    return {
        token: convertToSlpToken(burn.token),
        tokenId: (0, hex_1.toHex)(burn.tokenId),
    };
}
function convertToSlpToken(token) {
    return {
        amount: token.amount,
        isMintBaton: token.isMintBaton,
    };
}
function convertToNetwork(network) {
    switch (network) {
        case proto.Network.BCH:
            return 'BCH';
        case proto.Network.XEC:
            return 'XEC';
        case proto.Network.XPI:
            return 'XPI';
        case proto.Network.XRG:
            return 'XRG';
        default:
            throw new Error(`Unknown network: ${network}`);
    }
}
function convertToUtxoStateVariant(variant) {
    switch (variant) {
        case proto.UtxoStateVariant.UNSPENT:
            return 'UNSPENT';
        case proto.UtxoStateVariant.SPENT:
            return 'SPENT';
        case proto.UtxoStateVariant.NO_SUCH_TX:
            return 'NO_SUCH_TX';
        case proto.UtxoStateVariant.NO_SUCH_OUTPUT:
            return 'NO_SUCH_OUTPUT';
        default:
            throw new Error(`Unknown UtxoStateVariant: ${variant}`);
    }
}
//# sourceMappingURL=index.js.map