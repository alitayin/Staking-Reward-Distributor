"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = __importStar(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const index_1 = require("../index");
const expect = chai.expect;
const assert = chai.assert;
chai.use(chai_as_promised_1.default);
const TEST_URL = 'https://chronik-native.fabien.cash';
const GENESIS_PK = '04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc' +
    '3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f';
const GENESIS_BLOCK_INFO = {
    hash: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f',
    prevHash: '0000000000000000000000000000000000000000000000000000000000000000',
    height: 0,
    nBits: 0x1d00ffff,
    timestamp: '1231006505',
    blockSize: '285',
    numTxs: '1',
    numInputs: '1',
    numOutputs: '1',
    sumInputSats: '0',
    sumCoinbaseOutputSats: '5000000000',
    sumNormalOutputSats: '0',
    sumBurnedSats: '0',
};
const GENESIS_BLOCK_DETAILS = {
    version: 1,
    merkleRoot: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
    nonce: '2083236893',
    medianTimestamp: '1231006505',
};
const GENESIS_TX = {
    txid: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
    version: 1,
    inputs: [
        {
            prevOut: {
                txid: '0000000000000000000000000000000000000000000000000000000000000000',
                outIdx: 0xffffffff,
            },
            inputScript: '04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e' +
                '63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420' +
                '666f722062616e6b73',
            outputScript: undefined,
            value: '0',
            sequenceNo: 0xffffffff,
            slpBurn: undefined,
            slpToken: undefined,
        },
    ],
    outputs: [
        {
            value: '5000000000',
            outputScript: '41' + GENESIS_PK + 'ac',
            slpToken: undefined,
            spentBy: undefined,
        },
    ],
    lockTime: 0,
    slpTxData: undefined,
    slpErrorMsg: undefined,
    block: {
        hash: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f',
        height: 0,
        timestamp: '1231006505',
    },
    size: 204,
    isCoinbase: true,
    timeFirstSeen: '0',
    network: 'BCH', // TODO in-node chronik should return 'XEC'
};
const GENESIS_UTXO = {
    outpoint: { txid: GENESIS_TX.txid, outIdx: 0 },
    blockHeight: 0,
    isCoinbase: true,
    value: '5000000000',
    slpMeta: undefined,
    slpToken: undefined,
    network: 'XEC',
};
describe('new ChronikClient', () => {
    it('throws if url ends with a slash', () => {
        expect(() => new index_1.ChronikClient('https://chronik.be.cash/xec/')).to.throw("`url` cannot end with '/', got: https://chronik.be.cash/xec/");
    });
    it('throws if url has wrong schema', () => {
        expect(() => new index_1.ChronikClient('soap://chronik.be.cash/xec')).to.throw("`url` must start with 'https://' or 'http://', got: " +
            'soap://chronik.be.cash/xec');
    });
});
describe('/broadcast-tx', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('throws a decode error', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik.broadcastTx('00000000'), Error, 'Failed getting /broadcast-tx (invalid-tx-encoding): Invalid tx ' +
            'encoding: Bytes error: Index 1 is out of bounds for array with ' +
            'length 0');
    }));
});
describe('/blockchain-info', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('gives us the blockchain info', () => __awaiter(void 0, void 0, void 0, function* () {
        const blockchainInfo = yield chronik.blockchainInfo();
        expect(blockchainInfo.tipHash.length).to.eql(64);
        expect(blockchainInfo.tipHeight).to.gte(739039);
    }));
});
describe('/block/:hash', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('gives us the Genesis block by hash', () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield chronik.block('000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f');
        expect(block.blockInfo).to.eql(GENESIS_BLOCK_INFO);
        expect(block.blockDetails).to.eql(undefined);
        expect(block.rawHeader).to.eql(undefined);
        expect(block.txs).to.eql(undefined);
    }));
    it('gives us the Genesis block by height', () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield chronik.block(0);
        expect(block.blockInfo).to.eql(GENESIS_BLOCK_INFO);
        expect(block.blockDetails).to.eql(undefined);
        expect(block.rawHeader).to.eql(undefined);
        expect(block.txs).to.eql(undefined);
    }));
});
describe('/blocks/:start/:end', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('gives us the first few blocks', () => __awaiter(void 0, void 0, void 0, function* () {
        const blocks = yield chronik.blocks(0, 10);
        expect(blocks.length).to.equal(11);
        const block0 = GENESIS_BLOCK_INFO;
        expect(blocks[0]).to.eql(block0);
        const block1 = Object.assign(Object.assign({}, block0), { hash: '00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048', prevHash: block0.hash, height: 1, timestamp: '1231469665', blockSize: '215' });
        expect(blocks[1]).to.eql(block1);
        const block2 = Object.assign(Object.assign({}, block1), { hash: '000000006a625f06636b8bb6ac7b960a8d03705d1ace08b1a19da3fdcc99ddbd', prevHash: block1.hash, height: 2, timestamp: '1231469744' });
        expect(blocks[2]).to.eql(block2);
        const block3 = Object.assign(Object.assign({}, block2), { hash: '0000000082b5015589a3fdf2d4baff403e6f0be035a5d9742c1cae6295464449', prevHash: block2.hash, height: 3, timestamp: '1231470173' });
        expect(blocks[3]).to.eql(block3);
    }));
});
describe('/tx/:txid', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('results in Not Found', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik.tx('0000000000000000000000000000000000000000000000000000000000000000'), Error, 'Failed getting tx ' +
            '0000000000000000000000000000000000000000000000000000000000000000: ' +
            'Txid not found: ' +
            '0000000000000000000000000000000000000000000000000000000000000000');
    }));
    it('results in the right tx', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = yield chronik.tx('0f3c3908a2ddec8dea91d2fe1f77295bbbb158af869bff345d44ae800f0a5498');
        expect(tx.txid).to.eql('0f3c3908a2ddec8dea91d2fe1f77295bbbb158af869bff345d44ae800f0a5498');
        expect(tx.version).to.eql(2);
        expect(tx.inputs).to.eql([
            {
                inputScript: '473044022042349e5e9e58c4c7b1fc9cbcdd1a1c9774b2ae95b7704ce40c7058ef' +
                    '14ba2854022022ba0cd4ead86982e7fc090ad06569a72c165efa3634feac4e722e' +
                    'ee405b92674121022d577b731fb05971d54951e4cb8bd11120327eba3e0fdd5a4d' +
                    '18f74a882df1a4',
                outputScript: '76a914d15b9793d6af77663f8acf7e2c884f114ef901da88ac',
                prevOut: {
                    txid: 'fbe9a326ea525013e11e3f6341b3e03d6ad189bac30f94d5ceaf24ef4388e069',
                    outIdx: 1,
                },
                sequenceNo: 4294967295,
                slpBurn: undefined,
                slpToken: undefined,
                value: '546',
            },
            {
                inputScript: '473044022076e0c764b7d5a5f738304fec1df97db4ba6fc35f8ccb2438de8aabff' +
                    '781edb5c022002016344d4432a5837569b9c764b88aa71f98dbfb76c48cbd0ad9f' +
                    '18dc15be0e4121022d577b731fb05971d54951e4cb8bd11120327eba3e0fdd5a4d' +
                    '18f74a882df1a4',
                outputScript: '76a914d15b9793d6af77663f8acf7e2c884f114ef901da88ac',
                prevOut: {
                    txid: '7ded3b52bbe20fc40d147a4e799fda91e589d29e017789ab6361e462dc972094',
                    outIdx: 0,
                },
                sequenceNo: 4294967295,
                slpBurn: undefined,
                slpToken: undefined,
                value: '100000',
            },
        ]);
        expect(tx.outputs).to.eql([
            {
                outputScript: '6a04534c500001010453454e44200daf200e3418f2df1158efef36fbb507f12928' +
                    'f1fdcf3543703e64e75a4a90730800000000004c4b40080000000002aea540',
                slpToken: undefined,
                spentBy: undefined,
                value: '0',
            },
            {
                outputScript: '76a9149c371def7e7cf89b30a62d658147937e679a965388ac',
                slpToken: undefined,
                spentBy: {
                    txid: '962ace9db1a36d06c129dffbe9a92bcf2eafe37d1a44aedfc6f957d2be69f149',
                    outIdx: 0,
                },
                value: '546',
            },
            {
                outputScript: '76a914e7b4f63ec550ada1aed74960ddc4e0e107cd6cd188ac',
                slpToken: undefined,
                spentBy: {
                    txid: '11ce5e4249c5b43927810129d887ce0df3bbde46d036998dff0180f94d2df6f8',
                    outIdx: 0,
                },
                value: '546',
            },
            {
                outputScript: '76a914d15b9793d6af77663f8acf7e2c884f114ef901da88ac',
                slpToken: undefined,
                spentBy: {
                    txid: '11ce5e4249c5b43927810129d887ce0df3bbde46d036998dff0180f94d2df6f8',
                    outIdx: 1,
                },
                value: '98938',
            },
        ]);
        expect(tx.lockTime).to.eql(0);
        expect(tx.slpTxData).to.eql(undefined); // TODO support slpTxData in in-node chronik
        expect(tx.slpErrorMsg).to.eql(undefined); // TODO support slpTxData in in-node chronik
        expect(tx.block).to.eql({
            hash: '0000000000000000452f19532a6297ea194eaacac6d3bbcbf7c08a74cad84b44',
            height: 697728,
            timestamp: '1627790415',
        });
        expect(tx.timeFirstSeen).to.eql('0');
        expect(tx.network).to.eql('BCH'); // TODO patch in-node chronik returning BCH for network bug
    }));
});
describe('/token/:tokenId is not supported in the node, results in error', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('existing tokenId gives error', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik.token('0daf200e3418f2df1158efef36fbb507f12928f1fdcf3543703e64e75a4a9073'), Error);
    }));
});
describe('/validate-utxos is not supported in the node, results in error', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('Correct input throws error as method is not supported in in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik.validateUtxos([
            {
                txid: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
                outIdx: 0,
            },
            {
                txid: '0f3c3908a2ddec8dea91d2fe1f77295bbbb158af869bff345d44ae800f0a5498',
                outIdx: 1,
            },
            {
                txid: '0f3c3908a2ddec8dea91d2fe1f77295bbbb158af869bff345d44ae800f0a5498',
                outIdx: 100,
            },
            {
                txid: '0000000000000000000000000000000000000000000000000000000000000000',
                outIdx: 100,
            },
        ]), Error);
    }));
});
describe('/script/:type/:payload/history', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('gives us the first page', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik.script('p2pk', GENESIS_PK);
        const history = yield script.history();
        expect(history.numPages).to.equal(1);
        expect(history.txs[history.txs.length - 1]).to.eql(GENESIS_TX);
    }));
    it('gives us an empty page for ?page=1', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik.script('p2pk', GENESIS_PK);
        const history = yield script.history(1);
        expect(history.numPages).to.equal(1);
        expect(history.txs).to.eql([]);
    }));
    it('gives us just one tx for ?page_size=1', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik.script('p2pk', GENESIS_PK);
        const history = yield script.history(undefined, 1);
        expect(history.numPages).to.equal(2);
        expect(history.txs.length).to.equal(1);
    }));
    it('gives us the Genesis tx for ?page=1&page_size=1', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik.script('p2pk', GENESIS_PK);
        const history = yield script.history(1, 1);
        expect(history.numPages).to.equal(2);
        expect(history.txs).to.eql([GENESIS_TX]);
    }));
});
describe('/script/:type/:payload/utxos', () => {
    const chronik = new index_1.ChronikClient(TEST_URL);
    it('gives us the UTXOs', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik.script('p2pk', GENESIS_PK);
        const utxos = yield script.utxos();
        expect(utxos.length).to.equal(1);
        expect(utxos[0].outputScript).to.eql('41' + GENESIS_PK + 'ac');
        expect(utxos[0].utxos[0]).to.eql(GENESIS_UTXO);
    }));
});
describe('/ws', () => {
    const chronik = new index_1.ChronikClient('https://chronik.be.cash/xpi');
    xit('gives us a confirmation', () => __awaiter(void 0, void 0, void 0, function* () {
        const promise = new Promise((resolve) => {
            const ws = chronik.ws({
                onMessage: msg => {
                    resolve(msg);
                    ws.close();
                },
            });
            ws.subscribe('p2pkh', 'b8ae1c47effb58f72f7bca819fe7fc252f9e852e');
        });
        const msg = yield promise;
        expect(msg.type).to.eql('Confirmed');
    }));
    it('connects to the ws', () => __awaiter(void 0, void 0, void 0, function* () {
        const promise = new Promise(resolve => {
            const ws = chronik.ws({});
            ws.waitForOpen().then(() => {
                resolve({});
                ws.close();
            });
        });
        yield promise;
    }));
});
//# sourceMappingURL=inNode.js.map