"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = __importStar(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const index_1 = require("../index");
const fixtures_1 = require("./fixtures");
const expect = chai.expect;
const assert = chai.assert;
chai.use(chai_as_promised_1.default);
const TEST_URL_NNG = 'https://chronik.be.cash/xec';
const TEST_URL_IN_NODE = 'https://chronik.be.cash/xec2';
describe('new ChronikClient', () => {
    it('throws if url ends with a slash', () => {
        expect(() => new index_1.ChronikClient('https://chronik.be.cash/xec/')).to.throw("`url` cannot end with '/', got: https://chronik.be.cash/xec/");
    });
    it('throws if url has wrong schema', () => {
        expect(() => new index_1.ChronikClient('soap://chronik.be.cash/xec')).to.throw("`url` must start with 'https://' or 'http://', got: " +
            'soap://chronik.be.cash/xec');
    });
});
describe('/broadcast-tx', () => {
    it('nng chronik throws a decode error', () => __awaiter(void 0, void 0, void 0, function* () {
        const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
        assert.isRejected(chronik_nng.broadcastTx('00000000'), Error, 'Failed getting /broadcast-tx (invalid-tx-encoding): Invalid tx ' +
            'encoding: Bytes error: Index 1 is out of bounds for array with ' +
            'length 0');
    }));
    it('in-node chronik throws error as /broadcast-tx endpoint does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
        const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
        assert.isRejected(chronik_in_node.broadcastTx('02000000010c8dabdfc27f4e43e4c99e5f5534f7c3465a9036445674fc05bcd8510437a81f000000006b4830450221008c86fe8d3fee5082c4429eef064a2063fcc1ea9216afd88cba1ff8cfe7b7083602204c1655728b1bbfc5ded78d46db00968a67e2f4c7c8072fe808feff4ccfd29d74412102560c43edaa6a058c9096c90ce5d4a3bbbf70fd18b2030d26614bc32379151de9ffffffff0194110000000000001976a9140b7d35fda03544a08e65464d54cfae4257eb6db788ac00000000'), Error);
    }));
});
describe('/blockchain-info', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    it('nng gives us the blockchain info', () => __awaiter(void 0, void 0, void 0, function* () {
        const blockchainInfo = yield chronik_nng.blockchainInfo();
        expect(blockchainInfo.tipHash.length).to.eql(64);
        expect(blockchainInfo.tipHeight).to.gte(739039);
    }));
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('in-node gives us the blockchain info', () => __awaiter(void 0, void 0, void 0, function* () {
        const blockchainInfo = yield chronik_in_node.blockchainInfo();
        expect(blockchainInfo.tipHash.length).to.eql(64);
        expect(blockchainInfo.tipHeight).to.gte(739039);
    }));
});
describe('/block/:hash', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    it('nng gives us the Genesis block by hash', () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield chronik_nng.block(fixtures_1.GENESIS_BLOCK_INFO.hash);
        expect(block.blockInfo).to.eql(fixtures_1.GENESIS_BLOCK_INFO);
        expect(block.blockDetails).to.eql(fixtures_1.GENESIS_BLOCK_DETAILS);
        expect(block.txs).to.eql([fixtures_1.GENESIS_TX]);
    }));
    it('nng gives us the Genesis block by height', () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield chronik_nng.block(0);
        expect(block.blockInfo).to.eql(fixtures_1.GENESIS_BLOCK_INFO);
        expect(block.blockDetails).to.eql(fixtures_1.GENESIS_BLOCK_DETAILS);
        expect(block.txs).to.eql([fixtures_1.GENESIS_TX]);
    }));
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('in-node gives us the Genesis block by hash, less BlockDetails, rawHeader, and txs', () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield chronik_in_node.block(fixtures_1.GENESIS_BLOCK_INFO.hash);
        expect(block.blockInfo).to.eql(fixtures_1.GENESIS_BLOCK_INFO);
    }));
    it('in-node gives us the Genesis block by height, less BlockDetails, rawHeader, and txs', () => __awaiter(void 0, void 0, void 0, function* () {
        const block = yield chronik_in_node.block(0);
        expect(block.blockInfo).to.eql(fixtures_1.GENESIS_BLOCK_INFO);
    }));
});
describe('/blocks/:start/:end', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('nng and in-node give us the first few blocks', () => __awaiter(void 0, void 0, void 0, function* () {
        const blocks = yield chronik_nng.blocks(0, 10);
        const blocks_in_node = yield chronik_in_node.blocks(0, 10);
        expect(blocks).to.eql(blocks_in_node);
        expect(blocks.length).to.equal(11);
        const block0 = fixtures_1.GENESIS_BLOCK_INFO;
        expect(blocks[0]).to.eql(block0);
        const block1 = Object.assign(Object.assign({}, block0), { hash: '00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048', prevHash: block0.hash, height: 1, timestamp: '1231469665', blockSize: '215' });
        expect(blocks[1]).to.eql(block1);
        const block2 = Object.assign(Object.assign({}, block1), { hash: '000000006a625f06636b8bb6ac7b960a8d03705d1ace08b1a19da3fdcc99ddbd', prevHash: block1.hash, height: 2, timestamp: '1231469744' });
        expect(blocks[2]).to.eql(block2);
        const block3 = Object.assign(Object.assign({}, block2), { hash: '0000000082b5015589a3fdf2d4baff403e6f0be035a5d9742c1cae6295464449', prevHash: block2.hash, height: 3, timestamp: '1231470173' });
        expect(blocks[3]).to.eql(block3);
    }));
});
describe('/tx/:txid', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('for nng and in-node, zero txid results in Not Found', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik_nng.tx('0000000000000000000000000000000000000000000000000000000000000000'), Error, 'Failed getting tx ' +
            '0000000000000000000000000000000000000000000000000000000000000000: ' +
            'Txid not found: ' +
            '0000000000000000000000000000000000000000000000000000000000000000');
        assert.isRejected(chronik_in_node.tx('0000000000000000000000000000000000000000000000000000000000000000'), Error, 'Failed getting tx ' +
            '0000000000000000000000000000000000000000000000000000000000000000: ' +
            'Txid not found: ' +
            '0000000000000000000000000000000000000000000000000000000000000000');
    }));
    it('nng call for existing txid results in the right tx', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = yield chronik_nng.tx(fixtures_1.TEST_TX_NNG.txid);
        expect(tx).to.eql(fixtures_1.TEST_TX_NNG);
    }));
    it('in-node call for existing txid results in the right tx', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = yield chronik_in_node.tx(fixtures_1.TEST_TX_IN_NODE.txid);
        expect(tx).to.eql(fixtures_1.TEST_TX_IN_NODE);
    }));
});
describe('/token/:tokenId', () => {
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('route does not exist for in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik_in_node.token('0daf200e3418f2df1158efef36fbb507f12928f1fdcf3543703e64e75a4a9073'), Error);
    }));
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    it('results in Not Found', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik_nng.token('0000000000000000000000000000000000000000000000000000000000000000'), Error);
    }));
    it('results in Not Found', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik_nng.token('0f3c3908a2ddec8dea91d2fe1f77295bbbb158af869bff345d44ae800f0a5498'), Error);
    }));
    it('gives us a token', () => __awaiter(void 0, void 0, void 0, function* () {
        const token = yield chronik_nng.token('0daf200e3418f2df1158efef36fbb507f12928f1fdcf3543703e64e75a4a9073');
        expect(token.slpTxData).to.eql({
            genesisInfo: {
                decimals: 4,
                tokenDocumentHash: '',
                tokenDocumentUrl: 'https://www.raiusd.co/etoken',
                tokenName: 'RaiUSD',
                tokenTicker: 'USDR',
            },
            slpMeta: {
                groupTokenId: undefined,
                tokenId: '0daf200e3418f2df1158efef36fbb507f12928f1fdcf3543703e64e75a4a9073',
                tokenType: 'FUNGIBLE',
                txType: 'GENESIS',
            },
        });
        expect(token.block).to.eql({
            hash: '00000000000000002686aa5ffa8401c7ed67338fb9475561b2fa9817d6571da8',
            height: 697721,
            timestamp: '1627783243',
        });
        expect(token.timeFirstSeen).to.eql('0');
        expect(token.initialTokenQuantity).to.eql('0');
        expect(token.containsBaton).to.eql(true);
        expect(token.network).to.eql('XEC');
    }));
});
describe('/validate-utxos', () => {
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('Correct input throws error as method is not supported in in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        assert.isRejected(chronik_in_node.validateUtxos(fixtures_1.VALIDATION_UTXOS), Error);
    }));
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    it('validates the UTXOs', () => __awaiter(void 0, void 0, void 0, function* () {
        const validationResult = yield chronik_nng.validateUtxos(fixtures_1.VALIDATION_UTXOS);
        const expectedResult = [
            {
                height: 0,
                isConfirmed: true,
                state: 'UNSPENT',
            },
            {
                height: 697728,
                isConfirmed: true,
                state: 'SPENT',
            },
            {
                height: 697728,
                isConfirmed: true,
                state: 'NO_SUCH_OUTPUT',
            },
            {
                height: -1,
                isConfirmed: false,
                state: 'NO_SUCH_TX',
            },
        ];
        expect(validationResult).to.eql(expectedResult);
    }));
});
describe('/script/:type/:payload/history', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('gives us the first page, including numTxs for in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik_nng.script('p2pk', fixtures_1.GENESIS_PK);
        const history = yield script.history();
        expect(history.numPages).to.equal(1);
        expect(history.txs[history.txs.length - 1]).to.eql(fixtures_1.GENESIS_TX);
        const scriptNode = chronik_in_node.script('p2pk', fixtures_1.GENESIS_PK);
        const historyNode = yield scriptNode.history();
        expect(historyNode.numPages).to.equal(1);
        expect(historyNode.numTxs).to.equal(2);
        expect(historyNode.txs[historyNode.txs.length - 1]).to.eql(fixtures_1.GENESIS_TX_IN_NODE);
    }));
    it('gives us an empty page for ?page=1, including numTxs for in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik_nng.script('p2pk', fixtures_1.GENESIS_PK);
        const history = yield script.history(1);
        expect(history.numPages).to.equal(1);
        expect(history.txs).to.eql([]);
        const scriptNode = chronik_in_node.script('p2pk', fixtures_1.GENESIS_PK);
        const historyNode = yield scriptNode.history(1);
        expect(historyNode.numPages).to.equal(1);
        expect(historyNode.numTxs).to.equal(2);
        expect(historyNode.txs).to.eql([]);
    }));
    it('gives us just one tx for ?page_size=1, including numTxs for in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik_nng.script('p2pk', fixtures_1.GENESIS_PK);
        const history = yield script.history(undefined, 1);
        expect(history.numPages).to.equal(2);
        expect(history.txs.length).to.equal(1);
        const scriptNode = chronik_in_node.script('p2pk', fixtures_1.GENESIS_PK);
        const historyNode = yield scriptNode.history(undefined, 1);
        expect(historyNode.numPages).to.equal(2);
        expect(historyNode.numTxs).to.equal(2);
        expect(historyNode.txs.length).to.eql(1);
    }));
    it('gives us the Genesis tx for ?page=1&page_size=1, including numTxs for in-node chronik', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik_nng.script('p2pk', fixtures_1.GENESIS_PK);
        const history = yield script.history(1, 1);
        expect(history.numPages).to.equal(2);
        expect(history.txs).to.eql([fixtures_1.GENESIS_TX]);
        const scriptNode = chronik_in_node.script('p2pk', fixtures_1.GENESIS_PK);
        const historyNode = yield scriptNode.history(1, 1);
        expect(historyNode.numPages).to.equal(2);
        expect(historyNode.numTxs).to.equal(2);
        expect(historyNode.txs).to.eql([fixtures_1.GENESIS_TX_IN_NODE]);
    }));
});
describe('/script/:type/:payload/utxos', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('gives us the UTXOs', () => __awaiter(void 0, void 0, void 0, function* () {
        const script = chronik_nng.script('p2pk', fixtures_1.GENESIS_PK);
        const utxos = yield script.utxos();
        expect(utxos.length).to.equal(1);
        expect(utxos[0].outputScript).to.eql('41' + fixtures_1.GENESIS_PK + 'ac');
        expect(utxos[0].utxos[0]).to.eql(fixtures_1.GENESIS_UTXO);
        const scriptNode = chronik_in_node.script('p2pk', fixtures_1.GENESIS_PK);
        const utxosNode = yield scriptNode.utxos();
        expect(utxosNode.length).to.equal(1);
        expect(utxosNode[0].outputScript).to.eql('41' + fixtures_1.GENESIS_PK + 'ac');
        expect(utxosNode[0].utxos[0]).to.eql(fixtures_1.GENESIS_UTXO_IN_NODE);
    }));
});
describe('/ws', () => {
    const chronik_nng = new index_1.ChronikClient(TEST_URL_NNG);
    xit('nng chronik server gives us a confirmation', () => __awaiter(void 0, void 0, void 0, function* () {
        const promise = new Promise((resolve) => {
            const ws = chronik_nng.ws({
                onMessage: msg => {
                    resolve(msg);
                    ws.close();
                },
            });
            ws.subscribe('p2pkh', 'b8ae1c47effb58f72f7bca819fe7fc252f9e852e');
        });
        const msg = yield promise;
        expect(msg.type).to.eql('Confirmed');
    }));
    it('nng chronik client connects to the ws', () => __awaiter(void 0, void 0, void 0, function* () {
        const promise = new Promise(resolve => {
            const ws = chronik_nng.ws({});
            ws.waitForOpen().then(() => {
                resolve({});
                ws.close();
            });
        });
        yield promise;
    }));
    const chronik_in_node = new index_1.ChronikClient(TEST_URL_IN_NODE);
    it('in-node chronik client connects to the ws', () => __awaiter(void 0, void 0, void 0, function* () {
        const promise = new Promise(resolve => {
            const ws = chronik_in_node.ws({});
            ws.waitForOpen().then(() => {
                resolve({});
                ws.close();
            });
        });
        yield promise;
    }));
});
//# sourceMappingURL=test.js.map