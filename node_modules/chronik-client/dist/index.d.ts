import * as ws from 'ws';
/** Client to access an NNG Chronik or in-node instance. Plain object, without any
 * connections. */
export declare class ChronikClient {
    private _url;
    private _wsUrl;
    /**
     * Create a new client. This just creates an object, without any connections.
     *
     * @param url Url of a Chronik instance, with schema and without trailing
     *            slash. E.g. https://chronik.be.cash/xec.
     */
    constructor(url: string);
    /** Broadcasts the `rawTx` on the network.
     * If `skipSlpCheck` is false, it will be checked that the tx doesn't burn
     * any SLP tokens before broadcasting.
     */
    broadcastTx(rawTx: Uint8Array | string, skipSlpCheck?: boolean): Promise<{
        txid: string;
    }>;
    /** Broadcasts the `rawTxs` on the network, only if all of them are valid.
     * If `skipSlpCheck` is false, it will be checked that the txs don't burn
     * any SLP tokens before broadcasting.
     */
    broadcastTxs(rawTxs: (Uint8Array | string)[], skipSlpCheck?: boolean): Promise<{
        txids: string[];
    }>;
    /** Fetch current info of the blockchain, such as tip hash and height. */
    blockchainInfo(): Promise<BlockchainInfo>;
    /** Fetch the block given hash or height. */
    block(hashOrHeight: string | number): Promise<Block>;
    /** Fetch block info of a range of blocks. `startHeight` and `endHeight` are
     * inclusive ranges. */
    blocks(startHeight: number, endHeight: number): Promise<BlockInfo[]>;
    /** Fetch tx details given the txid. */
    tx(txid: string): Promise<Tx>;
    /** Fetch token info and stats given the tokenId. */
    token(tokenId: string): Promise<Token>;
    /** Validate the given outpoints: whether they are unspent, spent or
     * never existed. */
    validateUtxos(outpoints: OutPoint[]): Promise<UtxoState[]>;
    /** Create object that allows fetching script history or UTXOs. */
    script(scriptType: ScriptType, scriptPayload: string): ScriptEndpoint;
    /** Open a WebSocket connection to listen for updates. */
    ws(config: WsConfig): WsEndpoint;
}
/** Allows fetching script history and UTXOs. */
export declare class ScriptEndpoint {
    private _url;
    private _scriptType;
    private _scriptPayload;
    constructor(url: string, scriptType: string, scriptPayload: string);
    /** Fetches the tx history of this script, in anti-chronological order.
     * This means it's ordered by first-seen first. If the tx hasn't been seen
     * by the indexer before, it's ordered by the block timestamp.
     * @param page Page index of the tx history.
     * @param pageSize Number of txs per page.
     */
    history(page?: number, pageSize?: number): Promise<TxHistoryPage>;
    /** Fetches the current UTXO set for this script.
     * It is grouped by output script, in case a script type can match multiple
     * different output scripts (e.g. Taproot on Lotus). */
    utxos(): Promise<ScriptUtxos[]>;
}
/** Config for a WebSocket connection to Chronik. */
export interface WsConfig {
    /** Fired when a message is sent from the WebSocket. */
    onMessage?: (msg: SubscribeMsg) => void;
    /** Fired when a connection has been (re)established. */
    onConnect?: (e: ws.Event) => void;
    /** Fired after a connection has been unexpectedly closed, and before a
     * reconnection attempt is made. Only fired if `autoReconnect` is true. */
    onReconnect?: (e: ws.Event) => void;
    /** Fired when an error with the WebSocket occurs. */
    onError?: (e: ws.ErrorEvent) => void;
    /** Fired after a connection has been manually closed, or if `autoReconnect`
     * is false, if the WebSocket disconnects for any reason. */
    onEnd?: (e: ws.Event) => void;
    /** Whether to automatically reconnect on disconnect, default true. */
    autoReconnect?: boolean;
}
interface SubscriptionObject {
    scriptType?: ScriptType;
    scriptPayload?: string;
}
/** WebSocket connection to Chronik. */
export declare class WsEndpoint {
    /** Fired when a message is sent from the WebSocket. */
    onMessage?: (msg: SubscribeMsg) => void;
    /** Fired when a connection has been (re)established. */
    onConnect?: (e: ws.Event) => void;
    /** Fired after a connection has been unexpectedly closed, and before a
     * reconnection attempt is made. Only fired if `autoReconnect` is true. */
    onReconnect?: (e: ws.Event) => void;
    /** Fired when an error with the WebSocket occurs. */
    onError?: (e: ws.ErrorEvent) => void;
    /** Fired after a connection has been manually closed, or if `autoReconnect`
     * is false, if the WebSocket disconnects for any reason. */
    onEnd?: (e: ws.Event) => void;
    /** Whether to automatically reconnect on disconnect, default true. */
    autoReconnect: boolean;
    private _ws;
    private _wsUrl;
    private _connected;
    private _manuallyClosed;
    private _subs;
    private _subsNode;
    constructor(wsUrl: string, config: WsConfig);
    /** Wait for the WebSocket to be connected. */
    waitForOpen(): Promise<void>;
    /** Subscribe to the given script type and payload.
     * For "p2pkh", `scriptPayload` is the 20 byte public key hash. */
    subscribe(scriptType: ScriptType, scriptPayload: string): void;
    subscribeNode(subscriptionObject: SubscriptionObject): void;
    /** Unsubscribe from the given script type and payload. */
    unsubscribe(scriptType: ScriptType, scriptPayload: string): void;
    unsubscribeNode(subscriptionObject: SubscriptionObject): void;
    /** Close the WebSocket connection and prevent future any reconnection
     * attempts. */
    close(): void;
    private _connect;
    private _subUnsub;
    private _subUnsubNode;
    private _handleMsg;
}
/** Current state of the blockchain. */
export interface BlockchainInfo {
    /** Block hash of the current blockchain tip */
    tipHash: string;
    /** Current height of the blockchain */
    tipHeight: number;
}
/** A transaction on the blockchain or in the mempool. */
export interface Tx {
    /** Transaction ID.
     * - On BCH, eCash and Ergon, this is the hash of the tx.
     * - On Lotus, this is a special serialization, omitting the input scripts.
     */
    txid: string;
    /** `version` field of the transaction. */
    version: number;
    /** Inputs of this transaction. */
    inputs: TxInput[];
    /** Outputs of this transaction. */
    outputs: TxOutput[];
    /** `locktime` field of the transaction, tx is not valid before this time. */
    lockTime: number;
    /** SLP data about this transaction, if valid. */
    slpTxData: SlpTxData | undefined;
    /** A human-readable message as to why this tx is not an SLP transaction,
     * unless trivially so. */
    slpErrorMsg: string | undefined;
    /** Block data for this tx, or undefined if not mined yet. */
    block: BlockMetadata | undefined;
    /** UNIX timestamp when this tx has first been seen in the mempool.
     * 0 if unknown -> make sure to check.
     */
    timeFirstSeen: string;
    /** Serialized size of the tx. */
    size: number;
    /** Whether this tx is a coinbase tx. */
    isCoinbase: boolean;
    /** Which network this tx is on. */
    network?: Network;
}
/** An unspent transaction output (aka. UTXO, aka. "Coin") of a script. */
export interface Utxo {
    /** Outpoint of the UTXO. */
    outpoint: OutPoint;
    /** Which block this UTXO is in, or -1 if in the mempool. */
    blockHeight: number;
    /** Whether this UTXO is a coinbase UTXO
     * (make sure it's buried 100 blocks before spending!) */
    isCoinbase: boolean;
    /** Value of the UTXO in satoshis. */
    value: string;
    /** SLP data in this UTXO. */
    slpMeta: SlpMeta | undefined;
    /** SLP token of this UTXO (i.e. SLP amount + whether it's a mint baton). */
    slpToken: SlpToken | undefined;
    /** Which network this UTXO is on. */
    network?: Network;
    /** For in-node chronik, is this avalanche finalized? */
    isFinal?: boolean | undefined;
}
/** Data and stats about an SLP token. */
export interface Token {
    /** SLP data of the GENESIS transaction. */
    slpTxData: SlpTokenTxData;
    /** Current stats about this token, e.g. minted and burned amount. */
    tokenStats: TokenStats;
    /** Block the GENESIS transaction has been mined in, or undefined if not mined yet. */
    block: BlockMetadata | undefined;
    /** UNIX timestamp when the GENESIS transaction has first been seen in the mempool.
     * 0 if unknown. */
    timeFirstSeen: string;
    /** How many tokens have been mined in the GENESIS transaction. */
    initialTokenQuantity: string;
    /** Whether the GENESIS transaction created a mint baton.
     * Note: This doesn't indicate whether the mint baton is still alive. */
    containsBaton: boolean;
    /** Which network this token is on. */
    network: Network;
}
/** Block info about a block */
export interface BlockInfo {
    /** Block hash of the block, in 'human-readable' (big-endian) hex encoding. */
    hash: string;
    /** Block hash of the previous block, in 'human-readable' (big-endian) hex
     * encoding. */
    prevHash: string;
    /** Height of the block; Genesis block has height 0. */
    height: number;
    /** nBits field of the block, encodes the target compactly. */
    nBits: number;
    /** Timestamp of the block. Filled in by the miner, so might not be 100%
     * precise. */
    timestamp: string;
    /** Block size of this block in bytes (including headers etc.). */
    blockSize: string;
    /** Number of txs in this block. */
    numTxs: string;
    /** Total number of tx inputs in block (including coinbase). */
    numInputs: string;
    /** Total number of tx output in block (including coinbase). */
    numOutputs: string;
    /** Total number of satoshis spent by tx inputs. */
    sumInputSats: string;
    /** Total block reward for this block. */
    sumCoinbaseOutputSats: string;
    /** Total number of satoshis in non-coinbase tx outputs. */
    sumNormalOutputSats: string;
    /** Total number of satoshis burned using OP_RETURN. */
    sumBurnedSats: string;
}
/** Additional details about a block. */
export interface BlockDetails {
    /** nVersion field of the block. */
    version: number;
    /** Merkle root of the block. */
    merkleRoot: string;
    /** Nonce of the block (32-bit on XEC, 64-bit on XPI). */
    nonce: string;
    /** Median-time-past (MTP) of the last 11 blocks. */
    medianTimestamp: string;
}
/** Block on the blockchain. */
export interface Block {
    /** Info about the block. */
    blockInfo: BlockInfo;
    /** Details about the block. */
    blockDetails?: BlockDetails | undefined;
    /** Header encoded as hex. */
    rawHeader?: string | undefined;
    /** Txs in this block, in canonical order
     * (at least on all supported chains). */
    txs?: Tx[] | undefined;
}
/** Group of UTXOs by output script. */
export interface ScriptUtxos {
    /** Output script in hex. */
    outputScript: string;
    /** UTXOs of the output script. */
    utxos: Utxo[];
}
/** Page of the transaction history. */
export interface TxHistoryPage {
    /** Txs of this page. */
    txs: Tx[];
    /** Number of pages of the entire transaction history.
     * This changes based on the `pageSize` provided. */
    numPages: number;
    numTxs?: number | undefined;
}
/** SLP data about an SLP transaction. */
export interface SlpTxData {
    /** SLP metadata. */
    slpMeta: SlpMeta;
    /** Genesis info, only present for GENESIS txs. */
    genesisInfo: SlpGenesisInfo | undefined;
}
/** SLP data about an SLP transaction. */
export interface SlpTokenTxData {
    /** SLP metadata. */
    slpMeta: SlpMeta;
    /** Genesis info of the token. */
    genesisInfo: SlpGenesisInfo;
}
/** Metadata about an SLP tx or UTXO. */
export interface SlpMeta {
    /** Whether this token is a normal fungible token, or an NFT or unknown. */
    tokenType: SlpTokenType;
    /** Whether this tx is a GENESIS, MINT, SEND or UNKNOWN transaction. */
    txType: SlpTxType;
    /** Token ID of this tx/UTXO, in human-readable (big-endian) hex encoding. */
    tokenId: string;
    /** Group token ID of this tx/UTXO, NFT only, in human-readable
     * (big-endian) hex encoding.
     * This is the token ID of the token that went into the GENESIS of this token
     * as first input. */
    groupTokenId: string | undefined;
}
/**
 * Stats about a token.
 *
 * `totalMinted` and `totalBurned` don't fit in a 64-bit integer, therefore we
 * use a string with the decimal representation.
 */
export interface TokenStats {
    /** Total number of tokens minted (including GENESIS). */
    totalMinted: string;
    /** Total number of tokens burned. */
    totalBurned: string;
}
/** Input of a tx, spends an output of a previous tx. */
export interface TxInput {
    /** Points to an output spent by this input. */
    prevOut: OutPoint;
    /** Script unlocking the output, in hex encoding.
     * Aka. `scriptSig` in bitcoind parlance. */
    inputScript: string;
    /** Script of the output, in hex encoding.
     * Aka. `scriptPubKey` in bitcoind parlance. */
    outputScript: string | undefined;
    /** Value of the output spent by this input, in satoshis. */
    value: string;
    /** `sequence` field of the input; can be used for relative time locking. */
    sequenceNo: number;
    /** SLP tokens burned by this input, or `undefined` if no burn occured. */
    slpBurn: SlpBurn | undefined;
    /** SLP tokens spent by this input, or `undefined` if the tokens were burned
     * or if there were no tokens in the output spent by this input. */
    slpToken: SlpToken | undefined;
}
/** Output of a tx, creates new UTXOs. */
export interface TxOutput {
    /** Value of the output, in satoshis. */
    value: string;
    /** Script of this output, locking the coins.
     * Aka. `scriptPubKey` in bitcoind parlance. */
    outputScript: string;
    /** SLP tokens locked up in this output, or `undefined` if no tokens were sent
     * to this output. */
    slpToken: SlpToken | undefined;
    /** Transaction & input index spending this output, or undefined if
     * unspent. */
    spentBy: OutPoint | undefined;
}
/** Metadata of a block, used in transaction data. */
export interface BlockMetadata {
    /** Height of the block. */
    height: number;
    /** Hash of the block. */
    hash: string;
    /** Timestamp of the block; useful if `timeFirstSeen` of a transaction is
     * unknown. */
    timestamp: string;
}
/** Outpoint referencing an output on the blockchain (or input for field
 * `spentBy`). */
export interface OutPoint {
    /** Transaction referenced by this outpoint. */
    txid: string;
    /** Index of the output in the tx referenced by this outpoint
     * (or input index if used in field `spentBy`). */
    outIdx: number;
}
/** SLP amount or whether this is a mint baton, for inputs and outputs. */
export interface SlpToken {
    /** SLP amount of the input or output, in base units. */
    amount: string;
    /** Whether this input/output is a mint baton. */
    isMintBaton: boolean;
}
/** SLP burn; indicates burn of some tokens. */
export interface SlpBurn {
    /** SLP amount/mint baton burned by this burn. */
    token: SlpToken;
    /** Token ID of the burned SLP tokens, in human-readable (big-endian) hex
     * encoding. */
    tokenId: string;
}
/** SLP info about a GENESIS transaction. */
export interface SlpGenesisInfo {
    /** Ticker of the token, decoded as UTF-8. */
    tokenTicker: string;
    /** Name of the token, decoded as UTF-8. */
    tokenName: string;
    /** URL of the token, decoded as UTF-8. */
    tokenDocumentUrl: string;
    /** Document hash of the token, encoded in hex (byte order as occuring in the
     * OP_RETURN). */
    tokenDocumentHash: string;
    /** Number of decimals of the GENESIS transaction. */
    decimals: number;
}
/** State of a UTXO (from `validateUtxos`). */
export interface UtxoState {
    /** Height of the UTXO. -1 if the tx doesn't exist or is unconfirmed.
     * If it's confirmed (or if the output doesn't exist but the tx does),
     * it's the height of the block confirming the tx. */
    height: number;
    /** Whether the UTXO or the transaction queried is confirmed. */
    isConfirmed: boolean;
    /** State of the UTXO, can be unconfirmed, confirmed, tx doesn't exist or
     * output doesn't exist. */
    state: UtxoStateVariant;
}
/** Message returned from the WebSocket. */
export declare type SubscribeMsg = Error | MsgAddedToMempool | MsgRemovedFromMempool | MsgConfirmed | MsgReorg | MsgBlockConnected | MsgBlockDisconnected;
/** A transaction has been added to the mempool. */
export interface MsgAddedToMempool {
    type: 'AddedToMempool';
    /** txid of the transaction, in 'human-readable' (big-endian) hex encoding. */
    txid: string;
}
/** A transaction has been removed from the mempool,
 * but not because of a confirmation (e.g. expiry, conflict, etc.).
 */
export interface MsgRemovedFromMempool {
    type: 'RemovedFromMempool';
    /** txid of the transaction, in 'human-readable' (big-endian) hex encoding. */
    txid: string;
}
/** A transaction has been confirmed in a block. */
export interface MsgConfirmed {
    type: 'Confirmed';
    /** txid of the transaction, in 'human-readable' (big-endian) hex encoding. */
    txid: string;
}
/** A transaction used to be part of a block but now got re-orged.
 * Usually, unless something malicious occurs, a "Confirmed" message is sent
 * immediately afterwards.
 */
export interface MsgReorg {
    type: 'Reorg';
    /** txid of the transaction, in 'human-readable' (big-endian) hex encoding. */
    txid: string;
}
/** A new block has been added to the chain. Sent regardless of subscriptions. */
export interface MsgBlockConnected {
    type: 'BlockConnected';
    /** block hash of the block, in 'human-readable' (big-endian) hex encoding. */
    blockHash: string;
}
/** A block has been removed from the chain. Sent regardless of subscriptions. */
export interface MsgBlockDisconnected {
    type: 'BlockDisconnected';
    /** block hash of the block, in 'human-readable' (big-endian) hex encoding. */
    blockHash: string;
}
/** Reports an error, e.g. when a subscription is malformed. */
export interface Error {
    type: 'Error';
    /** Code for this error, e.g. "tx-not-found". */
    errorCode: string;
    /** Human-readable message for this error. */
    msg: string;
    /** Whether this error is presentable to an end-user.
     * This is somewhat subjective, but can be used as a good heuristic. */
    isUserError: boolean;
}
/** Different networks of txs/blocks/UTXOs.
 * Supported are BCH, eCash, Lotus and Ergon. */
export declare type Network = 'BCH' | 'XEC' | 'XPI' | 'XRG';
/** Which SLP tx type. */
export declare type SlpTxType = 'GENESIS' | 'SEND' | 'MINT' | 'BURN' | 'UNKNOWN_TX_TYPE';
/** Which SLP token type (normal fungible, NFT, unknown). */
export declare type SlpTokenType = 'FUNGIBLE' | 'NFT1_GROUP' | 'NFT1_CHILD' | 'UNKNOWN_TOKEN_TYPE';
/** State of a transaction output.
 * - `UNSPENT`: The UTXO is unspent.
 * - `SPENT`: The output is spent and no longer part of the UTXO set.
 * - `NO_SUCH_TX`: The tx queried does not exist.
 * - `NO_SUCH_OUTPUT`: The output queried does not exist, but the tx does exist.
 */
export declare type UtxoStateVariant = 'UNSPENT' | 'SPENT' | 'NO_SUCH_TX' | 'NO_SUCH_OUTPUT';
/** Script type queried in the `script` method.
 * - `other`: Script type not covered by the standard script types; payload is
 *   the raw hex.
 * - `p2pk`: Pay-to-Public-Key (`<pk> OP_CHECKSIG`), payload is the hex of the
 *   pubkey (compressed (33 bytes) or uncompressed (65 bytes)).
 * - `p2pkh`: Pay-to-Public-Key-Hash
 *   (`OP_DUP OP_HASH160 <pkh> OP_EQUALVERIFY OP_CHECKSIG`).
 *   Payload is the 20 byte public key hash.
 * - `p2sh`: Pay-to-Script-Hash (`OP_HASH160 <sh> OP_EQUAL`).
 *   Payload is the 20 byte script hash.
 * - `p2tr-commitment`: Pay-to-Taproot
 *   (`OP_SCRIPTTYPE OP_1 <commitment> <state>?`), only on Lotus.
 *   Queries by the commitment. Payload is the 33 byte commitment.
 * - `p2tr-state`: Pay-to-Taproot (`OP_SCRIPTTYPE OP_1 <commitment> <state>`),
 *   only on Lotus. Queries by the state. Payload is the 32 byte state.
 */
export declare type ScriptType = 'other' | 'p2pk' | 'p2pkh' | 'p2sh' | 'p2tr-commitment' | 'p2tr-state';
export {};
//# sourceMappingURL=index.d.ts.map